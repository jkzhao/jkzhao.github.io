<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jkzhao&#39;s blog</title>
  <subtitle>学习 总结 思考</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-24T03:27:19.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhao Jiankai</name>
    <email>jk.zhaocoder@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于mysqldump做备份恢复</title>
    <link href="http://yoursite.com/2018/04/21/%E5%9F%BA%E4%BA%8Emysqldump%E5%81%9A%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"/>
    <id>http://yoursite.com/2018/04/21/基于mysqldump做备份恢复/</id>
    <published>2018-04-21T00:17:27.000Z</published>
    <updated>2018-04-24T03:27:19.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;备份和恢复概念&quot;&gt;&lt;a href=&quot;#备份和恢复概念&quot; class=&quot;headerlink&quot; title=&quot;备份和恢复概念&quot;&gt;&lt;/a&gt;备份和恢复概念&lt;/h2&gt;&lt;h3 id=&quot;备份和恢复的意义&quot;&gt;&lt;a href=&quot;#备份和恢复的意义&quot; class=&quot;headerlink&quot; title=&quot;备份和恢复的意义&quot;&gt;&lt;/a&gt;备份和恢复的意义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;灾难恢复：比如机房被淹。&lt;/li&gt;
&lt;li&gt;审计：比如想知道某一数据在某一时刻是什么样的。&lt;/li&gt;
&lt;li&gt;测试 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;备份：目的用于恢复。请注意要对备份数据做恢复测试，防止备份的不能恢复，到时候就麻烦了。&lt;/p&gt;
&lt;h3 id=&quot;备份类型&quot;&gt;&lt;a href=&quot;#备份类型&quot; class=&quot;headerlink&quot; title=&quot;备份类型&quot;&gt;&lt;/a&gt;备份类型&lt;/h3&gt;&lt;p&gt;1.根据备份时，数据库服务器是否在线：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;冷备：cold backup。&lt;/strong&gt;服务器离线，数据库读写操作都不能执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;温备：warm backup。&lt;/strong&gt;全局施加共享锁，所有业务只能读，不能写。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;热备：hot backup。&lt;/strong&gt;服务器不离线，读写操作都能进行。这就可能会有问题了。我们去备份，数据量很大，我们得夜间备份，在你复制的过程中，如果文件发生了改变，前一半后一半时间戳不一致，备份好的文件恢复过来是不允许访问的。在文件系统上，这样的文件属于时间点不一致文件，因此是不允许访问的。我们可以把整个数据库锁定，然后创建一快照，通过快照进行备份。通过快照备份，时间点一定是一致的，但是也有一些其他的问题。首先你要锁定整个库，你一锁定，别人就读写不了了。所以这也不能算是热备。真正的热备是指任何业务不终止，它能够自动在背后进行备份，而且自动保证时间点是一致的。&lt;strong&gt;【注意】:要想完成热备，通常是基于事务的存储引擎才能完成的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.根据备份的数据集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;完全备份：full backup&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部分备份: partial backup&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.根据备份时的接口（直接备份数据文件还是通过mysql服务器导出数据）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;物理备份：&lt;/strong&gt;直接复制(归档)数据文件的备份方式；physical backup。&lt;br&gt;copy命令就可以备份了，还可以tar归档压缩备份，因此不需要额外的工具就可以备份。恢复也很简单，把备份的文件复制到数据库里面就可以了，但是要兼容才行。但好在MySQL的InnoDB和MyISAM非常容易跨平台，一般来说，在windows上备份的在Linux上也能用，在Linux上备份的在windows上也能用。物理备份比较适合大数据量备份，比如超过10G，甚至几十个G，千万别用逻辑备份。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑备份：&lt;/strong&gt;把数据从库中提出出来保存为文本文件；logical backup。&lt;br&gt;从根本上来讲，逻辑备份备份后为文本文件，我们可以使用grep、sed、awk来处理查看，物理备份的文件则不能被如此处理。而且逻辑备份恢复简单，导入就可以了。逻辑备份也有缺点，比如说与物理备份恢复速度比，逻辑备份恢复更慢，占据空间更大。还有逻辑备份有个重要缺点，无法保证浮点数的精度，因为我们必须把二进制数据转换成文本格式。更重要的是使用逻辑备份还原数据以后还需要重建索引。 对于非常大的表，重建索引是相当消耗时间和资源的，由其是CPU资源。逻辑备份的工具：mysqldump&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.根据备份时是备份整个数据还是仅备份变化的数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;完全备份：&lt;/strong&gt;full backup&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增量备份：&lt;/strong&gt;incremental backup。得使用专业的备份工具进行增量备份。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;差异备份：&lt;/strong&gt;differential backup&lt;br&gt;增量和差异：差异，每一次起始点不是上一次备份，而是上一次完全备份。见下图。将来设计备份策略的时候，需要根据你的数据量变化频度来设计。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/93.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;备份策略&quot;&gt;&lt;a href=&quot;#备份策略&quot; class=&quot;headerlink&quot; title=&quot;备份策略&quot;&gt;&lt;/a&gt;备份策略&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;选择备份方式&lt;/li&gt;
&lt;li&gt;选择备份时间&lt;/li&gt;
&lt;li&gt;考虑到恢复成本&lt;ul&gt;
&lt;li&gt;恢复时长&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;备份成本：&lt;ul&gt;
&lt;li&gt;锁时间&lt;/li&gt;
&lt;li&gt;备份时长&lt;/li&gt;
&lt;li&gt;备份负载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;备份对象&quot;&gt;&lt;a href=&quot;#备份对象&quot; class=&quot;headerlink&quot; title=&quot;备份对象&quot;&gt;&lt;/a&gt;备份对象&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;配置文件&lt;/li&gt;
&lt;li&gt;代码：存储过程，存储函数，触发器&lt;/li&gt;
&lt;li&gt;OS相关的配置文件，如crontab配置计划及相关的脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;备份工具&quot;&gt;&lt;a href=&quot;#备份工具&quot; class=&quot;headerlink&quot; title=&quot;备份工具&quot;&gt;&lt;/a&gt;备份工具&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.mysqldump：&lt;/strong&gt;MySQL原生自带的逻辑备份工具，单线程工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB热备、温备和冷备，MyISAM温备，Aria温备&lt;/li&gt;
&lt;li&gt;因为是逻辑备份，所以备份和恢复过程较慢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.mysqldumper: &lt;/strong&gt;多线程的mysqldump。装上percona的tools之后，mysqldumper就在里面。多线程同时备份多个库，在必要的场景下缩短备份时间是很有必要的。&lt;/p&gt;
&lt;p&gt;这两个备份工具很难实现差异或增量备份；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.lvm-snapshot:&lt;/strong&gt; 基于lvm的逻辑卷快照进行备份。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是接近于热备的工具：为什么叫接近于？因为要先请求全局锁，而后创建快照，并在创建快照完成后释放全局锁；&lt;/li&gt;
&lt;li&gt;使用cp、tar等工具进行物理备份；&lt;/li&gt;
&lt;li&gt;备份和恢复速度较快；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很难实现增量备份，并且请求全局需要等待一段时间，在繁忙的服务器上尤其如此；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.部分备份工具：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT clause INTO OUTFILE &amp;apos;/path/to/somefile&amp;apos;
LOAD DATA INFILE &amp;apos;/path/from/somefile&amp;apos;   #恢复时得使用这个命令恢复。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;部分备份工具， 不会备份关系定义，仅备份表中的数据；&lt;/li&gt;
&lt;li&gt;也是个逻辑备份工具，快于mysqldump。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5.mysqlhotcopy:&lt;/strong&gt;几乎冷备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.专业备份工具：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Innobase: 商业备份工具, innobackup&lt;/li&gt;
&lt;li&gt;Xtrabackup: 由Percona提供的开源备份工具。需要单独安装。&lt;ul&gt;
&lt;li&gt;InnoDB热备，增量备份；&lt;/li&gt;
&lt;li&gt;MyISAM温备，只是完全备份，不支持增量；&lt;/li&gt;
&lt;li&gt;物理备份，速度快；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;mysqldump备份&quot;&gt;&lt;a href=&quot;#mysqldump备份&quot; class=&quot;headerlink&quot; title=&quot;mysqldump备份&quot;&gt;&lt;/a&gt;mysqldump备份&lt;/h2&gt;&lt;h3 id=&quot;mysqldump备份介绍&quot;&gt;&lt;a href=&quot;#mysqldump备份介绍&quot; class=&quot;headerlink&quot; title=&quot;mysqldump备份介绍&quot;&gt;&lt;/a&gt;mysqldump备份介绍&lt;/h3&gt;&lt;p&gt;【注意】：数据量在10G以下。&lt;br&gt;相当于一个MySQL客户端工具，你的服务器在远程，mysqldump在本地，没有任何问题，也就意味着二者可以在不同的主机上。可实现完全备份和部分备份，但是还原一个库时，这个库得事先存在，就是说在还原前，先得CREATE DATABASE。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man mysqldump
mysqldump [options] [db_name [tbl_name ...]]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;备份单个库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysqldump [options] db_name
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;恢复时：如果目标库不存在，需要事先手动创建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【示例1】：备份和恢复。&lt;/strong&gt;&lt;br&gt;1.先备份库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db ~]# mysqldump -uroot -hlocalhost -p hellodb &amp;gt;/tmp/hdb.sql
Enter password: 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.连接上mysql数据库，删除库hellodb&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; DROP DATABASE hellodb;
Query OK, 7 rows affected (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.恢复，得事先创建库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db ~]# mysql -uroot -hlocalhost -p &amp;lt;/tmp/hdb.sql 
Enter password: 
ERROR 1046 (3D000) at line 22: No database selected

mysql&amp;gt; CREATE DATABASE hellodb DEFAULT CHARSET &amp;apos;utf8&amp;apos;;
Query OK, 1 row affected (0.00 sec)

[root@db ~]# mysql -uroot -hlocalhost -p hellodb &amp;lt;/tmp/hdb.sql     
Enter password: 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以说指定数据库进行备份的这种方式，它只是备份这个库里的东西，它以为这个库是事先存在的，所以恢复时是不会自动创建库的。也可以备份某个表。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--all-databases:　备份所有库。恢复时不需要事先创建库名。
--databases db1 db2 ...: 备份指定的多个库。多个库名间用空格隔开，事先不需要创建库名。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;【示例2】：备份前加锁。（这才是真正的备份，要锁表）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;–lock-all-tables：请求锁定所有表之后再备份，对MyISAM、InnoDB、Aria做温备。&lt;/li&gt;
&lt;li&gt;–lock-tables：备份哪张表，就锁定哪张表。这种并不理想，不建议使用，使用上面的那个。&lt;/li&gt;
&lt;li&gt;–single-transaction: 能够对InnoDB存储引擎实现热备；&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[root@db ~]# mysqldump -uroot -hlocalhost -p hellodb --lock-all-tables &amp;gt;/root/hellodb.sql &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Enter password: &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[root@db ~]# mysqldump -uroot -hlocalhost -p --databases hellodb --lock-all-tables &amp;gt;/root/hellodb2.sql  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Enter password:&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;【注意】:上面两句，第二句在备份单个表时也加了–databases参数，这样备份后的文件里是有CREATE DATABASE语句的。但是–lock-all-tables这种方式也不是很理想，其他的请求会被阻塞，如果你能确保你要备份的数据库的表的底层存储引擎都是InnoDB的话，可以使用另外一种备份方式，–single-transaction，基于多版本并发控制完成对InnoDB存储的热备，和–lock-all-tables不要同时使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备份代码：mysqldump只备份数据，不备份代码。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;–events: 备份事件调度器代码&lt;/li&gt;
&lt;li&gt;–routines: 备份存储过程和存储函数&lt;/li&gt;
&lt;li&gt;–triggers：备份触发器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;备份时滚动日志：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--flush-logs: 备份前、请求到锁之后滚动日志。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么要滚动日志呢？恢复是要采用完全备份+增量备份或差异备份，最后是恢复不到数据损坏的那一刻的，比如你周日做的完全备份，周三中午崩掉了，你可以采用完全备份+周一、周二的增量备份，或者完全备份+差异备份，但是你周三凌晨到周三中午的数据怎么恢复？依靠二进制日志。滚动之后，恢复时你就知道从哪个文件向后是要用到的。因此用mysqldump做完全备份时都应该做–flush-logs。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制时的同步位置标记：&lt;/strong&gt;&lt;br&gt;主从复制架构中的主服务器数据，说白了它就是在你没有flush-logs时怎么知道下一次恢复时用这个文件怎么恢复到时间点。–master-data帮我们备份那一刻二进制日志的文件名及事件所处的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--master-data=[0|1|2]
  0: 不记录
  1：记录为CHANGE MASTER语句
  2：记录为注释的CHANGE MASTER语句
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;【总结】:使用mysqldump备份需要使用的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请求锁：–lock-all-tables或使用–singe-transaction进行innodb热备；&lt;/li&gt;
&lt;li&gt;滚动日志：–flush-logs&lt;/li&gt;
&lt;li&gt;选定要备份的库：–databases&lt;/li&gt;
&lt;li&gt;记录二进制日志文件及位置：–master-data=&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;mysqldump备份示例&quot;&gt;&lt;a href=&quot;#mysqldump备份示例&quot; class=&quot;headerlink&quot; title=&quot;mysqldump备份示例&quot;&gt;&lt;/a&gt;mysqldump备份示例&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;【示例1】:手动施加锁，然后进行备份。&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/94.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/95.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;【注意】：刷写所有表：把所有表在缓冲区中的内容通通同步到磁盘上。如果你的数据量很大，这句刷写和加锁语句要等很长时间。&lt;br&gt;然后用mysqldump备份就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db ~]# mysqldump -uroot -p --databases hellodb &amp;gt;/tmp/hellodb2.sql
Enter password: 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;备份完了记得释放锁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; UNLOCK TABLES;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;【示例2】:手动施加锁太麻烦，直接用mysqldump备份。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db ~]# mysqldump -uroot -p --databases hellodb --lock-all-tables --flush-logs &amp;gt;/tmp/hellodb3.sql
Enter password: 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果有代码块，也需要把相应选项加进来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;–events: 备份事件调度器代码&lt;/li&gt;
&lt;li&gt;–routines: 备份存储过程和存储函数&lt;/li&gt;
&lt;li&gt;–triggers：备份触发器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;热备，你得确定库中所有表的存储引擎都是InnoDB存储引擎&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db ~]# mysqldump -uroot -p --databases hellodb --single-transaction --flush-logs &amp;gt;/tmp/hellodb4.sql                 
Enter password: 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还应该指定–master-data=[0|1|2]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db ~]# mysqldump -uroot -p --databases hellodb --lock-all-tables --flush-logs --master-data=2 &amp;gt;/tmp/hellodb5.sql
Enter password: 
[root@db ~]# vim /tmp/hellodb5.sql 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/96.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;恢复:&lt;/strong&gt;&lt;br&gt;建议：临时性关闭二进制日志，关闭其它用户连接。因为恢复时经常会创建数据库，创建表，插入数据，这部分没必要记录二进制日志。用这个备份恢复时只能恢复到上一次完全备份的位置，要想做时间点还原，还需要二进制日志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【示例3】:数据库即时点恢复。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db ~]# mysqldump -uroot -p --databases hellodb --lock-all-tables --flush-logs --master-data=2 &amp;gt;/tmp/hellodb6.sql
Enter password: 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;备份后，我们在hellodb库中创建了表，插入了一些数据。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; use hellodb&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Database changed&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; create table newtable(Name CHAR(30));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Query OK, 0 rows affected (0.04 sec)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; insert into newtable values (&amp;apos;Tom&amp;apos;),(&amp;apos;Jerry&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Query OK, 2 rows affected (0.00 sec)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Records: 2  Duplicates: 0  Warnings: 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; quit&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Bye&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;没注意把数据库hellodb删除了&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; DROP DATABASE hellodb;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Query OK, 8 rows affected (0.03 sec)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; quit&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Bye&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;恢复过程：&lt;br&gt;①让服务器离线，最起码你得保证服务器不能被别人连进来。&lt;br&gt;开启防火墙或者其他。&lt;/p&gt;
&lt;p&gt;②把即时点前的二进制日志导出来。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/97.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;二进制日志是master-bin.000013的120位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db ~]# vim /tmp/hellodb6.sql 
[root@db ~]# cd /data/binlog/
[root@db binlog]# mysqlbinlog --start-position=120 master-bin.000013 #这个日志文件和文件名是在配置文件中定义的
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/98.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db binlog]# mysqlbinlog --start-position=120 --stop-position=446 master-bin.000013 &amp;gt;/tmp/helldb6.inc.sql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/99.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;③连上mysql服务器做恢复，先临时性关闭二进制日志&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/100.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;千万不要xshell另起一个会话，导入完全备份，因为session sql_log_bin=0只对当前会话生效，另起一会话导入备份，那么同时也会写到二进制日志中，这是我们不期望的。&lt;/p&gt;
&lt;p&gt;④恢复到即时点。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/101.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/102.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/103.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;但事实上这个开不开没什么影响，只要你自己不在当前session中操作就行。     &lt;/p&gt;
&lt;p&gt;【总结】:备份策略：基于mysqldump&lt;br&gt;&lt;strong&gt;1.备份：mysqldump+二进制日志文件&lt;/strong&gt;&lt;br&gt;    周日做一次完全备份：备份的同时滚动日志&lt;br&gt;    周一至周六：备份二进制日志；(可以每天都FLUSH LOGS，然后把备份之前的那个二进制日志，每天备份每天的二进制日志，直接copy就可以备份二进制日志文件。这里其实是把二进制日志当增量备份)。&lt;br&gt;&lt;strong&gt;2.恢复&lt;/strong&gt;&lt;br&gt;    完全备份+各二进制日志文件中至此刻的事件&lt;br&gt;   日志滚动也可以使用mysqladmin工具：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db binlog]# mysqladmin -uroot -p flush-logs
Enter password: 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对MySQL配置文件，以及与MySQL相关的OS配置文件在每次修改后都应该直接进行备份。cp一份放在一个地方就行。&lt;/p&gt;
&lt;p&gt;我们可以写一个备份脚本：&lt;br&gt;1、备份所有数据库；&lt;br&gt;2、在每周日凌晨自动执行；&lt;br&gt;【注意】:crontab的PATH环境变量和系统的PATH环境变量是不一样的，无论你在命令行中使用命令多么顺当，在crontab中未必会执行，所以你写一个脚本的目的不是在命令行中执行，而是在crontab中执行，请使用命令全路径。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;备份和恢复概念&quot;&gt;&lt;a href=&quot;#备份和恢复概念&quot; class=&quot;headerlink&quot; title=&quot;备份和恢复概念&quot;&gt;&lt;/a&gt;备份和恢复概念&lt;/h2&gt;&lt;h3 id=&quot;备份和恢复的意义&quot;&gt;&lt;a href=&quot;#备份和恢复的意义&quot; class=&quot;headerlink&quot; title=&quot;备份和恢复的意义&quot;&gt;&lt;/a&gt;备份和恢复的意义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;灾难恢复：比如机房被淹。&lt;/li&gt;
&lt;li&gt;审计：比如想知道某一数据在某一时刻是什么样的。&lt;/li&gt;
&lt;li&gt;测试
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL日志功能详解</title>
    <link href="http://yoursite.com/2018/04/16/MySQL%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/16/MySQL日志功能详解/</id>
    <published>2018-04-16T00:40:02.000Z</published>
    <updated>2018-04-18T06:03:54.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;MySQL日志&quot;&gt;&lt;a href=&quot;#MySQL日志&quot; class=&quot;headerlink&quot; title=&quot;MySQL日志&quot;&gt;&lt;/a&gt;MySQL日志&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查询日志&lt;br&gt;这是最不应该记录的日志。因为一个非常繁忙的数据库服务器，其查询会有很多，每一次都记录日志会导致系统性能下降。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;而且还会有额外的空间开销。MySQL默认没有开启这个日志。注意不仅仅是SELECT。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;慢查询日志&lt;br&gt;查询执行时长超过指定时长的查询，即为慢查询。这里的慢不一定是语句自身执行慢，如果一个操作锁定了某张表，尤其是独占锁锁定了这张表，那么其他人对于这张表的查询就阻塞掉了。但不管怎么讲，慢查询日志是我们通常拿来定位系统上查询操作执行速度过慢时常用到的一个评估工具。所以在生产环境中有时是很有必要启用慢查日志的。percona公司在提供的工具perconatools中有专门工具用来分析慢查日志中哪些查询执行时长过长，以及产生的原因有哪些。这是一个应该启用的日志，但是默认没启用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误日志&lt;br&gt;通常情况下记录的不光是错误信息，也包括mysql启动和关闭过程中的信息，以及启动复制线程时的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;中继日志&lt;br&gt;在从服务器上的日志。就是说复制的时候，主服务器任何能够产生数据修改的操作，在写入数据文件的同时，还会把这个语句(也可能是行)记录到二进制日志文件中一份。从服务器就是使用一个用户帐号不断的去连接主服务器，并尝试去读取主服务器上二进制日志中的每一个条目，从服务器将这些挨个的读到从服务器上，在执行之前，先要将这些读到的保存在本地的日志文件中，而后从本地日志文件中读一条执行一条。这个日志文件就叫做中继日志。很显然，中继日志内容应该和二进制日志内容是一样的，为了完成复制，二进制日志不能随便删除，中继日志可以删除，用完后清了。如果发现清错了，可以找个二进制日志复制下就可以了。再想一个问题，从服务器也有二进制日志，每次执行都是从中继日志中读，然后执行，同时还要写入二进制日志，如果要记录二进制日志的话，应该是和主服务器的二进制日志一样的。这种记录是额外的开销，如果其他服务器不把这个从服务器当做主来用，这个二进制日志就没有用了，所以应该关闭掉，以提升性能。另外，从服务器是不能执行额外的任何写操作的，只能从中继日志中读一条写一条。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事务日志&lt;br&gt;先暂存事务提交的数据，然后在同步到数据文件中。&lt;br&gt;随机I/O转换为顺序I/O。但是即便是顺序I/O，其速度依然有限。把事务日志放在RAID10上，或放在固态硬盘上，或放在PCI-E固态硬盘上，那就体会几乎内存的性能了。&lt;br&gt;如果是支持事务的存储引擎，要满足事务的要求，就必须满足ACID测试，其中有一点很重要就是持久性。事务还要能够回滚。考虑一种场景，我们的事务隔离级别是”读未提交”，两个连接进来了，都在做事务，第一个事务执行的语句，它的事务在提交之前有可能是保存在内存中，有可能是被同步到事务日志中，内存中可能放不下，就放到事务日志中去了。当第二个事务查询时，它的查询应该是来自磁盘上的数据文件，但问题是第一个事务执行的操作还没有同步到磁盘上，那它怎么查到呢？所以要支持事务，背后的工作逻辑是很复杂的，不但要从数据文件中找，还要去找那些有可能潜在修改这个数据文件的数据集，比如内存缓冲区，这个缓冲区我们称为innodb_buffer，还有可能要去查询事务日志。所以事务日志还要支撑读操作。只有完全把buffer和事务日志中的数据全部同步到磁盘的数据文件中去了，从磁盘上读到的数据才是最新的。所以buffer和事务日志中所保存的数据接近于表中所存储的格式的。&lt;br&gt;再考虑一种场景如果我们启动了一个非常大的事务，那么buffer实在缓存不下了，就要先写到事务日志中去了，日志文件至少需要两个，以实现轮替的，两个组成一个日志文件组。第一个日志文件写满了，就去写第二个。日志文件一个5M，可以调整的，但是大多数场景是够用的。第一个日志文件不够用了，写第二个日志文件，然后第一个日志文件中的数据开始往磁盘数据文件同步。即便如此，这个事务只执行了一半或者2/3，过一会，回滚。该怎么回滚？那些写到磁盘数据文件的数据也得删掉。所以回滚也是一个非常复杂的操作。如果说这个回滚的所有数据最多只到事务日志中和最多走到数据文件中，哪种回滚的开销比较小？只是走到事务日志中开销比较小，甚至于还没走到事务日志中，仍然还在innodb_buffer中，回滚的开销会更小，所以我们应该使用小事务。&lt;br&gt;为了保证提交的事务不丢失，其一部分写操作可能在内存中，我们一commit，所有位于内存中的数据有可能会因为断电或系统崩溃而丢失，为了避免这种情况，要立即写到持久存储中去。写到事务日志中。假如一个事务提交了，刚从内存中同步到事务日志中，还没同步到数据文件中，系统崩溃了。下次启动时，这个事务能恢复回来，因为事务日志中有。所以下一次mysql启动时，它必须保证把那些提交的事务从事务文件中同步到数据文件中。而未提交的事务，比如有些事务正在操作，但并未提交，系统崩溃了，这种情况怎么办？因为没有完成，所以之前这个事务的操作全部回滚，这个过程就叫做系统崩溃恢复的过程。把那些提交的事务同步到数据文件中，没提交的事务回滚。而事务性存储引擎的崩溃恢复能力是天生的。&lt;br&gt;如果MySQL崩溃是因为事务日志的磁盘坏了，这种情况下，就不能崩溃恢复了。只能用备份恢复了。所以我们应该让事务日志所在的硬盘足够可靠，RAID10或者RAID1。假如说是因为数据文件崩溃了，一样的场景。你有事务日志，但你数据文件坏了，怎么去写啊。有事务日志并不能恢复数据，&lt;strong&gt;事务日志不是用来恢复数据的，事务日志仅仅是崩溃时能够保证已提交事务不丢失，未提交事务能回滚。&lt;/strong&gt;&lt;br&gt;从性能上来讲，将事务日志和数据文件放在一块是不合理的。从内存到硬盘，I/O，从事务日志到数据文件也要I/O，所有的I/O都压在一块硬盘上去了，导致性能下降。因此，把数据文件放在一个RAID设备上，把事务日志放在一个RAID设备上。考虑独特的场景，我们实在没有RAID设备放事务日志了，那就给事务日志做镜像。如果你实在是没钱，那就找个其他磁盘空间，跟事务日志文件不在同一个磁盘上就行，做一个mirror，任何往第一组事务日志中写的数据会被自动同步到第二组中去的。&lt;br&gt;日志文件组：至少应该有两个日志文件；&lt;br&gt;【注意】：尽可能使用小事务以提升事务引擎的性能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二进制日志&lt;br&gt;主要用于MySQL时间点恢复和复制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;查询日志&quot;&gt;&lt;a href=&quot;#查询日志&quot; class=&quot;headerlink&quot; title=&quot;查询日志&quot;&gt;&lt;/a&gt;查询日志&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;log={ON|OFF}:是否记录所有语句的日志信息于一般查询日志文件(general_log)。MySQL5.6已经弃用此项变量了，都使用general_log。&lt;/li&gt;
&lt;li&gt;log_output={TABLE|FILE|NONE}&lt;ul&gt;
&lt;li&gt;TABLE：记录于表中。MySQL库中会自动生成一个表记录。&lt;/li&gt;
&lt;li&gt;FILE：记录于general_log_file。&lt;/li&gt;
&lt;li&gt;NONE：不记录。&lt;/li&gt;
&lt;li&gt;TABLE和FILE可以同时出现，用逗号分隔即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;general_log：是否启用查询日志。由于历史的原因，和log是个冲突的概念。&lt;/li&gt;
&lt;li&gt;general_log_file：定义一般查询日志保存的文件。文件名为：主机名.log，保存路径没说的话保存在数据目录中。所有的相对路径通常都是相对于数据目录而言的。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; SHOW GLOBAL VARIABLES LIKE &amp;quot;%log%&amp;quot;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/89.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果开启查询日志，包括SHOW、SET操作也会被记录，这些操作过程中也需要查询。如果要记录查询日志，记录到数据库中，会比记录到文件中快一点。但是一般是不启用记录查询日志的，除非特殊情况。&lt;/p&gt;
&lt;h2 id=&quot;慢查询日志&quot;&gt;&lt;a href=&quot;#慢查询日志&quot; class=&quot;headerlink&quot; title=&quot;慢查询日志&quot;&gt;&lt;/a&gt;慢查询日志&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;long_query_time： 10.000000&lt;br&gt;执行多长时间的查询算是慢查询&lt;/li&gt;
&lt;li&gt;slow_query_log={ON|OFF}  或者是1 | 0&lt;br&gt;设定是否启用慢查询日志；它的输出位置也取决log_output={TABLE|FILE|NONE}；&lt;/li&gt;
&lt;li&gt;slow_query_log_file=www-slow.log&lt;br&gt;定义日志文件路径及名称；&lt;/li&gt;
&lt;li&gt;log_slow_queries=ON    &lt;/li&gt;
&lt;li&gt;与上面slow_query_log={ON|OFF}好像是重复的，上面那个是全局的，下面这个是用户自己会话的。                                &lt;/li&gt;
&lt;li&gt;log_slow_rate_limit=1     记录慢查询日志的速率。                  &lt;/li&gt;
&lt;li&gt;log_slow_verbosity     是否记录详细的慢查询的详细信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; SHOW GLOBAL VARIABLES LIKE &amp;quot;long%&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+-----------------+-----------+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Variable_name   | Value     |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+-----------------+-----------+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| long_query_time | 10.000000 |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+-----------------+-----------+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;1 row in set (0.00 sec)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;错误日志&quot;&gt;&lt;a href=&quot;#错误日志&quot; class=&quot;headerlink&quot; title=&quot;错误日志&quot;&gt;&lt;/a&gt;错误日志&lt;/h2&gt;&lt;p&gt;错误日志： 通常是开启的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器启动和关闭过程中的信息；&lt;/li&gt;
&lt;li&gt;服务器运行过程中的错误信息；&lt;/li&gt;
&lt;li&gt;事件调度器运行一个事件时产生的信息；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在复制架构中的从服务器上启动从服务器线程时产生的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log_error = /path/to/error_log_file&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;log_warnings = {1|0}&lt;br&gt;是否记录警告信息于错误日志中。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; SHOW GLOBAL VARIABLES LIKE &amp;quot;%log%&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| log_error                               | /data/mydata/db.err           |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;二进制日志&quot;&gt;&lt;a href=&quot;#二进制日志&quot; class=&quot;headerlink&quot; title=&quot;二进制日志&quot;&gt;&lt;/a&gt;二进制日志&lt;/h2&gt;&lt;h3 id=&quot;二进制日志介绍&quot;&gt;&lt;a href=&quot;#二进制日志介绍&quot; class=&quot;headerlink&quot; title=&quot;二进制日志介绍&quot;&gt;&lt;/a&gt;二进制日志介绍&lt;/h3&gt;&lt;p&gt;二进制日志：也称为复制日志，记录的是”修改”类信息，记录的是一个个事件。&lt;br&gt;格式也应该是二进制的，不能使用cat命令查看，有专门的工具mysqlbinlog可以查看。&lt;br&gt;二进制日志能够基于过去某个数据集的基础上，把后续的所有操作重新跑一遍，能得到和此前第一次跑时所得到的是一样的结果。日志文件名字以及存放路径都是可以定义的。比如我在安装mysql时将数据文件和二进制日志文件就定义在了不同的目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db ~]# cd /data/binlog/
[root@db binlog]# ls
master-bin.000001  master-bin.000003  master-bin.000005  master-bin.000007  master-bin.index
master-bin.000002  master-bin.000004  master-bin.000006  master-bin.000008
[root@db binlog]# file master-bin.000001
master-bin.000001: MySQL replication log
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以使用工具mysqlbinlog查看二进制日志文件内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db binlog]# mysqlbinlog master-bin.000001
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/90.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这个事件从66773开始到66846结束，66846-66773=中间的信息的偏移量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;position：位置，空间记录法。空间记录法就是相对于当前日志文件而言它的偏移位置。&lt;/li&gt;
&lt;li&gt;time: 时间点，时间记录法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二进制日志文件内容格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件发生的日期和时间&lt;/li&gt;
&lt;li&gt;服务器ID&lt;/li&gt;
&lt;li&gt;事件的结束位置&lt;/li&gt;
&lt;li&gt;事件的类型&lt;/li&gt;
&lt;li&gt;原服务器生成此事件时的线程ID&lt;/li&gt;
&lt;li&gt;语句的时间戳和写入二进制日志文件的时间差。exec_time=0，由于单位是s，所以很多时候是0。&lt;/li&gt;
&lt;li&gt;错误代码；&lt;/li&gt;
&lt;li&gt;事件内容：也就是语句本身。&lt;/li&gt;
&lt;li&gt;事件位置，相当于下一事件的开始位置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;考虑一种场景：如果说我们有多个进程同时进行，比如处理两个请求的两个线程分别在两颗CPU上跑着，而且修改不是同一张表，这个时候都需要写入二进制日志，但是某个时刻只会往一个二进制日志文件中写，具体哪个见下面的命令。显然，这个文件不能有两个进程同时写，如果交替着写，事件就混到一块了。由于二进制日志成为了资源争用点，有可能会导致性能下降，如果你去设计的话，如何去避免性能下降？缓存，于是每一个线程在写数据时不是直接写文件，而是写在缓冲区中，专业点的说法是，写通常是叫做缓冲。过一段时间，由MySQL服务器后台线程找空闲时间自行往二进制日志文件中同步。但这会带来一个问题，如果说事件写在缓冲区中了，忽然间系统断电了，这些缓冲区的数据还没写到二进制文件中去呢，那么拿来二进制日志执行，数据也不对。虽然没有写到二进制日志文件中去，但是却已经写到本地数据文件中去了。只不过这个有可能产生数据修改的操作还得写到记录到二进制日志中去。将来把这个二进制日志信息复制到从服务器上，重新跑一遍，得到的数据不一样。因此这是不安全的做法。通常效率和安全性通常是两个背离的方向。所以我们要求应该在事务提交时无论如何也应该把二进制日志缓冲区中的信息同步到二进制日志文件中去。&lt;/p&gt;
&lt;p&gt;滚动： 二进制日志文件需要不停的进行滚动，防止文件大小过大。&lt;br&gt;1、大小&lt;br&gt;2、时间&lt;/p&gt;
&lt;p&gt;二进制日志的功用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;即时点恢复：我们想恢复到哪个位置，可以通过二进制日志文件手动调整进行的。&lt;/li&gt;
&lt;li&gt;复制。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;二进制日志常用命令&quot;&gt;&lt;a href=&quot;#二进制日志常用命令&quot; class=&quot;headerlink&quot; title=&quot;二进制日志常用命令&quot;&gt;&lt;/a&gt;二进制日志常用命令&lt;/h3&gt;&lt;p&gt;1.查看当前服务器所正在使用的二进制日志文件，以及下一个事件要开始时记录的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW MASTER STATUS;
+-------------------+----------+--------------+------------------+-------------------+
| File              | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------------+----------+--------------+------------------+-------------------+
| master-bin.000008 |  5525554 |              |                  |                   |
+-------------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.每一次重启MySQL服务器或者FLUSH LOGS，日志文件都会滚动。FLUSH LOGS，对错误日志等没有意义，它主要是用来滚动二进制日志和中继日志的。二进制日志不像事务日志ib_logfile0、ib_logfile1，反复被用到。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; FLUSH LOGS;       
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.查看有多少二进制日志文件及其大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW BINARY LOGS; 
+-------------------+-----------+
| Log_name          | File_size |
+-------------------+-----------+
| master-bin.000001 |     67251 |
| master-bin.000002 |   1361538 |
| master-bin.000003 |  73892389 |
| master-bin.000004 |       120 |
| master-bin.000005 |   5076873 |
| master-bin.000006 |   8200661 |
| master-bin.000007 |  30885330 |
| master-bin.000008 |   5525554 |
+-------------------+-----------+
8 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以通过删除文件的方式清除二进制日志，注意不到万不得已，千万不要手动删除。而且手动删除也不是通过删除文件删除的，而是通过PURGE命令删除的。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; HELP PURGE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Name: &amp;apos;PURGE BINARY LOGS&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Description:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Syntax:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PURGE &amp;#123; BINARY | MASTER &amp;#125; LOGS&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123; TO &amp;apos;log_name&amp;apos; | BEFORE datetime_expr &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;The binary log is a set of files that contain information about data&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;modifications made by the MySQL server. The log consists of a set of&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;binary log files, plus an index file (see&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;http://dev.mysql.com/doc/refman/5.6/en/binary-log.html).&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;The PURGE BINARY LOGS statement deletes all the binary log files listed&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;in the log index file prior to the specified log file name or date.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;BINARY and MASTER are synonyms. Deleted log files also are removed from&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;the list recorded in the index file, so that the given log file becomes&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;the first in the list.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;This statement has no effect if the server was not started with the&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--log-bin option to enable binary logging.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;URL: http://dev.mysql.com/doc/refman/5.6/en/purge-binary-logs.html&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Examples:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PURGE BINARY LOGS TO &amp;apos;mysql-bin.010&amp;apos;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;PURGE BINARY LOGS BEFORE &amp;apos;2008-04-02 22:46:26&amp;apos;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4.查看事件信息&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; HELP SHOW BINLOG EVENTS&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Name: &amp;apos;SHOW BINLOG EVENTS&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Description:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Syntax:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;SHOW BINLOG EVENTS&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   [IN &amp;apos;log_name&amp;apos;] [FROM pos] [LIMIT [offset,] row_count]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Shows the events in the binary log. If you do not specify &amp;apos;log_name&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;the first binary log is displayed.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;URL: http://dev.mysql.com/doc/refman/5.6/en/show-binlog-events.html&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW BINLOG EVENTS IN &amp;apos;master-bin.000001&amp;apos;\G
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/91.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;server-id: 服务器身份标识。MySQL的复制模型可以做的很复杂，服务器之间可以互为主从，也就是说各自是对方的主，又各自是对方的从。也就意味着左边的服务器也会复制右边的服务器的二进制日志，右边的机器是从左边的二进制日志中读取信息到中继日志中，并执行，同时写入自己的二进制日志，那左边从右边的二进制日志拿回来在执行一次，也就重复了。为了避免重复，server-id。左边读回来的信息发现是自己的server-id，就不会执行了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者可以使用mysqlbinlog工具查看事件信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysqlbinlog      
    --start-time
    --stop-time
    --start-position
    --stop-position
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;考虑一种场景：我们当前执行了INSERT INTO t1 VALUE (CURRENT_DATE())，记录到了二进制日志，但是以后拿这个日志跑一遍，很显然这个函数在那个时刻获得值肯定和现在不一样的。&lt;br&gt;MySQL记录二进制日志的格式的三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于语句：statement。像上面那个插入语句，就不能基于语句做了，就得把那个时间记录下来，叫基于行记录。&lt;/li&gt;
&lt;li&gt;基于行：row。但是基于行，每个行都得记录，比如我执行了一条语句UPDATE tb1 SET salary=salary+1000; ，如果公司有2万人，基于行记录得产生很大的数据量，但是基于语句，只需要记录这个语句就行。&lt;/li&gt;
&lt;li&gt;混合模式：mixed。由MySQL自动判断基于哪种方式记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;二进制日志相关配置&quot;&gt;&lt;a href=&quot;#二进制日志相关配置&quot; class=&quot;headerlink&quot; title=&quot;二进制日志相关配置&quot;&gt;&lt;/a&gt;二进制日志相关配置&lt;/h3&gt;&lt;p&gt;跟二进制日志相关的服务器参数：&lt;br&gt;&lt;strong&gt;1.log_bin = {ON|OFF},&lt;/strong&gt; 是否开启二进制日志。还可以是个文件路径。同样二进制日志文件也不要和数据文件放在一起。建议在安装好MySQL就配置好二进制日志文件存放路径和没给你做。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@db ~]# vim /etc/my.cnf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/92.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.log_bin_trust_function_creators：&lt;/strong&gt;用于控制创建存储函数时如果会导致不完全事件的记录。一般是OFF。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.sql_log_bin = {ON|OFF} &lt;/strong&gt; sql_log_bin 是一个动态变量，修改该变量时，可以只对当前会话生效（Session），也可以是全局的（Global），当全局修改这个变量时，只会对新的会话生效（这意味当对当前会话也不会生效），因此一般全局修改了这个变量后，都要把原来的所有连接 kill 掉。在 mysql 启动时，通过命令行或配置文件决定是否开启 binlog，而 log_bin 这个变量仅仅是报告当前 binlog 系统的状态（打开与否）。若你想要关闭 binlog，你可以通过修改 sql_log_bin 并把原来的连接 kill 掉，也可以修改 log_bin，然后重启 mysql，后者更彻底，缺点就是需要重启。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.sync_binlog：&lt;/strong&gt;设定多久同步一次。就是定义多久将缓冲区中的二进制日志信息同步到二进制日志文件中。时间间隔越长，性能就越好，但数据安全性就越差。默认为0，表示不同步，也就是不靠时间来控制。如果你给的是正值，就表示每隔多长时间会同步。事实上如果你的auto_commit=0，意味着每一次事务提交时才会自动同步。虽然这里是二进制日志，和事务没关系，但为了保证事务安全，每一次事务提交时都会同步二进制日志。因此如果auto_commit=1，每个语句执行完都会同步，这是相当的性能低下。sync_binlog和MySQL的性能密切相关，虽然说不至于和事务日志、事务日志的刷写方式影响那么严重，这也是应该引起我们重视的一个服务器参数。=0反而是性能表现比较好的方式。默认情况下auto_commint=1，见下图。建议关闭。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.binlog_format = {statement|row|mixed}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.max_binlog_cache_size = &lt;/strong&gt;&lt;br&gt;二进制日志缓冲空间大小，从MySQL5.5.9以后仅用于缓冲事务类的语句。一般不需要调整。如果是非事务类的，比如Aria存储引擎，max_binlog_stmt_cache_size。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.max_binlog_stmt_cache_size =&lt;/strong&gt;&lt;br&gt;非事务类的和事务类的共用的空间大小。一般不需要调整。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.max_binlog_size = &lt;/strong&gt;&lt;br&gt;二进制日志文件上限。一旦超过这个大小，就自动滚动了。默认单位是bytes。&lt;/p&gt;
&lt;p&gt;建议：切勿将二进制日志与数据文件放在一同设备。MySQL的很多默认设定并不适合生产环境，我们需要调整。&lt;/p&gt;
&lt;p&gt;中继日志：对于非从服务器，其中继日志默认是不启用的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;relay_log_purge={ON|OFF} 是否自动清理 不再需要的中继日志。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;总结日志相关的服务器参数&quot;&gt;&lt;a href=&quot;#总结日志相关的服务器参数&quot; class=&quot;headerlink&quot; title=&quot;总结日志相关的服务器参数&quot;&gt;&lt;/a&gt;总结日志相关的服务器参数&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;expire_logs_days={0..99}&lt;br&gt;设定二进制日志的过期天数，超出此天数的二进制日志文件将被自动删除。默认为0，表示不启用过期自动删除功能。如果启用此功能，自动删除工作通常发生在MySQL启动时或FLUSH日志时。作用范围为全局，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;general_log={ON|OFF}&lt;br&gt;设定是否启用查询日志，默认值为取决于在启动mysqld时是否使用了–general_log选项。如若启用此项，其输出位置则由–log_output选项进行定义，如果log_output的值设定为NONE，即使用启用查询日志，其也不会记录任何日志信息。作用范围为全局，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;general_log_file=FILE_NAME&lt;br&gt;查询日志的日志文件名称，默认为“hostname.log”。作用范围为全局，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;binlog-format={ROW|STATEMENT|MIXED}&lt;br&gt;指定二进制日志的类型，默认为STATEMENT。如果设定了二进制日志的格式，却没有启用二进制日志，则MySQL启动时会产生警告日志信息并记录于错误日志中。作用范围为全局或会话，可用于配置文件，且属于动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log={YES|NO}&lt;br&gt;是否启用记录所有语句的日志信息于一般查询日志(general query log)中，默认通常为OFF。MySQL 5.6已经弃用此选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log-bin={YES|NO}&lt;br&gt;是否启用二进制日志，如果为mysqld设定了–log-bin选项，则其值为ON，否则则为OFF。其仅用于显示是否启用了二进制日志，并不反应log-bin的设定值。作用范围为全局级别，属非动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log_bin_trust_function_creators={TRUE|FALSE}&lt;br&gt;此参数仅在启用二进制日志时有效，用于控制创建存储函数时如果会导致不安全的事件记录二进制日志条件下是否禁止创建存储函数。默认值为0，表示除非用户除了CREATE ROUTING或ALTER ROUTINE权限外还有SUPER权限，否则将禁止创建或修改存储函数，同时，还要求在创建函数时必需为之使用DETERMINISTIC属性，再不然就是附带READS SQL DATA或NO SQL属性。设置其值为1时则不启用这些限制。作用范围为全局级别，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log_error=/PATH/TO/ERROR_LOG_FILENAME&lt;br&gt;定义错误日志文件。作用范围为全局或会话级别，可用于配置文件，属非动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log_output={TABLE|FILE|NONE}&lt;br&gt;定义一般查询日志和慢查询日志的保存方式，可以是TABLE、FILE、NONE，也可以是TABLE及FILE的组合(用逗号隔开)，默认为TABLE。如果组合中出现了NONE，那么其它设定都将失效，同时，无论是否启用日志功能，也不会记录任何相关的日志信息。作用范围为全局级别，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log_query_not_using_indexes={ON|OFF}&lt;br&gt;设定是否将没有使用索引的查询操作记录到慢查询日志。作用范围为全局级别，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log_slave_updates&lt;br&gt;用于设定复制场景中的从服务器是否将从主服务器收到的更新操作记录进本机的二进制日志中。本参数设定的生效需要在从服务器上启用二进制日志功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log_slow_queries={YES|NO}&lt;br&gt;是否记录慢查询日志。慢查询是指查询的执行时间超出long_query_time参数所设定时长的事件。MySQL 5.6将此参数修改为了slow_query_log。作用范围为全局级别，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;log_warnings=#&lt;br&gt;设定是否将警告信息记录进错误日志。默认设定为1，表示启用；可以将其设置为0以禁用；而其值为大于1的数值时表示将新发起连接时产生的“失败的连接”和“拒绝访问”类的错误信息也记录进错误日志。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;long_query_time=#&lt;br&gt;设定区别慢查询与一般查询的语句执行时间长度。这里的语句执行时长为实际的执行时间，而非在CPU上的执行时长，因此，负载较重的服务器上更容易产生慢查询。其最小值为0，默认值为10，单位是秒钟。它也支持毫秒级的解析度。作用范围为全局或会话级别，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;max_binlog_cache_size{4096 .. 18446744073709547520}&lt;br&gt;二进定日志缓存空间大小，5.5.9及以后的版本仅应用于事务缓存，其上限由max_binlog_stmt_cache_size决定。作用范围为全局级别，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;max_binlog_size={4096 .. 1073741824}&lt;br&gt;设定二进制日志文件上限，单位为字节，最小值为4K，最大值为1G，默认为1G。某事务所产生的日志信息只能写入一个二进制日志文件，因此，实际上的二进制日志文件可能大于这个指定的上限。作用范围为全局级别，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;max_relay_log_size={4096..1073741824}&lt;br&gt;设定从服务器上中继日志的体积上限，到达此限度时其会自动进行中继日志滚动。此参数值为0时，mysqld将使用max_binlog_size参数同时为二进制日志和中继日志设定日志文件体积上限。作用范围为全局级别，可用于配置文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;innodb_log_buffer_size={262144 .. 4294967295}&lt;br&gt;设定InnoDB用于辅助完成日志文件写操作的日志缓冲区大小，单位是字节，默认为8MB。较大的事务可以借助于更大的日志缓冲区来避免在事务完成之前将日志缓冲区的数据写入日志文件，以减少I/O操作进而提升系统性能。因此，在有着较大事务的应用场景中，建议为此变量设定一个更大的值。作用范围为全局级别，可用于选项文件，属非动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;innodb_log_file_size={108576 .. 4294967295}&lt;br&gt;设定日志组中每个日志文件的大小，单位是字节，默认值是5MB。较为明智的取值范围是从1MB到缓存池体积的1/n，其中n表示日志组中日志文件的个数。日志文件越大，在缓存池中需要执行的检查点刷写操作就越少，这意味着所需的I/O操作也就越少，然而这也会导致较慢的故障恢复速度。作用范围为全局级别，可用于选项文件，属非动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;innodb_log_files_in_group={2 .. 100}&lt;br&gt;设定日志组中日志文件的个数。InnoDB以循环的方式使用这些日志文件。默认值为2。作用范围为全局级别，可用于选项文件，属非动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;innodb_log_group_home_dir=/PATH/TO/DIR&lt;br&gt;设定InnoDB重做日志文件的存储目录。在缺省使用InnoDB日志相关的所有变量时，其默认会在数据目录中创建两个大小为5MB的名为ib_logfile0和ib_logfile1的日志文件。作用范围为全局级别，可用于选项文件，属非动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;relay_log=file_name&lt;br&gt;设定中继日志的文件名称，默认为host_name-relay-bin。也可以使用绝对路径，以指定非数据目录来存储中继日志。作用范围为全局级别，可用于选项文件，属非动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;relay_log_index=file_name&lt;br&gt;设定中继日志的索引文件名，默认为为数据目录中的host_name-relay-bin.index。作用范围为全局级别，可用于选项文件，属非动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;relay-log-info-file=file_name&lt;br&gt;设定中继服务用于记录中继信息的文件，默认为数据目录中的relay-log.info。作用范围为全局级别，可用于选项文件，属非动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;relay_log_purge={ON|OFF}&lt;br&gt;设定对不再需要的中继日志是否自动进行清理。默认值为ON。作用范围为全局级别，可用于选项文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;relay_log_space_limit=#&lt;br&gt;设定用于存储所有中继日志文件的可用空间大小。默认为0，表示不限定。最大值取决于系统平台位数。作用范围为全局级别，可用于选项文件，属非动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;slow_query_log={ON|OFF}&lt;br&gt;设定是否启用慢查询日志。0或OFF表示禁用，1或ON表示启用。日志信息的输出位置取决于log_output变量的定义，如果其值为NONE，则即便slow_query_log为ON，也不会记录任何慢查询信息。作用范围为全局级别，可用于选项文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;slow_query_log_file=/PATH/TO/SOMEFILE&lt;br&gt;设定慢查询日志文件的名称。默认为hostname-slow.log，但可以通过–slow_query_log_file选项修改。作用范围为全局级别，可用于选项文件，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sql_log_bin={ON|OFF}&lt;br&gt;用于控制二进制日志信息是否记录进日志文件。默认为ON，表示启用记录功能。用户可以在会话级别修改此变量的值，但其必须具有SUPER权限。作用范围为全局和会话级别，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sql_log_off={ON|OFF}&lt;br&gt;用于控制是否禁止将一般查询日志类信息记录进查询日志文件。默认为OFF，表示不禁止记录功能。用户可以在会话级别修改此变量的值，但其必须具有SUPER权限。作用范围为全局和会话级别，属动态变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sync_binlog=#&lt;br&gt;设定多久同步一次二进制日志至磁盘文件中，0表示不同步，任何正数值都表示对二进制每多少次写操作之后同步一次。当autocommit的值为1时，每条语句的执行都会引起二进制日志同步，否则，每个事务的提交会引起二进制日志同步。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL日志&quot;&gt;&lt;a href=&quot;#MySQL日志&quot; class=&quot;headerlink&quot; title=&quot;MySQL日志&quot;&gt;&lt;/a&gt;MySQL日志&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查询日志&lt;br&gt;这是最不应该记录的日志。因为一个非常繁忙的数据库服务器，其查询会有很多，每一次都记录日志会导致系统性能下降。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL用户管理及查询缓存详解</title>
    <link href="http://yoursite.com/2018/04/12/MySQL%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%8F%8A%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/04/12/MySQL用户管理及查询缓存详解/</id>
    <published>2018-04-12T06:46:07.000Z</published>
    <updated>2018-04-13T02:31:16.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;MySQL用户管理&quot;&gt;&lt;a href=&quot;#MySQL用户管理&quot; class=&quot;headerlink&quot; title=&quot;MySQL用户管理&quot;&gt;&lt;/a&gt;MySQL用户管理&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;用户帐号：username@hostname, password       
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表示这个账号允许通过hostname主机连入mysql服务器。hostname可以是单个ip，也可以是一个网络，也可以是通配符。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/85.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;MySQL对用户帐号的管理是分两步的：创建和授权。&lt;/p&gt;
&lt;h3 id=&quot;用户账号管理&quot;&gt;&lt;a href=&quot;#用户账号管理&quot; class=&quot;headerlink&quot; title=&quot;用户账号管理&quot;&gt;&lt;/a&gt;用户账号管理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CREATE USER   #使用这种方式创建完用户后，他仅能够连入mysql服务器，并能够执行有限的查看类命令，想创建数据库、创建表、插入数据等没有权限。&lt;/li&gt;
&lt;li&gt;DROP UESER&lt;/li&gt;
&lt;li&gt;RENAME USER&lt;/li&gt;
&lt;li&gt;SET PASSWORD&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;CREATE-USER&quot;&gt;&lt;a href=&quot;#CREATE-USER&quot; class=&quot;headerlink&quot; title=&quot;CREATE USER&quot;&gt;&lt;/a&gt;CREATE USER&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;CREATE USER username@hostname
   [
       IDENTIFIED BY [PASSWORD] &amp;apos;password&amp;apos;
   ]            
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【注意】:如果不给密码就是空密码。&lt;/p&gt;
&lt;p&gt;主机也可使用通配符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%：匹配任何字符
_: 匹配单个字符
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【示例】：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;testuser@&amp;apos;172.16.100.1__&amp;apos; 代表 172.16.100.100-172.16.100.199


mysql&amp;gt; CREATE USER testuser@&amp;apos;172.16.%.%&amp;apos; IDENTIFIED BY &amp;apos;testpass&amp;apos;;
Query OK, 0 rows affected (0.13 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于CREATE USER、GRANT来说，FLUSH不是必须的。然后我们使用这个刚创建的用户账户连接mysql，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@res ~]# mysql -h172.16.206.30  -utestuser -p
Enter password: 
mysql&amp;gt; CREATE DATABASE mydb;
ERROR 1044 (42000): Access denied for user &amp;apos;testuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos; to database &amp;apos;mydb&amp;apos;
mysql&amp;gt; SHOW GRANTS FOR &amp;apos;testuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos;;
+-------------------------------------------------------------------------------+
| Grants for testuser@172.16.%.%                                                |
+-------------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO &amp;apos;testuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos; IDENTIFIED BY PASSWORD &amp;lt;secret&amp;gt; |
+-------------------------------------------------------------------------------+
1 row in set (0.04 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【说明】：USAGE：只是一个简单的连入mysql服务器的权限。这是默认获取的授权。&lt;/p&gt;
&lt;p&gt;查看用户能够使用的权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SHOW GRANTS FOR username@&amp;apos;hostname&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重命名用户账号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; RENAME USER &amp;apos;testuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos; TO &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos;;
Query OK, 0 rows affected (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;权限管理&quot;&gt;&lt;a href=&quot;#权限管理&quot; class=&quot;headerlink&quot; title=&quot;权限管理&quot;&gt;&lt;/a&gt;权限管理&lt;/h3&gt;&lt;p&gt;权限管理命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GRANT    #GRANT命令在用户事先不存在的前提下，它可以自动创建用户。&lt;/li&gt;
&lt;li&gt;REVOKE&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;权限管理分类&quot;&gt;&lt;a href=&quot;#权限管理分类&quot; class=&quot;headerlink&quot; title=&quot;权限管理分类&quot;&gt;&lt;/a&gt;权限管理分类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;库级别&lt;/li&gt;
&lt;li&gt;表级别&lt;/li&gt;
&lt;li&gt;字段级别&lt;/li&gt;
&lt;li&gt;管理类：比如能否把自己的权限转赠给其他用户、能否创建用户、能否执行复制等。&lt;/li&gt;
&lt;li&gt;程序类：比如存储过程、存储函数、触发器。   (这两类是我们自己定义的)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.管理类权限&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CREATE TEMPORARY TABLES&lt;/li&gt;
&lt;li&gt;CREATE USER&lt;/li&gt;
&lt;li&gt;FILE：在服务器上能够读取或写入文件的。比如我们通过客户端连入mysql服务器，如果想把mysql的查询结果保存到文件中，这个文件很显然就是在服务器上的。这个权限很危险，不能让用户随意使用。&lt;/li&gt;
&lt;li&gt;SUPER：杂项管理类命令。&lt;/li&gt;
&lt;li&gt;SHOW DATABASES&lt;/li&gt;
&lt;li&gt;RELOAD&lt;/li&gt;
&lt;li&gt;SHUTDOWN&lt;/li&gt;
&lt;li&gt;REPLICATION SLAVE&lt;/li&gt;
&lt;li&gt;REPLICATION CLIENT&lt;/li&gt;
&lt;li&gt;LOCK TABLES：显式施加表锁。&lt;/li&gt;
&lt;li&gt;PROCESS：查看当前服务器上执行的所有进程，可以理解为线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看当前MySQL服务器上的执行的所有线程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW PROCESSLIST;
+---------+----------------+----------------------+------------+---------+------+-------+------------------+
| Id      | User           | Host                 | db         | Command | Time | State | Info             |
+---------+----------------+----------------------+------------+---------+------+-------+------------------+
| 7793848 | root           | localhost            | NULL       | Query   |    0 | init  | SHOW PROCESSLIST |
| 7793872 | sonar          | localhost:57831      | sonar      | Sleep   |   41 |       | NULL             |
| 7794027 | testuser       | res.wisedu.com:39982 | NULL       | Sleep   |  241 |       | NULL             |
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;【注意】: 这个命令是我们将来非常常用的命令，用于查看当前mysql上内部所执行的众多跟用户相关的线程的。&lt;/strong&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.库级别和表级别&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ALTER&lt;/li&gt;
&lt;li&gt;ALTER ROUTINE：修改存储例程，包括存储过程和存储函数。&lt;/li&gt;
&lt;li&gt;CREATE &lt;/li&gt;
&lt;li&gt;CREATE ROUTINE&lt;/li&gt;
&lt;li&gt;CREATE VIEW&lt;/li&gt;
&lt;li&gt;DROP&lt;/li&gt;
&lt;li&gt;EXECUTE：是否能够执行存储过程或存储函数。&lt;/li&gt;
&lt;li&gt;GRNAT OPTION：把自己获得的权限转赠给别人。&lt;/li&gt;
&lt;li&gt;INDEX&lt;/li&gt;
&lt;li&gt;SHOW VIEW：查看一个视图是怎么被创建的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3.数据操作(表级别)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SELECT&lt;/li&gt;
&lt;li&gt;INSERT&lt;/li&gt;
&lt;li&gt;UPDATE&lt;/li&gt;
&lt;li&gt;DELETE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4.数据操作(字段级别)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SELECT(col1,…)&lt;/li&gt;
&lt;li&gt;UPDATE(col1,…)&lt;/li&gt;
&lt;li&gt;INSERT(col1,…)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5.所有权限&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ALL [PRIVILEGES]&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;权限管理命令之GRANT&quot;&gt;&lt;a href=&quot;#权限管理命令之GRANT&quot; class=&quot;headerlink&quot; title=&quot;权限管理命令之GRANT&quot;&gt;&lt;/a&gt;权限管理命令之GRANT&lt;/h4&gt;&lt;p&gt;两种使用格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GRANT ALL ON [FUNCTION] *.*      
第一个*表示库，如果第一个*前面没有修饰，那默认第2个*表示表，否则比如加个FUNCTION，第二个*表示的就是某个库的存储函数。修饰有3个，[TABLE|FUNCTION|PROCEDURE]。
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; HELP GRANT&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Name: &amp;apos;GRANT&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Description:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Syntax:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GRANT&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    priv_type [(column_list)]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      [, priv_type [(column_list)]] ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ON [object_type] priv_level&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    TO user_specification [, user_specification] ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [REQUIRE &amp;#123;NONE | ssl_option [[AND] ssl_option] ...&amp;#125;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [WITH &amp;#123;GRANT OPTION | resource_option&amp;#125; ...]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GRANT PROXY ON user_specification&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    TO user_specification [, user_specification] ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [WITH GRANT OPTION]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;object_type: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    TABLE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | FUNCTION&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | PROCEDURE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;priv_level: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    *&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | *.*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | db_name.*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | db_name.tbl_name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | tbl_name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | db_name.routine_name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;user_specification:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    user [ auth_option ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;auth_option: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    IDENTIFIED BY &amp;apos;auth_string&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | IDENTIFIED BY PASSWORD &amp;apos;hash_string&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | IDENTIFIED WITH auth_plugin&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | IDENTIFIED WITH auth_plugin AS &amp;apos;hash_string&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ssl_option: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    SSL&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | X509&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | CIPHER &amp;apos;cipher&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | ISSUER &amp;apos;issuer&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | SUBJECT &amp;apos;subject&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;GRANT OPTION # 允许把自己的权限转赠给其他用户&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;resource_option: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | MAX_QUERIES_PER_HOUR count #每小时所能执行的最多查询请求的次数，这是做资源限定的&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | MAX_UPDATES_PER_HOUR count # 每小时所能执行的最多更新的次数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | MAX_CONNECTIONS_PER_HOUR count&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  | MAX_USER_CONNECTIONS count # 指定某个用户帐号最多同时连接几次&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面那个例子中，我们使用普通用户 tuser@’172.16.%.%’ 连接上去是不能创建数据库的，接下来我们使用root账户登录上去授权这个普通用户一些权限，看看效果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; GRANT CREATE ON mydb.tb1 TO &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos;;
Query OK, 0 rows affected (0.02 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【注意】:这个权限只能创建tb1这个表，不能创建库mydb，见下面。管理员授权后，普通用户连接上mysql，可以查看自己的权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW GRANTS FOR &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos;;   
+----------------------------------------------------------------------------+
| Grants for tuser@172.16.%.%                                                |
+----------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos; IDENTIFIED BY PASSWORD &amp;lt;secret&amp;gt; |
| GRANT CREATE ON `mydb`.`tb1` TO &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos;                       |
+----------------------------------------------------------------------------+
2 rows in set (0.00 sec)

mysql&amp;gt; CREATE DATABASE mydb;
ERROR 1044 (42000): Access denied for user &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos; to database &amp;apos;mydb&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时确实不能创建数据库。使用root账号授权如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; GRANT CREATE ON mydb.* TO &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos;;   
Query OK, 0 rows affected (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;普通用户再次查看自己的权限，然后在创建数据库就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW GRANTS FOR &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos;;
+----------------------------------------------------------------------------+
| Grants for tuser@172.16.%.%                                                |
+----------------------------------------------------------------------------+
| GRANT USAGE ON *.* TO &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos; IDENTIFIED BY PASSWORD &amp;lt;secret&amp;gt; |
| GRANT CREATE ON `mydb`.* TO &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos;                           |
| GRANT CREATE ON `mydb`.`tb1` TO &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos;                       |
+----------------------------------------------------------------------------+
3 rows in set (0.00 sec)

mysql&amp;gt; CREATE DATABASE mydb;
Query OK, 1 row affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/86.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在赋予删除表的权限：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; GRANT DROP ON mydb.* TO &amp;apos;tuser&amp;apos;@&amp;apos;172.16.%.%&amp;apos;;      
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;普通用户查看权限和删除表、库：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/87.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;所以为了让那些在线用户能够立即获取权限，就要在授权后FLUSH。&lt;/p&gt;
&lt;h4 id=&quot;权限管理命令之REVOKE&quot;&gt;&lt;a href=&quot;#权限管理命令之REVOKE&quot; class=&quot;headerlink&quot; title=&quot;权限管理命令之REVOKE&quot;&gt;&lt;/a&gt;权限管理命令之REVOKE&lt;/h4&gt;&lt;p&gt;两种使用格式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;REVOKE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  priv_type [(column_list)]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [, priv_type [(column_list)]] ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ON [object_type] priv_level&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  FROM user [, user] ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;REVOKE ALL PRIVILEGES, GRANT OPTION&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  FROM user [, user] ...&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所有给用户授权的这些权限都会保存在跟用户相关的授权表当中，几个跟用户授权相关的表(都在mysql库中)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;db: 库级别权限。&lt;/li&gt;
&lt;li&gt;host: 主机级别权限，已废弃。&lt;/li&gt;
&lt;li&gt;tables_priv: 表级别权限。&lt;/li&gt;
&lt;li&gt;colomns_priv：列级别的权限。&lt;/li&gt;
&lt;li&gt;procs_priv：存储过程和存储函数相关的权限。&lt;/li&gt;
&lt;li&gt;proxies_priv：代理用户权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/88.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对MySQL来讲，检查用户授权分两个阶段，mysql用户刚刚执行连入数据库时需要认证，检查用户名密码并且检查用户是否有连进来的权限；连接进来以后，用户每次执行SELECT操作也要检验权限。所以MySQL在执行权限检查时，几乎每一次操作都涉及到，这也是为什么mysql为什么将授权表载入内存中的原因，不然它的速度会有多慢。&lt;br&gt;    如果用户在登录mysql时输错了命令，连续输错了好多次，会被mysql锁定的。再次登录，mysql会直接拒绝了，不会检查授权表。mysql认为这是尝试攻击。如果遇到这种情况，我们需要FLUSH hosts，让系统清空一下hosts相关的缓存，这样用户就可以再次连接。&lt;/p&gt;
&lt;p&gt;之前的文章中提到过MySQL作者在MySQL被Oracle收购后，又带着团队重新开发了MariaDB。在MariaDB中，有两款支持事务的，FEDERATED和InnoDB。只不过FEDERATED不支持XA(分布式事务)。&lt;br&gt;Aria是增强版的MyISAM。&lt;br&gt;MySQL和MariaDB除了这些存储引擎上的区别，他们两个区别并不大。但是要注意MariaDB的服务器变量非常多，有400多个。&lt;/p&gt;
&lt;h2 id=&quot;MySQL查询缓存&quot;&gt;&lt;a href=&quot;#MySQL查询缓存&quot; class=&quot;headerlink&quot; title=&quot;MySQL查询缓存&quot;&gt;&lt;/a&gt;MySQL查询缓存&lt;/h2&gt;&lt;p&gt;每个查询语句要做词法分析，语法分析、语义分析，然后执行解析树，从中选择一个最优路径，并且通过优化器重写查询，并选择合适的索引完成查询操作。而如果这个查询计划被缓存下来，多个用户使用同一个SELECT语句时，语句如果避免二次解析，它就能够加速查询操作。&lt;br&gt;    用于保存MySQL查询语句返回的完整结果。被命中时，MySQL会立即返回结果，省去解析、优化和执行等阶段。&lt;br&gt;    但是查询缓存带来的未必都是好事。为什么呢？现在运行数据库数据的服务器硬件越来越强大，内存动辄几十个g，32g、64g都很常见，而且CPU动辄就是好几颗，每一颗都有好多核，而多个用户同时连进来时，每个用户都有一个连接线程，这些线程会被分配到多颗CPU上执行的。由于MySQL的内生性限制，单独的一条查询最多只能在一颗CPU上执行，如果我们使用了查询缓存，多个用户都执行查询操作，每个查询操作都要查缓存，也就意味着缓存会成为多个能够并发在多颗CPU上执行的查询请求的热点所在，会不会争用。第一个线程发起了查询语句，去查了缓存，假设2颗CPU，每颗32核，现在连进来了64个用户，大家都发起了查询操作，都去查询缓存，所以缓存就成为资源争用的热点所在了。在某一时刻，这段内存空间只能为其中一颗CPU所访问。所以在这种场景下，缓存所带来的未必有我们想象中的好。因为你不能只用单颗CPU的方式去思考mysql服务器。并发查询量非常大，而且CPU核心数又非常多时，缓存是否有效就是个值得思考的问题。&lt;/p&gt;
&lt;p&gt;一个mysql查询操作会经过类似的步骤：&lt;br&gt;   一个查询请求来了，首先检查缓存是否命中，命中则直接返回结果。没命中，解析、优化、执行，执行后的结果先看看能否进行缓存，如果能，缓存到缓存中，然后在把结果返回给用户。&lt;/p&gt;
&lt;h3 id=&quot;什么样的语句不会被缓存？&quot;&gt;&lt;a href=&quot;#什么样的语句不会被缓存？&quot; class=&quot;headerlink&quot; title=&quot;什么样的语句不会被缓存？&quot;&gt;&lt;/a&gt;什么样的语句不会被缓存？&lt;/h3&gt;&lt;p&gt;查询语句中有一些不确定数据时，不会缓存：例如NOW(), CURRENT_TIME()；一般来说，如果查询中包含用户自定义函数、存储函数、用户变量、临时表、mysql库中系统表、或者任何包含权限的表，一般都不会缓存；&lt;/p&gt;
&lt;h3 id=&quot;缓存会带来额外开销&quot;&gt;&lt;a href=&quot;#缓存会带来额外开销&quot; class=&quot;headerlink&quot; title=&quot;缓存会带来额外开销&quot;&gt;&lt;/a&gt;缓存会带来额外开销&lt;/h3&gt;&lt;p&gt;缓存会带来如下的开销，只有当这种开销小于缓存给我们带来的益处时才有必要启用缓存&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个查询都得先检查是否命中；&lt;/li&gt;
&lt;li&gt;查询结果要先缓存；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;查看当前MySQL上缓存的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW GLOBAL VARIABLES LIKE &amp;apos;query_cache%&amp;apos;;
+------------------------------+---------+
| Variable_name                | Value   |
+------------------------------+---------+
| query_cache_limit            | 1048576 |
| query_cache_min_res_unit     | 4096    |
| query_cache_size             | 1048576 |
| query_cache_type             | OFF     |
| query_cache_wlock_invalidate | OFF     |
+------------------------------+---------+
5 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;query_cache_type: 查询缓存类型；就是指是否开启缓存功能，其开启方式有三种{ON|OFF|DEMAND}；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DEMAND：意味着SELECT语句明确使用 SQL_CACHE 选项时才会缓存；&lt;/li&gt;
&lt;li&gt;一般而言除非我们明确知道哪些语句缓存下来才有意义的时候才会使用DEMAND，否则我们如果要想使用缓存机制，设置为ON。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;query_cache_size: 总空间，单位为字节，大小必须是1024的整数倍。16777216是16M，比较小。如果内存够用，可以调大点，但是也不要太大，看你命中率。如果调大能提高命中率，就应该调大些。但是查询命中率，要先”预热”，刚开机你就去查缓存命中率，那没意义。MySQL启动时，会一次性分配并立即初始化这里指定大小的内存空间；这意味着，如果修改此大小，会清空缓存并重新初始化的。不建议经常改，最好事先设置好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;query_cache_min_res_unit: 存储缓存的最小内存块；(query_cache_size-Qcache_free_memory)/Qcache_queries_in_cache能够获得一个理想的值。缓存必须要划分成内存块进行缓存的，比如一个划分的内存块一个为1k，某一个查询结果只有30bytes，缓存在一个内存块里，剩余的空间就浪费了。所以这个内存块太大了会导致浪费，太小了我缓存一个大结果，得申请很多个内存块才能存下来。最好你能够观测一下大多数查询，很多结果都是满足正太分布的，找那些分布率比较集中的地方的缓存大小。当然也可以用上面的公式去计算，得到的值是比较理想的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;query_cache_limit: 单个缓存对象的最大值，超出时则不予缓存；可以在SELECT语句中手动使用SQL_NO_CACHE可以人为地避免尝试缓存返回结果超出此参数限定值的语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;query_cache_wlock_invalidate: 如果某个表被其它用户的连接(查询)锁住了，是否仍然从缓存中返回结果。OFF表示返回。&lt;br&gt;因为其他用户锁住了表，他可能会改表中的数据，也可能不改，这个时候是返回还是不返回呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何检查缓存？&quot;&gt;&lt;a href=&quot;#如何检查缓存？&quot; class=&quot;headerlink&quot; title=&quot;如何检查缓存？&quot;&gt;&lt;/a&gt;如何检查缓存？&lt;/h3&gt;&lt;p&gt;MySQL保存结果于缓存中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把SELECT语句本身做hash计算，计算的结果作为key，查询结果作为value。&lt;/li&gt;
&lt;li&gt;所以缓存由两个字段组成，一个是key，一个是value。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缓存到底有没有效不能简单的根据有多少SELECT语句来判定，我们要去判定缓存命中率。但是这个缓存命中率的高和低不能简单的根据查询的命中次数来判定，一般来讲，要根据它的开销来判断命中率到底有多高。命中率有两种，次数命中率和字节命中率(命中后所省去的传输数据量)。&lt;/p&gt;
&lt;h3 id=&quot;如何判断命中率？&quot;&gt;&lt;a href=&quot;#如何判断命中率？&quot; class=&quot;headerlink&quot; title=&quot;如何判断命中率？&quot;&gt;&lt;/a&gt;如何判断命中率？&lt;/h3&gt;&lt;p&gt;查看次数命中率，而不是字节命中率。衡量时最好都衡量&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; SHOW GLOBAL STATUS LIKE &amp;apos;Qcache%&amp;apos;;     &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+-------------------------+----------+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Variable_name           | Value    |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+-------------------------+----------+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Qcache_free_blocks      | 1        | 空闲的块数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Qcache_free_memory      | 16757008 | 空闲空间&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Qcache_hits             | 4        | 命中次数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Qcache_inserts          | 2        | 向缓存空间中缓存数据的次数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Qcache_lowmem_prunes    | 0        | 因为内存太少而腾出内存的次数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Qcache_not_cached       | 18       | 没被缓存的语句的次数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Qcache_queries_in_cache | 2        | 在缓存中缓存的查询的个数。和Qcache_inserts不一定一样大。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Qcache_total_blocks     | 6        | 缓存总块数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+-------------------------+----------+&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;【注意】:总空间-空闲空间=已用空间。但并非已用空间都缓存了数据，这些已用块数表示已划分好格式了，可以随时等待数据缓存进来。&lt;br&gt;如果内存中的确有碎片了，比如说空闲空间还很多，但是内存总是被修剪(腾出)，这可能是有大量碎片导致大结果无法被缓存。这就需要清理碎片了。只是把碎片挪出去，做成连续空间。&lt;br&gt;碎片整理：FLUSH QUERY_CACHE&lt;br&gt;清空缓存：RESET QUERY_CACHE&lt;/p&gt;
&lt;p&gt;计算次数命中率：(节命中率很难估算)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; SHOW GLOBAL STATUS WHERE Variable_name=&amp;apos;Qcache_hits&amp;apos; OR Variable_name=&amp;apos;Com_select&amp;apos;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+---------------+-------+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Variable_name | Value |&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+---------------+-------+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Com_select    | 24    |  一共查询了这么多次&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;| Qcache_hits   | 4     |  命中的查询的次数，注意命中了缓存，上面那个查询次数是不会加1的。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+---------------+-------+&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Qcache_hits/(Com_select+Qcache_hits)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;也应该参考另外一个指标：命中和写入的比率，即Qcache_hits/Qcache_inserts的值，此比值如果能大于3:1，则表明缓存也是有效的。能达到10:1，为比较理想的情况。&lt;/p&gt;
&lt;h3 id=&quot;缓存优化使用思路&quot;&gt;&lt;a href=&quot;#缓存优化使用思路&quot; class=&quot;headerlink&quot; title=&quot;缓存优化使用思路&quot;&gt;&lt;/a&gt;缓存优化使用思路&lt;/h3&gt;&lt;p&gt;1、批量写入而非多次单个写入；&lt;br&gt;2、缓存空间不宜过大，因为大量缓存同时失效时会导致服务器假死；&lt;br&gt;3、必要时，使用SQL_CACHE和SQL_N0_CACHE手动控制缓存；&lt;br&gt;4、对写密集型的应用场景来说，禁用缓存反而能提高性能。读写比例一样大的时候最好也关了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL用户管理&quot;&gt;&lt;a href=&quot;#MySQL用户管理&quot; class=&quot;headerlink&quot; title=&quot;MySQL用户管理&quot;&gt;&lt;/a&gt;MySQL用户管理&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;用户帐号：username@hostname, password       
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表示这个账号允许通过hostname主机连入mysql服务器。hostname可以是单个ip，也可以是一个网络，也可以是通配符。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL存储引擎对比</title>
    <link href="http://yoursite.com/2018/04/08/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2018/04/08/MySQL存储引擎对比/</id>
    <published>2018-04-08T08:36:31.000Z</published>
    <updated>2018-04-10T09:12:34.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;MySQL存储引擎&quot;&gt;&lt;a href=&quot;#MySQL存储引擎&quot; class=&quot;headerlink&quot; title=&quot;MySQL存储引擎&quot;&gt;&lt;/a&gt;MySQL存储引擎&lt;/h2&gt;&lt;p&gt;存储引擎也通常称作“表类型”。可以在创建表时指定其存储引擎。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW ENGINES;    #查看支持的存储引擎。
mysql&amp;gt; SHOW TABLES STATUS [LIKE clause] [WHERE clause] #使用WHERE比使用LIKE性能好
SHOW TABLE STATUS [{FROM | IN} db_name] [LIKE &amp;apos;pattern&amp;apos; | WHERE expr] #如果设定了数据库，就不需要指定[{FROM | IN} db_name] 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【示例】：查看某张表的存储引擎&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW TABLE STATUS IN hellodb WHERE Name=&amp;apos;classes&amp;apos;\G
*************************** 1. row ***************************
               Name: classes
             Engine: InnoDB
            Version: 10
         Row_format: Compact
               Rows: 8
     Avg_row_length: 2048
        Data_length: 16384
    Max_data_length: 0
       Index_length: 0
          Data_free: 9437184
     Auto_increment: 9
        Create_time: 2014-04-08 11:14:52
        Update_time: NULL
         Check_time: NULL
          Collation: utf8_general_ci
           Checksum: NULL
     Create_options: 
            Comment: 
    1 row in set (0.01 sec)   
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Name: 表名&lt;/li&gt;
&lt;li&gt;Engine: 存储引擎&lt;/li&gt;
&lt;li&gt;Version: 表的版本&lt;/li&gt;
&lt;li&gt;Row_format: 行格式。这些行格式是MySQL在其内部存储行数据时所采用的格式。每一种不同格式，其存储空间、开销是各部相同的。对于MyISAM表，常用的通常有DYNAMIC、FIXED或者COMPRESSED。而对于InnoDB存储引擎来讲，还可以额外使用REDUNDANT、COMPACT等类型。对于InnoDB来讲，默认是COMPACT。&lt;br&gt;{DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}&lt;/li&gt;
&lt;li&gt;Rows: 表中的行数。【注意】:对于MyISAM表来讲是精确的，但是对于InnoDB来讲未必精确。因为InnoDB基于多版本并发控制，里面有多种版本的快照，所以有些行你删了里面依然可能有。所以InnoDB表里的行数可能是个估计值。&lt;/li&gt;
&lt;li&gt;Avg_row_length: 平均每行所包含的字节数。&lt;/li&gt;
&lt;li&gt;Data_length: 表中数据总体大小，单位是字节。Data_length:=RowsXAvg_row_length。&lt;/li&gt;
&lt;li&gt;Max_data_length: 表能够占用的最大空间，单位为字节。0表示没有上限。&lt;/li&gt;
&lt;li&gt;Index_length: 索引的大小，单位为字节。&lt;/li&gt;
&lt;li&gt;Data_free: 对于MyISAM表，表示已经分配但尚未使用的空间(就是划分给这个表的块的剩余空间)，其中包含此前删除行之后腾出来的空间。对于InnoDB表，就比较复杂了。&lt;/li&gt;
&lt;li&gt;Auto_increment: 下一个AUTO_INCREMENT的值；&lt;/li&gt;
&lt;li&gt;Create_time: 表的创建时间；&lt;/li&gt;
&lt;li&gt;Update_time：表数据的最近一次的修改时间；&lt;/li&gt;
&lt;li&gt;Check_time：mysql的一些工具，比如使用CHECK TABLE或myisamchk最近一次检测表的时间；&lt;/li&gt;
&lt;li&gt;Collation: 排序规则；&lt;/li&gt;
&lt;li&gt;Checksum: 如果启用，则为表的checksum；为空表示没有启用校验功能。但是请注意，每次修改表，这个值也会变动，会产生额外的I/O，性能会有影响，但是对表的一致性和数据完整性提供了额外保证；&lt;/li&gt;
&lt;li&gt;Create_options: 创建表时指定使用的其它选项，比如SQL_Cache等选项；&lt;/li&gt;
&lt;li&gt;Comment: 表的注释信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;存储引擎中的数据和数据文件&quot;&gt;&lt;a href=&quot;#存储引擎中的数据和数据文件&quot; class=&quot;headerlink&quot; title=&quot;存储引擎中的数据和数据文件&quot;&gt;&lt;/a&gt;存储引擎中的数据和数据文件&lt;/h2&gt;&lt;h3 id=&quot;InnoDB&quot;&gt;&lt;a href=&quot;#InnoDB&quot; class=&quot;headerlink&quot; title=&quot;InnoDB&quot;&gt;&lt;/a&gt;InnoDB&lt;/h3&gt;&lt;p&gt;两种格式：&lt;br&gt;&lt;strong&gt;1、innodb_file_per_table=OFF，即使用共享表空间。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每张表有一个独有的格式定义文件: tb_name.frm&lt;/li&gt;
&lt;li&gt;还有一个默认位于数据目录下共享的表空间文件：ibdata#   (一个表空间文件大小到达一定程度后，会启动第二个表空间文件)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2、innodb_file_per_table=ON，即使用独立表空间。&lt;/strong&gt;&lt;br&gt;每个表在数据库目录下存储两个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tb_name.frm&lt;/li&gt;
&lt;li&gt;tb_name.ibd&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;表空间：table space，由InnoDB管理的特有格式数据文件，内部可同时存储数据和索引(因此是聚簇索引)。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;MyISAM&quot;&gt;&lt;a href=&quot;#MyISAM&quot; class=&quot;headerlink&quot; title=&quot;MyISAM&quot;&gt;&lt;/a&gt;MyISAM&lt;/h3&gt;&lt;p&gt;每个表都在数据库目录(data目录)下存储三个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tb_name.frm  #表结构的定义&lt;/li&gt;
&lt;li&gt;tb_name.MYD  #数据&lt;/li&gt;
&lt;li&gt;tb_name.MYI  #索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何修改默认存储引擎：通过default_storage_engine服务变量实现。要想永久生效，需要写到配置文件中，重启生效。&lt;/p&gt;
&lt;h2 id=&quot;各存储引擎的特性&quot;&gt;&lt;a href=&quot;#各存储引擎的特性&quot; class=&quot;headerlink&quot; title=&quot;各存储引擎的特性&quot;&gt;&lt;/a&gt;各存储引擎的特性&lt;/h2&gt;&lt;p&gt;mysql 5.3.8之后mysql就被oracle收购了，原生自带InnoDB存储引擎了。(以前InnoDB是插件形式工作的，但是自从oracle收购InnoDB后做了很大改进，再到后来收购了sun，InnoDB就自然成为原生的了。)&lt;/p&gt;
&lt;h3 id=&quot;InnoDB-1&quot;&gt;&lt;a href=&quot;#InnoDB-1&quot; class=&quot;headerlink&quot; title=&quot;InnoDB&quot;&gt;&lt;/a&gt;InnoDB&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;支持事务：有事务日志。为什么要有事务日志啊？&lt;strong&gt;因为可以它能够把随机I/O改为顺序I/O。&lt;/strong&gt;事务日志在数据目录下，至少有两个，而且大小固定，不会增长，而且一定是磁盘上的一段连续存储空间。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/82.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;支持外键约束：MyISAM是不支持的，因为不支持事务就很难使用外键。&lt;/li&gt;
&lt;li&gt;MVCC：多版本并发控制。&lt;/li&gt;
&lt;li&gt;支持聚簇索引：也叫聚集索引。说白了就是数据和索引存储在一起，通过表空间来实现的。也就意味着创建InnoDB表时必须要有主键。这样的话InnoDB表的查询比MyISAM表的查询多了一步，因为所有非聚集索引(又称为辅助索引)不是指向数据的，而是指向聚簇索引的。什么意思呢？(该节视频31分钟左右开始)。&lt;br&gt;聚簇索引之外的其它索引，通常称为辅助索引。聚簇索引只能有一个，辅助索引可以有多个。&lt;/li&gt;
&lt;li&gt;行级锁：行级锁之上它在实现MVCC机制时是基于”间隙锁”实现的。在行和行之间加间隙锁来隔离行。&lt;/li&gt;
&lt;li&gt;支持辅助索引：有些NoSQL只支持一种索引。&lt;/li&gt;
&lt;li&gt;支持自适应hash索引&lt;/li&gt;
&lt;li&gt;支持热备份：因此数据库不用离线就可以实现备份了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【补充】:聚簇索引和辅助索引。&lt;/strong&gt;&lt;br&gt;位于磁盘上的数据，我们需要把所有载入内存才可以查询的，太慢了。于是我们把表中数据按我们经常查询的叫搜索键，通常是一个字段，通常我们用于WHERE子句中比较的字段，把它抽取出来做索引就好了，这样可以提高查询速度的。这个索引文件如果是额外存放的，意味着要把这个字段的值复制一份出来，放在另外一个位置，这就是索引文件。但是这索引信息是要被排序的，它把表中的字段拿出来后重新排了下序。排完序以后，一个字段对应的那个行在哪？也就是我们找到索引后，怎么找到对应的整行数据？索引里面有原数据，只有一部分，只有你所抽取的字段，如果你找的正好是那个字段，那就不用去查原来的表了。比如SELECT Age FROM students WHERE Age &amp;gt; 30，那就意味着索引要建立在Age上才行，假如我们在Age上创建了索引，意味着索引文件中已经都有了Age字段的所有数据，正好我们找的就是Age，但是如果我们找的不是Age这个字段，而是Name，那么就需要先找到符合索引条件(Age &amp;gt; 30)的条目，这个条目有指向其在原数据中的行的位置，接着就找到行所在的磁盘块，把这个磁盘块载入内存，对应表中的那个行的所有字段就找到了，从而Name也就找到了。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/83.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;图中，索引和数据是分开存放的，也就意味着我们找到索引以后，还得做第二次I/O，找到那个真正数据所在磁盘上的位置，然后把数据读进来。&lt;br&gt;        那什么是聚簇索引呢？索引条目和行是挨着存放的，所以你只要能找到索引，就直接能找到这个行了。一个表能有几个聚簇索引呢？索引是排序的，我们按年龄排序和按姓名排序，其结果不一样。由于索引和数据是存放在一起的，那就意味着索引怎么排序，数据就一定是怎么排序的。如果索引按年龄排序存放了，数据也就按年龄排序存放了，很显然不能在拿姓名来排序存放了。所以对于一张表来讲，聚簇索引只能有一个。非聚簇索引可以有多个，因为排序只是索引本身，不是数据。而对于InnoDB表来讲，非聚簇索引的数据指针并不是指向数据的，而是指向聚簇索引。因此查找InnoDB表分两步，先找辅助索引，然后根据辅助索引找到聚簇索引，然后在找到数据。所以选择一个好的聚簇索引能够非常好的提升InnoDB的查询性能的。&lt;br&gt;        因此对于InnoDB表来说必须有一个聚簇索引，而聚簇索引通常用主键来实现，因为主键中的数据是不允许重复的，所以索引中出现重复的可能性就没有了。因此我们通常提供一个主键用于聚簇索引。&lt;br&gt;        当然，无论是聚簇索引还是辅助索引都是B树索引，因为聚簇和辅助只是指明了它的存储位置是否和原数据存储在一块的，但B树指的是索引自己的内部结构，数据结构。你可以把房子盖到市中心，也可以盖到郊区，但房子本身可以是别墅或一室两厅。一个按位置来讲，一个是按数据结构来讲。B树是一种数据结构。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/84.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;MyISAM-1&quot;&gt;&lt;a href=&quot;#MyISAM-1&quot; class=&quot;headerlink&quot; title=&quot;MyISAM&quot;&gt;&lt;/a&gt;MyISAM&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;支持全文索引：InnoDB不支持。但是InnoDB不支持，好在可以借助额外的其他工具来完成对InnoDB表的全文索引。因此这对于InnoDB来说不是一个缺陷。比如编译Mroonga存储引擎，这是一个很独特的存储引擎。&lt;/li&gt;
&lt;li&gt;支持表压缩：用于实现数据仓库，能节约存储空间并提升性能。只不过压缩以后就不能修改了，只能查询。所以在压缩的时候主要是用来做数据仓库的。&lt;/li&gt;
&lt;li&gt;支持空间索引：InnoDB也支持空间索引。要想使用空间索引，得使用空间函数，才能完成里面的很多数据的操作。&lt;/li&gt;
&lt;li&gt;支持表级锁：不支持行级锁，所以锁开销比较小。如果读写比例是9:1或8:2，对MyISAM是非常理想的。如果读写差不多比例，那么使用MyISAM其性能就下降太厉害了。所以读写差不多的话，建议使用InnoDB表。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持延迟更新索引：很多时候索引是为了提升读操作的，那么对写操作会有延迟。好在MyISAM支持延迟更新索引键。创建表有个选项delay_key_write，延迟键更新。这样每当数据更新时，不必要立即更新索引，使得其I/O压力就降低了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不支持事务、外键和行级锁&lt;br&gt;崩溃后无法安全恢复数据(你可能得使用repairtable这样的命令去修复表，而这个修复过程通常是不可控的。不像InnoDB，如果崩溃了，InnoDB存储引擎会自行根据事务日志进行恢复)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;适用场景：只读数据、较小的表、能够容忍崩溃后的修改操作时长和数据丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，mysql库中的表都是MyISAM的，因为mysql这个库是数据字典，而数据字典大多数情况下都是一次创建，但是我们对表的读取却是多次的，所以是一种多读少写的场景，而且表也不会特别大。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW TABLE STATUS IN mysql\G
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;ARCHIVE&quot;&gt;&lt;a href=&quot;#ARCHIVE&quot; class=&quot;headerlink&quot; title=&quot;ARCHIVE&quot;&gt;&lt;/a&gt;ARCHIVE&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;仅支持INSERT和SELECT，支持很好压缩功能；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;适用于存储日志信息，或其它按时间序列实现的数据采集类的应用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不支持事务，不能很好的支持索引；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;CSV&quot;&gt;&lt;a href=&quot;#CSV&quot; class=&quot;headerlink&quot; title=&quot;CSV&quot;&gt;&lt;/a&gt;CSV&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;将数据存储为CSV格式；不支持索引；仅适用于数据交换场景；&lt;br&gt;你可以将excel中表中数据存储为csv格式的，然后在把它导入到mysql中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;BLACKHOLE&quot;&gt;&lt;a href=&quot;#BLACKHOLE&quot; class=&quot;headerlink&quot; title=&quot;BLACKHOLE&quot;&gt;&lt;/a&gt;BLACKHOLE&lt;/h3&gt;&lt;p&gt;没有存储机制，任何发往此引擎的数据都会丢弃；其会记录二进制日志，因此，常用于多级复制架构中作中转服务器；&lt;/p&gt;
&lt;h3 id=&quot;MEMORY&quot;&gt;&lt;a href=&quot;#MEMORY&quot; class=&quot;headerlink&quot; title=&quot;MEMORY&quot;&gt;&lt;/a&gt;MEMORY&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;保存数据在内存中，内存表；常用于保存中间数据，如周期性的聚合数据等；也用于实现临时表&lt;/li&gt;
&lt;li&gt;仅支持hash索引，使用表级锁，不支持BLOB和TEXT数据类型；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;MRG-MYISAM&quot;&gt;&lt;a href=&quot;#MRG-MYISAM&quot; class=&quot;headerlink&quot; title=&quot;MRG_MYISAM&quot;&gt;&lt;/a&gt;MRG_MYISAM&lt;/h3&gt;&lt;p&gt;是MYISAM的一个变种，能够将多个MyISAM表合并成一个虚表；&lt;br&gt;但是现在很多应用场景中存的数据量非常大，而一张表中存的数据过多，查询的时候性能会很差。所以很多时候需要借助一些机制将一个表切割成多张表，更别说合并表了。所以这个引擎很少用。&lt;/p&gt;
&lt;h3 id=&quot;NDB&quot;&gt;&lt;a href=&quot;#NDB&quot; class=&quot;headerlink&quot; title=&quot;NDB&quot;&gt;&lt;/a&gt;NDB&lt;/h3&gt;&lt;p&gt;是MySQL CLUSTER中专用的存储引擎。是位于内存中完成数据存储和交换的，能够实现分布式、不做任何共享的、容灾的、高可用的mysql集群，但实际上这种集群没人用。&lt;br&gt;其实早期NDB是爱立信的一个数据库，而后2003年mysql AB公司从爱立信收购了NDB，随后把NDB转换为了存储引擎。&lt;/p&gt;
&lt;h2 id=&quot;第三方的存储引擎&quot;&gt;&lt;a href=&quot;#第三方的存储引擎&quot; class=&quot;headerlink&quot; title=&quot;第三方的存储引擎&quot;&gt;&lt;/a&gt;第三方的存储引擎&lt;/h2&gt;&lt;h3 id=&quot;OLTP类：在线事务处理&quot;&gt;&lt;a href=&quot;#OLTP类：在线事务处理&quot; class=&quot;headerlink&quot; title=&quot;OLTP类：在线事务处理&quot;&gt;&lt;/a&gt;OLTP类：在线事务处理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;XtraDB: 增强版的InnoDB，由Percona提供。&lt;br&gt;编译安装时，下载XtraDB的源码替换MySQL存储引擎中的InnoDB的源码。然后重命名XtraDB为InnoDB，接着编译安装mysql，就可以取代InnoDB，只不过仍然叫做InnoDB。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PBXT: MariaDB自带此存储引擎。&lt;br&gt;支持引擎级别的复制、外键约束，对SSD磁盘提供适当支持；&lt;br&gt;支持事务、MVCC。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;TokuDB: 使用Fractal Trees(分形树)索引(这个索引很新，性能很好)，适用存储大数据，拥有很高的压缩比；已经被引入MariaDB。事实上，在mysql被oracle收购后，Apple就立即抛弃了mysql，转向了pgSQL。Apple的领导人很有远见的，迟早有一天要抛弃，还不如早点抛弃。现在Google、Facebook都在纷纷抛弃mysql，转向MariaDB。而Redhat7不在提供mysql，而默认提供MariaDB。可以预见，CentOS、Fedora以后都会转向MariaDB。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;列式存储引擎-NoSQL用的多&quot;&gt;&lt;a href=&quot;#列式存储引擎-NoSQL用的多&quot; class=&quot;headerlink&quot; title=&quot;列式存储引擎(NoSQL用的多)&quot;&gt;&lt;/a&gt;列式存储引擎(NoSQL用的多)&lt;/h3&gt;&lt;p&gt;Mysql数据是这么存的，所有数据在存储时首先划分成逻辑块的，在每一个逻辑块中存的是数据行，一行一行存，不够存的话，再找一个数据块存。而列式存储是按列存的，先存一个字段。这对于按列查询会很有效，比如找所有用户，找到Name那个字段就可以了。web应用常用的反而是列式查询。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Infobright: 目前较有名的列式存储引擎，适用于海量数据存储场景，如PB级别，专为数据分析和数据仓库设计，有商业版和社区版。但是要想使用Infobright存储引擎，需要对mysql做定制。&lt;/li&gt;
&lt;li&gt;InfiniDB&lt;/li&gt;
&lt;li&gt;MonetDB&lt;/li&gt;
&lt;li&gt;LucidDB&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;开源社区提供的存储引擎&quot;&gt;&lt;a href=&quot;#开源社区提供的存储引擎&quot; class=&quot;headerlink&quot; title=&quot;开源社区提供的存储引擎&quot;&gt;&lt;/a&gt;开源社区提供的存储引擎&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Aria：前身为Maria，可理解为增强版的MyISAM(支持崩溃后安全恢复，支持数据缓存。MyISAM只支持索引缓存，不支持数据缓存)&lt;/li&gt;
&lt;li&gt;Groona：全文索引引擎，Mroonga是基于Groona的二次开发版。&lt;/li&gt;
&lt;li&gt;OQGraph: 由Open Query研发，支持图结构的存储引擎。&lt;br&gt;图是最难处理的数据结构。常用的数据结构有4种：顺序结构(线性结构)、链式结构、树型结构和图。&lt;/li&gt;
&lt;li&gt;SphinxSE: 为Sphinx全文搜索服务器提供了SQL接口。这个已经被整合进了MariaDB了。&lt;/li&gt;
&lt;li&gt;Spider: 能将表中的物理数据切分成不同分片，比较高效透明地实现了分片(shared)，还可以存于不同的服务器上，并支持在分片上支持并行查询。就像很多NoSQL的分片。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;索引类型&quot;&gt;&lt;a href=&quot;#索引类型&quot; class=&quot;headerlink&quot; title=&quot;索引类型&quot;&gt;&lt;/a&gt;索引类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;聚簇索引&lt;/li&gt;
&lt;li&gt;&lt;p&gt;辅助索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B树(B+树)索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;R树索引：空间索引&lt;/li&gt;
&lt;li&gt;hash索引&lt;/li&gt;
&lt;li&gt;全文索引：全文搜索，比如在某帖子里搜索内容。&lt;/li&gt;
&lt;li&gt;位图索引：oracle支持，mysql不支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何选择？&quot;&gt;&lt;a href=&quot;#如何选择？&quot; class=&quot;headerlink&quot; title=&quot;如何选择？&quot;&gt;&lt;/a&gt;如何选择？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;是否需要事务&lt;/li&gt;
&lt;li&gt;备份的类型的支持&lt;/li&gt;
&lt;li&gt;崩溃后的恢复&lt;/li&gt;
&lt;li&gt;特有的特性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般我们建议默认采用InnoDB，除非你是建立数据仓库时，我们建议使用MyISAM。MySQL5.5.8之前默认的存储引擎是MyISAM，而后其他版本默认是是InnoDB。&lt;br&gt;如果多个存储引擎满足你的需求，做测试，做性能剖析。&lt;/p&gt;
&lt;p&gt;优化没有任何放之四海而皆准的办法，你需要建立对对方良好的精确理解的基础上，并根据自己的需求去做选择。所以不要从网上搜一些文章朝自己的服务器咣当设置，就以为对服务器做优化了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL存储引擎&quot;&gt;&lt;a href=&quot;#MySQL存储引擎&quot; class=&quot;headerlink&quot; title=&quot;MySQL存储引擎&quot;&gt;&lt;/a&gt;MySQL存储引擎&lt;/h2&gt;&lt;p&gt;存储引擎也通常称作“表类型”。可以在创建表时指定其存储引擎。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务及隔离级别</title>
    <link href="http://yoursite.com/2018/04/05/MySQL%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2018/04/05/MySQL事务及隔离级别/</id>
    <published>2018-04-05T01:17:31.000Z</published>
    <updated>2018-04-08T08:35:32.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#MySQL逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL逻辑架构&quot;&gt;&lt;/a&gt;MySQL逻辑架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/63.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;我们可以把mysql的架构分为3层：&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.第一层：连接池或称为线程处理工具。处理用户的连接建立。&lt;/strong&gt;&lt;br&gt;        mysql现在对于线程管理是通过线程池来实现的。一个池子中所能够容纳的水量是有限的，所以一个线程池中所能够容纳的线程数也是有限的。所以mysql启动时事先创建好一个线程池，在这个池子内假如创建了100个空闲线程，来一个用户连接，给它一个线程，当用户连接达到100个，新连接就要排队等待，后面维持一个队列。当某个连接上的用户请求退出后，其对应的线程不会销毁，只会清理数据，还原成原来的样子，再去处理新的用户请求。&lt;br&gt;        所以用户的连接线程在线程池的管理模式中是不会被销毁的，一般是能够实现重用的。所以就避免了频繁的线程创建和删除。&lt;br&gt;        mysql客户端和服务器端通信要通过mysql协议进行通信，协议一般来讲有两种格式。http协议是文本的，我们可以通过telnet连进去手动发送命令的，https协议是二进制的。mysql协议这两种格式都支持。哪种协议会比较高效？二进制的会略微高效一点，所以很多支持两种协议的默认都使用二进制格式。无论是二进制还是文本，都是明文的，只不过你编码成了二进制格式而已，我们只需要一个解码工具，就能把二进制转换为原来的样子了。&lt;br&gt;        为了安全，加密。mysql支持将它的协议基于ssl进行发送的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.第二层：mysql核心服务层。是MySQL的核心功能层。&lt;/strong&gt;包括查询解析、分析、优化、缓存以及mysql的所有内置函数(BIF)等。&lt;br&gt;        Parser：解析器，也叫分析器。主要功能是分析查询语句的。首先要做词法分析，要把整个sql语句切割成一个一个的片段，还要做语法分析，看看整个sql语句中有没有语法错误，甚至于还要做语义分析。这些都是由分析器完成。当然，mysql并没有自己开发分析器，有很多著名的开源分析器，yacc和lex，一个做词法分析，一个做语法分析的。mysql借用了这分析器做了二次开发并整合进mysql使用了。&lt;br&gt;        Optimizer：优化器。包括重写查询、决定表的读取顺序(多表查询时调整表的读取顺序)、多表查询时选择一个开销最小的索引。但是我们在查询时，如果你作为用户知道哪个索引更好用，你也可以向mysql发送语句时给它提示以影响mysql决策的。对于mysql来讲，优化器并不关心底层那个表真正使用的存储引擎是什么，但是存储引擎根据其特性的不同所提供的性能表现也不同。但是优化器又不考虑存储引擎，但好在优化器会通过向存储引擎的API发起调用请求让存储引擎返回这种存储引擎下所对应的表的统计数据来判断这个表的查询开销有多大，并基于此做出优化决策。一直在说查询，INSERT和UPDATE都要查询的，我们这里讲的查询是广义上的查询，不仅仅是SELECT。不过，如果你真正执行的是SELECT，mysql还有个内部的工具对这种查询可以发挥效用以提升性能的，就是图中的Query Cache。&lt;br&gt;        Query Cache只对SELECT语句有效。只有SELECT才会被缓存下来。所以如果我们执行的是SELECT语句，服务器每次在解析查询操作之前会去查看缓存中是否命中。所以这对SELECT操作是额外的开销，但是如果命中率足够可靠的话，Query Cache还是很有必要的。怎么查看查询缓存的命中率多高？后面讲到mysql优化时，会讲怎么根据缓存的统计数据来分析命中率的。在命中率的基础上决定到底是否开启缓存。你可以把缓存工作在某种特定模式下，默认mysql都不缓存。只有我们手动明确要缓存语句才缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.第三层：存储引擎。&lt;/strong&gt;存储引擎的主要工作是真正负责数据的存储和提取的。&lt;/p&gt;
&lt;h2 id=&quot;MySQL锁&quot;&gt;&lt;a href=&quot;#MySQL锁&quot; class=&quot;headerlink&quot; title=&quot;MySQL锁&quot;&gt;&lt;/a&gt;MySQL锁&lt;/h2&gt;&lt;p&gt;MySQL允许多用户同时连接进来，如果多个用户在访问同一张表的时候，会发生什么问题？比如A用户连接进来修改表A，第二个用户B这时想查询表A中数据能否进行查询？不能查询，怎么达到这个目的呢？你得让B用户的查询操作知道表A正在被某一用户施加写操作。这需要MySQL内在的某些机制完成并发访问控制，而并发访问控制通常基于锁来实现。对于读操作来说，多个用户同时读是没问题的，但是对于写操作是不行的。&lt;/p&gt;
&lt;h3 id=&quot;MySQL锁-1&quot;&gt;&lt;a href=&quot;#MySQL锁-1&quot; class=&quot;headerlink&quot; title=&quot;MySQL锁&quot;&gt;&lt;/a&gt;MySQL锁&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.按执行操作时施加的锁模式来分类：两种类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读锁：又称为共享锁，可以同时读，但是不可以写。读为什么要加锁，因为防止其他人去修改我们正在查询的数据的。&lt;/li&gt;
&lt;li&gt;写锁：独占锁，排它锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.按锁粒度划分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表锁：table lock。锁定了整张表。开销最小。&lt;/li&gt;
&lt;li&gt;行锁：row lock。锁定了需要的行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;粒度越小，开销越大，但并发性越好；&lt;br&gt;粒度越大，开销越小，但并发性越差；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3.按锁的实现位置划分：&lt;ul&gt;
&lt;li&gt;MySQL锁：可以使用显式锁。很多时候我们提到MySQL，是指第二层核心服务层。&lt;/li&gt;
&lt;li&gt;存储引擎锁：自动进行的（隐式锁）。大多数查询操作都会自动由存储引擎施加锁的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何实现显式锁-在服务器级别显式锁只能是表级锁&quot;&gt;&lt;a href=&quot;#如何实现显式锁-在服务器级别显式锁只能是表级锁&quot; class=&quot;headerlink&quot; title=&quot;如何实现显式锁(在服务器级别显式锁只能是表级锁)&quot;&gt;&lt;/a&gt;如何实现显式锁(在服务器级别显式锁只能是表级锁)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;LOCK TABLES
UNLOCK TABLES  #只能一次释放所有表的锁，不能指定表和锁类型。见下面的截图语法。

LOCK TABLES
    tbl_name lock_type
    [, tbl_name lock_type] ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;锁类型：READ|WRITE&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【示例1】:演示读锁。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; use hellodb
Database changed
mysql&amp;gt; LOCK TABLES classes READ;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动另一个终端，连接进来：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/64.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在第一个终端上，释放锁：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; UNLOCK TABLES;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后到第二个窗口，会发现数据已经插入成功了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;InnoDB存储引擎也支持另外一种显式锁(锁定挑选出的部分行，行级锁 )：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT ... LOCK IN SHARE MODE;   共享锁
SELECT ... FOR UPDATE;   排它锁
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【示例2】:演示InnoDB行级锁。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/65.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;【注意】:&lt;/strong&gt;&lt;br&gt;1.只是在语句执行过程中添加了锁，语句执行结束了锁就释放了。因此就没有UNLOCK了。&lt;br&gt;2.除了特性情况下，做备份操作时，不建议手动施加锁，因为存储引擎会自动进行锁操作，而且它的锁操作性能比我们自己施加要好的多。做备份操作时，要手动添加读锁。&lt;/p&gt;
&lt;h2 id=&quot;事务Transaction&quot;&gt;&lt;a href=&quot;#事务Transaction&quot; class=&quot;headerlink&quot; title=&quot;事务Transaction&quot;&gt;&lt;/a&gt;事务Transaction&lt;/h2&gt;&lt;p&gt;基于锁我们实现了一定意义上的并发功能了，但是一般来讲，为了完成更高级别的操作，需要支持事务。&lt;br&gt;事务就是一组原子性的查询语句，也即将多个查询当作一个独立的工作单元。&lt;br&gt;【注意】:MyISAM存储引擎是不支持事务的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACID测试：能满足ACID测试就表示其支持事务，或兼容事务。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A：Atomicity，原子性。&lt;/li&gt;
&lt;li&gt;C：Consistency, 一致性。我们的数据库总是从一个一致性状态转到另一个一致性状态。比如，Tom从自己的账户(7000)转账3000到Jerry账户(5000)上， 这样Tom就只剩4000，Jerry就有了8000。转账前二者总和是12000，转账后还是12000。&lt;/li&gt;
&lt;li&gt;I: Isolation, 隔离性, 一个事务的所有修改操作在提交之前所有的修改对其它事务是不可见的。&lt;ul&gt;
&lt;li&gt;第一步：Tom: 7000-3000。事务没提交之前，有人查询Jerry账户，是不能看到这多3000的。同样查询Tom账户，也不能看到少了3000。因为我们事务还没提交&lt;/li&gt;
&lt;li&gt;第二步：Jerry: 5000+3000&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D：Durability, 持久性, 一旦事务得到提交，其所做的修改会永久有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，ACID机制需要背后有强大的机制才能实现的，而且一旦让一个存储引擎或关系型数据库支持事务，那么它在复杂程度上面是成几何倍上升的。并且如果事务做的完全隔离，事务就是串行的了。如果做到完全隔离，只有在两个事务压根不会涉及到同一张表的时候才会同时执行，否则只要涉及到同一个数据集，事务都只能以串行方式进行。数据安全性越高，其并发性就越低。所以就有了隔离级别的概念。&lt;/p&gt;
&lt;h3 id=&quot;隔离级别&quot;&gt;&lt;a href=&quot;#隔离级别&quot; class=&quot;headerlink&quot; title=&quot;隔离级别&quot;&gt;&lt;/a&gt;隔离级别&lt;/h3&gt;&lt;p&gt;隔离级别(4个)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;READ UNCOMMITTED (读未提交)&lt;br&gt;读别人还没提交的数据，这属于没什么隔离性的。数据安全性最差，但并发性最好(但从实际上来看，不会比其他级别好太多。又极其缺乏安全性，所以很少用。)&lt;br&gt;会产生脏读，不可重读，幻读(看到的数据和背后的数据不一样)&lt;/li&gt;
&lt;li&gt;READ COMMITTED (读提交)&lt;br&gt;只有别人提交了，我们才能看到。市面上常见的大多数关系型数据库隔离级别都是读提交，不过mysql不是。mysql是第3个隔离级别，可重读。&lt;br&gt;不可重读，幻读&lt;/li&gt;
&lt;li&gt;REPEATABLE READ (可重读)&lt;br&gt;解决了脏读问题，而且可重读，但是解决不了幻读问题。&lt;/li&gt;
&lt;li&gt;SERIALIZABLE (串行化)&lt;br&gt;强制事务的串行执行避免了幻读。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跟事务相关的命令：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; HELP CONTENTS;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;You asked for help about help category: &amp;quot;Contents&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;For more information, type &amp;apos;help &amp;lt;item&amp;gt;&amp;apos;, where &amp;lt;item&amp;gt; is one of the following&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;categories:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Account Management&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Administration&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Compound Statements&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Data Definition&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Data Manipulation&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Data Types&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Functions&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Functions and Modifiers for Use with GROUP BY&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Geographic Features&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Help Metadata&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Language Structure&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Plugins&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Procedures&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Storage Engines&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Table Maintenance&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Transactions&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   User-Defined Functions&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Utility&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; HELP Transactions;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;You asked for help about help category: &amp;quot;Transactions&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;For more information, type &amp;apos;help &amp;lt;item&amp;gt;&amp;apos;, where &amp;lt;item&amp;gt; is one of the following&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;topics:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   CHANGE MASTER TO&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   DEALLOCATE PREPARE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   EXECUTE STATEMENT&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ISOLATION&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   LOCK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   PREPARE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   PURGE BINARY LOGS&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   RESET MASTER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   RESET SLAVE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   SAVEPOINT&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   SET GLOBAL SQL_SLAVE_SKIP_COUNTER&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   SET SQL_LOG_BIN&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   START SLAVE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   START TRANSACTION&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   STOP SLAVE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   XA&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; HELP COMMIT&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Many help items for your request exist.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;To make a more specific request, please type &amp;apos;help &amp;lt;item&amp;gt;&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;where &amp;lt;item&amp;gt; is one of the following&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;topics:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   START TRANSACTION&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   XA&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; HELP ROLLBACK&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Many help items for your request exist.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;To make a more specific request, please type &amp;apos;help &amp;lt;item&amp;gt;&amp;apos;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;where &amp;lt;item&amp;gt; is one of the following&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;topics:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   SAVEPOINT&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   START TRANSACTION&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   XA&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mysql&amp;gt; HELP SAVEPOINT&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Name: &amp;apos;SAVEPOINT&amp;apos;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Description:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Syntax:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;SAVEPOINT identifier&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ROLLBACK [WORK] TO [SAVEPOINT] identifier&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RELEASE SAVEPOINT identifier&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;InnoDB supports the SQL statements SAVEPOINT, ROLLBACK TO SAVEPOINT,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RELEASE SAVEPOINT and the optional WORK keyword for ROLLBACK.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;URL: http://dev.mysql.com/doc/refman/5.6/en/savepoint.html&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;解释下常用的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; START TRANSACTION  手动显式启动一个事务。在这个事务中执行的所有语句在你执行下一条语句之前都处于未提交状态，未提交的事务都可以进行回滚。
mysql&amp;gt; COMMIT
mysql&amp;gt; ROLLBACK   回滚。回滚时有个问题，如果我们的事务非常大，假如有60个语句，我们执行到第40个的时候，发现第38个错了，如果能够回滚到第35个会比回滚到开头好多了，这就需要SAVEPOINT。我们可以在事务中设置多个保存点，给保存点设置个名字。

mysql&amp;gt; SAVEPOINT identifier
mysql&amp;gt; ROLLBACK [WORK] TO [SAVEPOINT] identifier
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;示例1：演示事务回滚&quot;&gt;&lt;a href=&quot;#示例1：演示事务回滚&quot; class=&quot;headerlink&quot; title=&quot;示例1：演示事务回滚&quot;&gt;&lt;/a&gt;示例1：演示事务回滚&lt;/h3&gt;&lt;p&gt;【注意】:MySQL数据库默认启动了自动提交的功能，也就意味着哪怕你手动不提交，也会自动提交的。但是当我们显式启动事务时，MySQL就不会自动帮我们提交。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/66.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/67.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;示例2：演示SAVEPOINT&quot;&gt;&lt;a href=&quot;#示例2：演示SAVEPOINT&quot; class=&quot;headerlink&quot; title=&quot;示例2：演示SAVEPOINT&quot;&gt;&lt;/a&gt;示例2：演示SAVEPOINT&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/68.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果没有显式启动事务，每个语句都会当作一个独立的事务，其执行完成后会被自动提交。自动提交会带来性能上的很大影响，因为每一个语句都自动提交，都会产生一个I/O。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW GLOBAL VARIABLES LIKE &amp;apos;%commit%&amp;apos;;
+--------------------------------+-------+
| Variable_name                  | Value |
+--------------------------------+-------+
| autocommit                     | ON    |
| binlog_order_commits           | ON    |
| innodb_api_bk_commit_interval  | 5     |
| innodb_commit_concurrency      | 0     |
| innodb_flush_log_at_trx_commit | 1     |
+--------------------------------+-------+
5 rows in set (0.00 sec)

mysql&amp;gt; SELECT @@global.autocommit;
+---------------------+
| @@global.autocommit |
+---------------------+
|                   1 |
+---------------------+
1 row in set (0.00 sec)

mysql&amp;gt; SET GLOBAL autocommit = 0;  注意这么改对当前会话没有影响，因为我改的是全局的。
如果关闭自动提交，请记得手动启动事务，手动进行提交；
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;事务隔离级别演示&quot;&gt;&lt;a href=&quot;#事务隔离级别演示&quot; class=&quot;headerlink&quot; title=&quot;事务隔离级别演示&quot;&gt;&lt;/a&gt;事务隔离级别演示&lt;/h3&gt;&lt;p&gt;MySQL默认的事务隔离级别是可重复读。查看MySQL的事务隔离级别：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW GLOBAL VARIABLES LIKE &amp;apos;%iso%&amp;apos;;
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
1 row in set (0.00 sec)

mysql&amp;gt; SHOW GLOBAL VARIABLES LIKE &amp;apos;tx_isolation&amp;apos;;
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| tx_isolation  | REPEATABLE-READ |
+---------------+-----------------+
1 row in set (0.00 sec)

mysql&amp;gt; SELECT @@global.tx_isolation;  
+-----------------------+
| @@global.tx_isolation |
+-----------------------+
| REPEATABLE-READ       |
+-----------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;示例3-演示”读未提交”&quot;&gt;&lt;a href=&quot;#示例3-演示”读未提交”&quot; class=&quot;headerlink&quot; title=&quot;示例3:演示”读未提交”&quot;&gt;&lt;/a&gt;示例3:演示”读未提交”&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SET GLOBAL tx_isolation=&amp;apos;READ-UNCOMMITTED&amp;apos;;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; SHOW GLOBAL VARIABLES LIKE &amp;apos;%iso%&amp;apos;;
+---------------+------------------+
| Variable_name | Value            |
+---------------+------------------+
| tx_isolation  | READ-UNCOMMITTED |
+---------------+------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新打开两个shell，连接进mysql：注意进去后两个shell要各自先启动事务。然后在到第一个会话执行操作。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/69.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在打开一个shell，连接进mysql：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/70.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;下面第一个会话回滚事务：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; ROLLBACK;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到第2个会话中，再次查询：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/71.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;第2个会话回滚事务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; ROLLBACK;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;示例4-演示”读提交”&quot;&gt;&lt;a href=&quot;#示例4-演示”读提交”&quot; class=&quot;headerlink&quot; title=&quot;示例4:演示”读提交”&quot;&gt;&lt;/a&gt;示例4:演示”读提交”&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SET GLOBAL tx_isolation=&amp;apos;READ-COMMITTED&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新打开两个shell，连接进mysql：注意进去后两个shell要各自先启动事务。然后在到第一个会话执行操作。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/72.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/73.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;此时如果第一个会话中的事务回滚了，那么第二个会话看到的还是第3个数据是有的，这是很正确的；&lt;br&gt;但是如果第一个会话中的事务提交了，&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/74.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/75.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;同一个事务中多次读取的结果不一样，这就是不可重复读。所以脏读了就一定不可重复读，因为你每一次都能读到别人直接修改的数据。所以”读提交”在同一个事务中多次读取仍然可能是不一样的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;示例3-演示”可重读”&quot;&gt;&lt;a href=&quot;#示例3-演示”可重读”&quot; class=&quot;headerlink&quot; title=&quot;示例3:演示”可重读”&quot;&gt;&lt;/a&gt;示例3:演示”可重读”&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SET GLOBAL tx_isolation=&amp;apos;REPEATABLE-READ&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新打开两个shell，连接进mysql：注意进去后两个shell要各自先启动事务。然后在到第一个会话执行操作。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/76.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/77.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;但是如果第一个会话中的事务提交了，&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/78.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/79.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;虽然”可重读”解决了不可重读的问题，但是仍然没有解决幻读的问题。&lt;/p&gt;
&lt;h4 id=&quot;示例4-演示”串行化”&quot;&gt;&lt;a href=&quot;#示例4-演示”串行化”&quot; class=&quot;headerlink&quot; title=&quot;示例4:演示”串行化”&quot;&gt;&lt;/a&gt;示例4:演示”串行化”&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SET GLOBAL tx_isolation=&amp;apos;serializable&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新打开两个shell，连接进mysql：注意进去后两个shell要各自先启动事务。然后在到第一个会话执行操作。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/80.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/81.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;只能等对方提交或者回滚，你才能查看结果。串行化解决了幻读的问题，但是性能太差了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【建议】：对事务要求不特别严格的场景下，可以使用读提交。要想让配置永久生效，要改配置文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事实上mysql是怎么实现的？为什么别人提交了，对可重读来讲，还不能看到数据。这就是MVCC机制。&lt;br&gt;&lt;strong&gt;MVCC：多版本并发控制&lt;/strong&gt;&lt;br&gt;对于可重读等机制来讲，每个事务启动时，InnoDB为会每个启动的事务提供一个当下时刻的快照，后续的所有操作都是在快照的基础上执行的。因此不管事务执行多长时间，在同一个事务中看到的数据是一致的。&lt;br&gt;为了实现此功能，InnoDB会为每个表提供两隐藏的字段，一个用于保存行的创建时间，一个用于保存行的失效时间(就是哪个事务删除过)。&lt;br&gt;实际上里面存的不是时间，里面存储的是系统版本号；（system version number）。每启动一个事务，InnoDB存储引擎就会给这个事务创建一个当下时刻的快照，并且为对应所读取的数据的快照启动一个新版本号，+1。&lt;/p&gt;
&lt;p&gt;MVCC只在两个隔离级别下有效：READ COMMITTED和REPEATABLE READ。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#MySQL逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL逻辑架构&quot;&gt;&lt;/a&gt;MySQL逻辑架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/63.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;我们可以把mysql的架构分为3层：
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL DML</title>
    <link href="http://yoursite.com/2018/04/02/MySQL-DML/"/>
    <id>http://yoursite.com/2018/04/02/MySQL-DML/</id>
    <published>2018-04-02T10:25:25.000Z</published>
    <updated>2018-04-03T07:23:05.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;DML&quot;&gt;&lt;a href=&quot;#DML&quot; class=&quot;headerlink&quot; title=&quot;DML&quot;&gt;&lt;/a&gt;DML&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;DDL&lt;ul&gt;
&lt;li&gt;DATABASE&lt;/li&gt;
&lt;li&gt;TABLE&lt;/li&gt;
&lt;li&gt;VIEW&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DML&lt;ul&gt;
&lt;li&gt;SELECT&lt;/li&gt;
&lt;li&gt;INSERT/REPLACE&lt;/li&gt;
&lt;li&gt;UPDATE&lt;/li&gt;
&lt;li&gt;DELETE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;INSERT-REPLACE&quot;&gt;&lt;a href=&quot;#INSERT-REPLACE&quot; class=&quot;headerlink&quot; title=&quot;INSERT/REPLACE&quot;&gt;&lt;/a&gt;INSERT/REPLACE&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/62.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;INSERT INTO:(INTO可以省略)&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;第一种：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO tb_name [(col1, col2,...)] {VALUES|VALUE} (val1, val2,...)[,(val21,val22,...),...]      
    ——VALUE插入单行数据，VALUES插入多行数据。二者取其一，必选的。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第二种：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO tb_name SET col1=val1, col2=val2, ...
    ——大多数情况下用于插入一行数据。有点类似于UPDATE。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;第三种：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;INSERT INTO tb_name SELECT clause
    ——查询的结果要和插入的表的字段类型、字段个数保持一致。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;REPLACE的工作机制：&lt;/strong&gt;与INSERT相同，除了在新插入的数据与表中的主键数据相同或与惟一索引定义的数据相同会替换老的行。&lt;br&gt;也是和INSERT一样3种使用方式。&lt;/p&gt;
&lt;h3 id=&quot;UPDATE&quot;&gt;&lt;a href=&quot;#UPDATE&quot; class=&quot;headerlink&quot; title=&quot;UPDATE&quot;&gt;&lt;/a&gt;UPDATE&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;UPDATE [LOW_PRIORITY] [IGNORE] table_reference
    SET col_name1=val1 [, col_name2=val2] ...
    [WHERE where_condition]
    [ORDER BY ...]
    [LIMIT row_count]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;UPDATE通常情况下，必须要使用WHERE子句，或者使用LIMIT限制要修改的行数；否则就每行都修改了，不安全。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--safe-updates     
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动mysqld还有这个选项，可用于限定如果你的DELETE语句忘记了带WHERE子句或LIMIT子句时是拒绝执行的。这个选项还包括对DELETE语句的限制。建议启动时使用–safe-updates。&lt;/p&gt;
&lt;h3 id=&quot;DELETE&quot;&gt;&lt;a href=&quot;#DELETE&quot; class=&quot;headerlink&quot; title=&quot;DELETE&quot;&gt;&lt;/a&gt;DELETE&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name
    [WHERE where_condition]
    [ORDER BY ...]
    [LIMIT row_count]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果对删除哪些行不做限定的话，非常危险。是删除行，不是删字段。不指定条件，就是清空表数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TRUNCATE tb_name
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们的目的是清空整张表的话，delete有个问题：如果这个表中有自动增长的字段，它那个自动增长的数值不会重置为1。我们需要使用TRUNCATE，不要使用delete。所以如果我们是想清空某张表的话，请使用TRUNCATE。&lt;br&gt;事实上我们还建议，复制表结构，然后把原来的表删除掉，即DROP。创建表结构，在插入原表数据。&lt;/p&gt;
&lt;p&gt;以上的SELECT、INSERT、UPDATE和DELETE在NoSQL中被称为crud。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DML&quot;&gt;&lt;a href=&quot;#DML&quot; class=&quot;headerlink&quot; title=&quot;DML&quot;&gt;&lt;/a&gt;DML&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;DDL&lt;ul&gt;
&lt;li&gt;DATABASE&lt;/li&gt;
&lt;li&gt;TABLE&lt;/li&gt;
&lt;li&gt;VIEW
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询和视图</title>
    <link href="http://yoursite.com/2018/03/29/MySQL%E6%9F%A5%E8%AF%A2%E5%92%8C%E8%A7%86%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/03/29/MySQL查询和视图/</id>
    <published>2018-03-29T01:20:40.000Z</published>
    <updated>2018-04-03T06:23:16.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;查询的执行路径&quot;&gt;&lt;a href=&quot;#查询的执行路径&quot; class=&quot;headerlink&quot; title=&quot;查询的执行路径&quot;&gt;&lt;/a&gt;查询的执行路径&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;查询执行路径：&lt;/strong&gt;先查缓存，缓存未命中交给解析器。MySQL是允许多个用户连接进来的，因此有多个线程，如果每个线程上的用户都发起查询请求，而mysql真正能够执行查询的查询引擎只有一个，所以要排队，要给一个队列。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;所以就需要有查询执行计划和查询执行引擎。但是查询执行引擎不能直接去硬盘取数据，所以查询引擎是接收查询执行计划传递而来的优化器优化后的查询语句，它负责转换为对应表的存储引擎的API调用。后面的数据获取是由对应的存储引擎负责到磁盘上取数据，并将数据返回给执行引擎，最后在层层返回给客户端，返回客户端之前有可能要判断要不要缓存下来。比如查当前系统时间，这个就没必要缓存下来了。查询的结果缓存与否，用户是可以定义的。当然不是说用户想缓存就一定能缓存。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/25.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;MySQL的查询操作&quot;&gt;&lt;a href=&quot;#MySQL的查询操作&quot; class=&quot;headerlink&quot; title=&quot;MySQL的查询操作&quot;&gt;&lt;/a&gt;MySQL的查询操作&lt;/h2&gt;&lt;p&gt;使用SELECT语句查询数据，查询语句的通用语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT values_to_dispaly
FROM table_name 
WHERE expression
GROUP BY how_to_group
HAVING expression
ORDER BY how_to_sort
LIMIT row_count;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询又可分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单表查询：也称为简单查询&lt;/li&gt;
&lt;li&gt;多表查询：也称为连接查询&lt;/li&gt;
&lt;li&gt;联合查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择和投影：就是关系代数，其实SELECT主要就包括这两方面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;投影：挑选要显示的字段&lt;/li&gt;
&lt;li&gt;选择：挑选符合条件的行&lt;ul&gt;
&lt;li&gt;投影：SELECT 字段1, 字段2, … FROM tb_name; &lt;ul&gt;
&lt;li&gt;SELECT * FROM tb_name;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选择：SELECT 字段1, … FROM tb_name WHERE 子句; &lt;ul&gt;
&lt;li&gt;WHERE 子句就是布尔条件表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;WHERE子句&quot;&gt;&lt;a href=&quot;#WHERE子句&quot; class=&quot;headerlink&quot; title=&quot;WHERE子句&quot;&gt;&lt;/a&gt;WHERE子句&lt;/h3&gt;&lt;p&gt;HERE 子句就是布尔条件表达式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;布尔条件表达式操作符： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;=&lt;/li&gt;
&lt;li&gt;&amp;lt;=&amp;gt; ：空值安全比较。与空比较值的安全方式，跟空值比较不会产生意外情况的等值比较。和上面那个一样都是等值比较。&lt;/li&gt;
&lt;li&gt;&amp;lt;&amp;gt; ：不等于&lt;/li&gt;
&lt;li&gt;&amp;lt;&lt;/li&gt;
&lt;li&gt;&amp;lt;=&lt;/li&gt;
&lt;li&gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;blockquote&gt;
&lt;p&gt;=&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IS NULL ：判断一个字段的值是否为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IS NOT NULL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LIKE: 支持的通配符: %(任意长度的任意字符)， _（任意单个字符） 。&lt;br&gt;【注意】:能用等值比较或不等值比较，就尽量不要用LIKE。因为它的性能要差得多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RLIKE(REGEXP): 支持使用正则表达式 。&lt;br&gt;【注意】:性能比较低。LIKE和RLIKE是用来做字符串比较的，千万不要拿来做数值比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IN: 判断指定字段的值是否在给定在列表中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BETWEEN … AND …: 位于指定的范围之间 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【示例1】：NULL示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; CREATE TABLE `students` (`SID` int(100), `Name` varchar(50) NOT NULL, `Age` TINYINT UNSIGNED NOT NULL, `Gender` ENUM(&amp;apos;M&amp;apos;,&amp;apos;F&amp;apos;) NOT NULL DEFAULT &amp;apos;M&amp;apos;, `Tutor` varchar(50), PRIMARY KEY(`SID`));
Query OK, 0 rows affected (0.04 sec)

mysql&amp;gt; INSERT INTO `students` VALUES (1,&amp;apos;tom&amp;apos;,13,&amp;apos;M&amp;apos;,&amp;apos;Song Jiang&amp;apos;);
Query OK, 1 row affected (0.00 sec)

mysql&amp;gt; INSERT INTO `students` VALUES (2,&amp;apos;jerry&amp;apos;,14,&amp;apos;F&amp;apos;,&amp;apos;Jiabaoyu&amp;apos;); 
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; INSERT INTO `students` VALUES (3,&amp;apos;jack&amp;apos;,14,&amp;apos;M&amp;apos;,&amp;apos;JinJiao&amp;apos;);
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; INSERT INTO `students` VALUES (4,&amp;apos;Lucy&amp;apos;,14,&amp;apos;F&amp;apos;,NULL);
Query OK, 1 row affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【示例2】：LIKE示例&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/27.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【示例3】：RLIKE示例&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/28.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【示例4】：IN示例&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/29.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【示例5】：BETWEEN … AND示例&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/30.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;组合条件测试： 逻辑操作符组合多个条件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NOT, 可以用 ! 表示。&lt;/li&gt;
&lt;li&gt;AND, 可以用&amp;amp;&amp;amp;表示&lt;/li&gt;
&lt;li&gt;OR, 可以用 || 表示&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;聚合函数&quot;&gt;&lt;a href=&quot;#聚合函数&quot; class=&quot;headerlink&quot; title=&quot;聚合函数&quot;&gt;&lt;/a&gt;聚合函数&lt;/h3&gt;&lt;p&gt;聚合函数是mysql内置的。&lt;br&gt;&lt;strong&gt;SUM(), AVG(), MAX(), MIN(), COUNT()&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/31.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/32.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;分组&quot;&gt;&lt;a href=&quot;#分组&quot; class=&quot;headerlink&quot; title=&quot;分组&quot;&gt;&lt;/a&gt;分组&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;GROUP BY&lt;/strong&gt;。在聚合函数使用时，往往伴随着分组的使用，然后对一组进行聚合。分组的目的主要是来用聚合。我们可以在GROUP BY之前使用WHERE子句做条件过滤。具体前面写的通用查询格式。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/33.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;HAVING子句&quot;&gt;&lt;a href=&quot;#HAVING子句&quot; class=&quot;headerlink&quot; title=&quot;HAVING子句&quot;&gt;&lt;/a&gt;HAVING子句&lt;/h3&gt;&lt;p&gt;对GROUP BY、聚合函数查出的结果做条件过滤用HAVING子句。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; ALTER TABLE students ADD column `ClassID` int(10);
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&amp;gt; UPDATE students SET ClassID=1 WHERE Name=&amp;apos;Tom&amp;apos;;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&amp;gt; UPDATE students SET ClassID=1 WHERE Name=&amp;apos;Jerry&amp;apos;;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&amp;gt; UPDATE students SET ClassID=1 WHERE Name=&amp;apos;Jack&amp;apos;;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&amp;gt; UPDATE students SET ClassID=2 WHERE Name=&amp;apos;Lucy&amp;apos;;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/34.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;ORDER BY。&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/35.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;LIMIT&quot;&gt;&lt;a href=&quot;#LIMIT&quot; class=&quot;headerlink&quot; title=&quot;LIMIT&quot;&gt;&lt;/a&gt;LIMIT&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;【注意】:有的时候为了简单的判断工作，我们只需要查询结果返回一部分结果，这时候可以使用LIMIT子句。&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/36.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结SELECT几种惯常用法&quot;&gt;&lt;a href=&quot;#总结SELECT几种惯常用法&quot; class=&quot;headerlink&quot; title=&quot;总结SELECT几种惯常用法&quot;&gt;&lt;/a&gt;总结SELECT几种惯常用法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;SELECT ...
FROM ...
ORDER BY ...

SELECT ...
FROM ...
GROUP BY ...
HAVING ...

SELECT ...
FROM ...
WHERE ...

SELECT ...

SELECT ...
FROM ...
WHERE ...
GROUP BY ...
LIMIT ...

SELECT ...
FROM ...
HAVING ...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;SELECT语句的执行流程&quot;&gt;&lt;a href=&quot;#SELECT语句的执行流程&quot; class=&quot;headerlink&quot; title=&quot;SELECT语句的执行流程&quot;&gt;&lt;/a&gt;SELECT语句的执行流程&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;FROM clause --&amp;gt; WHERE clause --&amp;gt; GROUP BY --&amp;gt; HAVING clause --&amp;gt; ORDER BY ... --&amp;gt; SELECT --&amp;gt; LIMIT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;【注意】:where子句不能使用聚合函数&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/37.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;【补充】：SELECT语句:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DISTINCT：指定的结果相同的只显示一次；&lt;/li&gt;
&lt;li&gt;SQL_CACHE：缓存于查询缓存中；&lt;/li&gt;
&lt;li&gt;SQL_NO_CACHE：不缓存查询结果。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/38.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;多表查询&quot;&gt;&lt;a href=&quot;#多表查询&quot; class=&quot;headerlink&quot; title=&quot;多表查询&quot;&gt;&lt;/a&gt;多表查询&lt;/h2&gt;&lt;p&gt;联结查询：事先将两张或多张表join，根据join的结果进行查询。&lt;br&gt;为什么会有多表查询？数据库设计要求降低冗余。如果一个数据我们来回存了n次，就建议拆分成两张表，并且在两张表中都有的字段建立关联关系。&lt;/p&gt;
&lt;p&gt;下面先初始化数据，导入一个sql脚本，用于举例子。脚本内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE DATABASE /*!32312 IF NOT EXISTS*/ `test` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `test`;

--
-- Table structure for table `classes`
--

DROP TABLE IF EXISTS `classes`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `classes` (
  `ClassID` tinyint(3) unsigned NOT NULL AUTO_INCREMENT,
  `Class` varchar(100) DEFAULT NULL,
  `NumOfStu` smallint(5) unsigned DEFAULT NULL,
  PRIMARY KEY (`ClassID`)
) ENGINE=MyISAM AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `classes`
--

LOCK TABLES `classes` WRITE;
/*!40000 ALTER TABLE `classes` DISABLE KEYS */;
INSERT INTO `classes` VALUES (1,&amp;apos;Shaolin Pai&amp;apos;,10),(2,&amp;apos;Emei Pai&amp;apos;,7),(3,&amp;apos;QingCheng Pai&amp;apos;,11),(4,&amp;apos;Wudang Pai&amp;apos;,12),(5,&amp;apos;Riyue Shenjiao&amp;apos;,31),(6,&amp;apos;Lianshan Pai&amp;apos;,27),(7,&amp;apos;Ming Jiao&amp;apos;,27),(8,&amp;apos;Xiaoyao Pai&amp;apos;,15);
/*!40000 ALTER TABLE `classes` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `coc`
--

DROP TABLE IF EXISTS `coc`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `coc` (
  `ID` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `ClassID` tinyint(3) unsigned NOT NULL,
  `CourseID` smallint(5) unsigned DEFAULT NULL,
  PRIMARY KEY (`ID`)
) ENGINE=MyISAM AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `coc`
--

LOCK TABLES `coc` WRITE;
/*!40000 ALTER TABLE `coc` DISABLE KEYS */;
INSERT INTO `coc` VALUES (1,1,2),(2,1,5),(3,2,2),(4,2,6),(5,3,1),(6,3,7),(7,4,5),(8,4,2),(9,5,1),(10,5,9),(11,6,3),(12,6,4),(13,7,4),(14,7,3);
/*!40000 ALTER TABLE `coc` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `courses`
--

DROP TABLE IF EXISTS `courses`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `courses` (
  `CourseID` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `Course` varchar(100) NOT NULL,
  PRIMARY KEY (`CourseID`)
) ENGINE=MyISAM AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `courses`
--

LOCK TABLES `courses` WRITE;
/*!40000 ALTER TABLE `courses` DISABLE KEYS */;
INSERT INTO `courses` VALUES (1,&amp;apos;Hamo Gong&amp;apos;),(2,&amp;apos;Kuihua Baodian&amp;apos;),(3,&amp;apos;Jinshe Jianfa&amp;apos;),(4,&amp;apos;Taiji Quan&amp;apos;),(5,&amp;apos;Daiyu Zanghua&amp;apos;),(6,&amp;apos;Weituo Zhang&amp;apos;),(7,&amp;apos;Dagou Bangfa&amp;apos;);
/*!40000 ALTER TABLE `courses` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `scores`
--

DROP TABLE IF EXISTS `scores`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `scores` (
  `ID` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `StuID` int(10) unsigned NOT NULL,
  `CourseID` smallint(5) unsigned NOT NULL,
  `Score` tinyint(3) unsigned DEFAULT NULL,
  PRIMARY KEY (`ID`)
) ENGINE=MyISAM AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `scores`
--

LOCK TABLES `scores` WRITE;
/*!40000 ALTER TABLE `scores` DISABLE KEYS */;
INSERT INTO `scores` VALUES (1,1,2,77),(2,1,6,93),(3,2,2,47),(4,2,5,97),(5,3,2,88),(6,3,6,75),(7,4,5,71),(8,4,2,89),(9,5,1,39),(10,5,7,63),(11,6,1,96),(12,7,1,86),(13,7,7,83),(14,8,4,57),(15,8,3,93);
/*!40000 ALTER TABLE `scores` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `students`
--

DROP TABLE IF EXISTS `students`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `students` (
  `StuID` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `Name` varchar(50) NOT NULL,
  `Age` tinyint(3) unsigned NOT NULL,
  `Gender` enum(&amp;apos;F&amp;apos;,&amp;apos;M&amp;apos;) NOT NULL,
  `ClassID` tinyint(3) unsigned DEFAULT NULL,
  `TeacherID` int(10) unsigned DEFAULT NULL,
  PRIMARY KEY (`StuID`)
) ENGINE=MyISAM AUTO_INCREMENT=26 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `students`
--

LOCK TABLES `students` WRITE;
/*!40000 ALTER TABLE `students` DISABLE KEYS */;
INSERT INTO `students` VALUES (1,&amp;apos;Shi Zhongyu&amp;apos;,22,&amp;apos;M&amp;apos;,2,3),(2,&amp;apos;Shi Potian&amp;apos;,22,&amp;apos;M&amp;apos;,1,7),(3,&amp;apos;Xie Yanke&amp;apos;,53,&amp;apos;M&amp;apos;,2,16),(4,&amp;apos;Ding Dian&amp;apos;,32,&amp;apos;M&amp;apos;,4,4),(5,&amp;apos;Yu Yutong&amp;apos;,26,&amp;apos;M&amp;apos;,3,1),(6,&amp;apos;Shi Qing&amp;apos;,46,&amp;apos;M&amp;apos;,5,NULL),(7,&amp;apos;Xi Ren&amp;apos;,19,&amp;apos;F&amp;apos;,3,NULL),(8,&amp;apos;Lin Daiyu&amp;apos;,17,&amp;apos;F&amp;apos;,7,NULL),(9,&amp;apos;Ren Yingying&amp;apos;,20,&amp;apos;F&amp;apos;,6,NULL),(10,&amp;apos;Yue Lingshan&amp;apos;,19,&amp;apos;F&amp;apos;,3,NULL),(11,&amp;apos;Yuan Chengzhi&amp;apos;,23,&amp;apos;M&amp;apos;,6,NULL),(12,&amp;apos;Wen Qingqing&amp;apos;,19,&amp;apos;F&amp;apos;,1,NULL),(13,&amp;apos;Tian Boguang&amp;apos;,33,&amp;apos;M&amp;apos;,2,NULL),(14,&amp;apos;Lu Wushuang&amp;apos;,17,&amp;apos;F&amp;apos;,3,NULL),(15,&amp;apos;Duan Yu&amp;apos;,19,&amp;apos;M&amp;apos;,4,NULL),(16,&amp;apos;Xu Zhu&amp;apos;,21,&amp;apos;M&amp;apos;,1,NULL),(17,&amp;apos;Lin Chong&amp;apos;,25,&amp;apos;M&amp;apos;,4,NULL),(18,&amp;apos;Hua Rong&amp;apos;,23,&amp;apos;M&amp;apos;,7,NULL),(19,&amp;apos;Xue Baochai&amp;apos;,18,&amp;apos;F&amp;apos;,6,NULL),(20,&amp;apos;Diao Chan&amp;apos;,19,&amp;apos;F&amp;apos;,7,NULL),(21,&amp;apos;Huang Yueying&amp;apos;,22,&amp;apos;F&amp;apos;,6,NULL),(22,&amp;apos;Xiao Qiao&amp;apos;,20,&amp;apos;F&amp;apos;,1,NULL),(23,&amp;apos;Ma Chao&amp;apos;,23,&amp;apos;M&amp;apos;,4,NULL),(24,&amp;apos;Xu Xian&amp;apos;,27,&amp;apos;M&amp;apos;,NULL,NULL),(25,&amp;apos;Sun Dasheng&amp;apos;,100,&amp;apos;M&amp;apos;,NULL,NULL);
/*!40000 ALTER TABLE `students` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `teachers`
--

DROP TABLE IF EXISTS `teachers`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `teachers` (
  `TID` smallint(5) unsigned NOT NULL AUTO_INCREMENT,
  `Name` varchar(100) NOT NULL,
  `Age` tinyint(3) unsigned NOT NULL,
  `Gender` enum(&amp;apos;F&amp;apos;,&amp;apos;M&amp;apos;) DEFAULT NULL,
  PRIMARY KEY (`TID`)
) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `teachers`
--

LOCK TABLES `teachers` WRITE;
/*!40000 ALTER TABLE `teachers` DISABLE KEYS */;
INSERT INTO `teachers` VALUES (1,&amp;apos;Song Jiang&amp;apos;,45,&amp;apos;M&amp;apos;),(2,&amp;apos;Zhang Sanfeng&amp;apos;,94,&amp;apos;M&amp;apos;),(3,&amp;apos;Miejue Shitai&amp;apos;,77,&amp;apos;F&amp;apos;),(4,&amp;apos;Lin Chaoying&amp;apos;,93,&amp;apos;F&amp;apos;);
/*!40000 ALTER TABLE `teachers` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `toc`
--

DROP TABLE IF EXISTS `toc`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `toc` (
  `ID` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `CourseID` smallint(5) unsigned DEFAULT NULL,
  `TID` smallint(5) unsigned DEFAULT NULL,
  PRIMARY KEY (`ID`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `toc`
--

LOCK TABLES `toc` WRITE;
/*!40000 ALTER TABLE `toc` DISABLE KEYS */;
/*!40000 ALTER TABLE `toc` ENABLE KEYS */;
UNLOCK TABLES;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;join的方式：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;1.cross join: 交叉联结。多项式相乘。效率极低，很少用。&lt;/strong&gt;&lt;br&gt;(a+b)(c+d+e)=ac+ad+ae+bc+bd+be&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.自然联结：内连接，等值连接。&lt;/strong&gt;&lt;br&gt;等值连接:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT * FROM students, classes WHERE students.ClassID = classes.ClassID;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/39.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.外联结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左外联结：只保留出现在左外连接运算之前（左边）的关系中的元组(元组就是记录)；&lt;br&gt;left_tb LEFT JOIN right_tb ON 连接条件(通常是一种等值比较)&lt;/li&gt;
&lt;li&gt;右外联结：只保留出现在右外连接运算之后（右边）的关系中的元组；left_tb RIGHT JOIN right_tb ON 连接条件&lt;/li&gt;
&lt;li&gt;全外联结：左右都出现，保留关系中的每一个元组。对应于右外连接来讲，左侧没有的左侧留空；对应于左外链接来讲，右侧没有的右留空。但是mysql是不支持全外联结。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【示例】：左外连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT s.Name,c.Class FROM students AS s LEFT JOIN classes AS c ON s.ClassID=c.ClassID;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/40.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;【示例】：右外连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT s.Name,c.Class FROM students AS s RIGHT JOIN classes AS c ON s.ClassID=c.ClassID;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/41.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.自联结：自己连接自己。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT t.Name,s.Name FROM students AS s,students AS t WHERE s.StuID = t.TeacherID;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/42.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;别名：&lt;/strong&gt;当表名、字段名太长时，或者为了区分，可以起个别名。使用AS&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/43.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/44.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/45.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【示例】：&lt;/strong&gt;&lt;br&gt; 1、显示前5位同学的姓名、课程及成绩；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT Name,Course FROM students AS s,courses AS c,coc WHERE s.ClassID = coc.ClassID AND coc.CourseID = c.CourseID AND s.StuID &amp;lt; 5;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/46.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT Name,Course,Score FROM students AS s,courses AS c,coc,scores AS ss WHERE s.ClassID = coc.ClassID AND coc.CourseID = c.CourseID AND s.StuID &amp;lt; 5 AND s.StuID=ss.StuID;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/47.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;但是由于scores表的StuID有重复，导致上面的s.StuID=ss.StuID条件挑选出来有重复，所以还要加一个条件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT Name,Course,Score FROM students AS s,courses AS c,coc,scores AS ss WHERE s.ClassID = coc.ClassID AND coc.CourseID = c.CourseID AND s.StuID &amp;lt; 5 AND s.StuID=ss.StuID AND coc.CourseID=ss.CourseID;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/48.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、求前8位同学每位同学自己两门课的平均成绩，并按降序排列；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT Name,AVG(Score) FROM students AS s,courses AS c,coc,scores AS ss WHERE s.ClassID = coc.ClassID AND coc.CourseID = c.CourseID AND s.StuID&amp;lt;=8 AND s.StuID=ss.StuID AND coc.CourseID=ss.CourseID GROUP BY Name ORDER BY AVG(Score) DESC;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/49.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;子查询&quot;&gt;&lt;a href=&quot;#子查询&quot; class=&quot;headerlink&quot; title=&quot;子查询&quot;&gt;&lt;/a&gt;子查询&lt;/h2&gt;&lt;p&gt;【思考】：如何显示其年龄大于平均年龄的同学的名字？&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/50.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;子查询：在查询中嵌套的查询。&lt;/p&gt;
&lt;h3 id=&quot;用于WHERE中的子查询&quot;&gt;&lt;a href=&quot;#用于WHERE中的子查询&quot; class=&quot;headerlink&quot; title=&quot;用于WHERE中的子查询&quot;&gt;&lt;/a&gt;用于WHERE中的子查询&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1、用于比较表达式中的子查询&lt;/strong&gt;&lt;br&gt;子查询的返回值只能有一个；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT Name,Age FROM students WHERE Age &amp;gt; (SELECT AVG(Age) FROM students GROUP BY Gender); 
ERROR 1242 (21000): Subquery returns more than 1 row
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2、用于EXISTS中的子查询&lt;/strong&gt;&lt;br&gt;判断存在与否&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、用于IN中的子查询&lt;/strong&gt;&lt;br&gt;判断存在于指定列表中&lt;/p&gt;
&lt;h3 id=&quot;用于FROM中的子查询&quot;&gt;&lt;a href=&quot;#用于FROM中的子查询&quot; class=&quot;headerlink&quot; title=&quot;用于FROM中的子查询&quot;&gt;&lt;/a&gt;用于FROM中的子查询&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;SELECT alias.col,... FROM (SELECT clause) AS alias WHERE condition  
mysql&amp;gt; SELECT s.Name,s.Age,s.Gender FROM (SELECT * FROM students WHERE Gender=&amp;apos;M&amp;apos;) AS s WHERE s.Age &amp;gt; 25;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/51.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【注意】：MySQL不擅长于子查询：应该避免使用子查询。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【总结】：MySQL的联结查询及子查询&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;联结&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交叉联结&lt;/li&gt;
&lt;li&gt;内联结&lt;/li&gt;
&lt;li&gt;外联结&lt;ul&gt;
&lt;li&gt;左外&lt;/li&gt;
&lt;li&gt;右外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自联结&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于WHERE中的子查询&lt;ul&gt;
&lt;li&gt;用于条件比较：子查询只能一个值&lt;/li&gt;
&lt;li&gt;用于IN：子查询可以返回多个值&lt;/li&gt;
&lt;li&gt;EXISTS：子查询可以返回多个值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用于FROM子句的子查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;MySQL的联合查询&quot;&gt;&lt;a href=&quot;#MySQL的联合查询&quot; class=&quot;headerlink&quot; title=&quot;MySQL的联合查询&quot;&gt;&lt;/a&gt;MySQL的联合查询&lt;/h2&gt;&lt;p&gt;把两个或多个查询语句的结果合并成一个结果进行输出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT clauase UNION SELECT clause UNION ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【示例】：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT Name,Age FROM teachers UNION SELECT Name,Age FROM students;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所谓索引有用，就是查询条件上面有索引，比如下例，你在姓名上创建索引，根据年龄来查找是没用的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SELECT Name,Age FROM students WHERE Age &amp;gt; 25;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询表中是否有索引：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/52.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;查看一个查询语句是否用到索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; EXPLAIN SELECT Name,Age FROM students WHERE Age &amp;gt; 25\G
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/53.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在某个字段上添加一个索引，然后再来查看这个查询是否用到索引：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; ALTER TABLE students ADD INDEX (Age);
mysql&amp;gt; SHOW INDEXES FROM students;
mysql&amp;gt; EXPLAIN SELECT Name,Age FROM students WHERE Age &amp;gt; 25\G
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/54.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;MySQL视图&quot;&gt;&lt;a href=&quot;#MySQL视图&quot; class=&quot;headerlink&quot; title=&quot;MySQL视图&quot;&gt;&lt;/a&gt;MySQL视图&lt;/h2&gt;&lt;p&gt;视图就是一虚表，MySQL对视图的支持很有限，因为MySQL支持子查询很有限。&lt;/p&gt;
&lt;p&gt;【示例】：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; GRANT ALL on hellodb.students TO &amp;apos;testuser&amp;apos;@&amp;apos;172.%.%.%&amp;apos; IDENTIFIED BY &amp;apos;testpass&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
mysql&amp;gt; GRANT ALL on hellodb.students TO &amp;apos;testuser&amp;apos;@&amp;apos;localhost&amp;apos; IDENTIFIED BY &amp;apos;testpass&amp;apos;;          
Query OK, 0 rows affected (0.00 sec)
mysql&amp;gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/55.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;为什么会出现这样的情况？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;In many default installations, all users have all privileges on tables within any database called test or beginning with test_.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以我这边重新导入上面的数据，并将数据库名字命名为hellodb。然后删除上面的两个用户，并且重新授权。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; use mysql
Database changed
mysql&amp;gt; DELETE FROM user WHERE user=&amp;apos;testuser&amp;apos;;
Query OK, 2 rows affected (0.00 sec)

mysql&amp;gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; GRANT ALL on hellodb.students TO &amp;apos;testuser&amp;apos;@&amp;apos;172.%.%.%&amp;apos; IDENTIFIED BY &amp;apos;testpass&amp;apos;;
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; GRANT ALL on hellodb.students TO &amp;apos;testuser&amp;apos;@&amp;apos;localhost&amp;apos; IDENTIFIED BY &amp;apos;testpass&amp;apos;; 
Query OK, 0 rows affected (0.00 sec)

mysql&amp;gt; FLUSH PRIVILEGES;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/56.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/57.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实授权的时候可以指定只给看表的某几个字段，但是用户用DESC students还是能看到这两个字段的定义。所以如果我们要想让用户意识到这两个用户不存在怎么办？这就是视图的意义了。创建一个虚表。授权视图给用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视图：存储下来的SELECT语句； 说白了就是把SELECT语句当表来用。&lt;/strong&gt;&lt;br&gt;【注意】:你什么时候用，它什么时候才执行，平时是没有的。因为存下来的是SELECT语句，不是SELECT查询的结果。当然，Oracle支持物化视图，MySQL不支持。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; HELP CREATE VIEW
Name: &amp;apos;CREATE VIEW&amp;apos;
Description:
Syntax:
CREATE
    [OR REPLACE]
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = { user | CURRENT_USER }]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW view_name [(column_list)]
    AS select_statement
    [WITH [CASCADED | LOCAL] CHECK OPTION]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/58.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/59.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/60.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/61.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;删除视图：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; DROP VIEW stu;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;查询的执行路径&quot;&gt;&lt;a href=&quot;#查询的执行路径&quot; class=&quot;headerlink&quot; title=&quot;查询的执行路径&quot;&gt;&lt;/a&gt;查询的执行路径&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;查询执行路径：&lt;/strong&gt;先查缓存，缓存未命中交给解析器。MySQL是允许多个用户连接进来的，因此有多个线程，如果每个线程上的用户都发起查询请求，而mysql真正能够执行查询的查询引擎只有一个，所以要排队，要给一个队列。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库及表管理</title>
    <link href="http://yoursite.com/2018/03/26/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E8%A1%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/03/26/MySQL数据库及表管理/</id>
    <published>2018-03-26T01:16:02.000Z</published>
    <updated>2018-03-26T02:58:27.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;MySQL中字符大小写&quot;&gt;&lt;a href=&quot;#MySQL中字符大小写&quot; class=&quot;headerlink&quot; title=&quot;MySQL中字符大小写&quot;&gt;&lt;/a&gt;MySQL中字符大小写&lt;/h2&gt;&lt;p&gt;1、SQL关键字及函数名不区分字符大小写； 但是为了提高缓存命中率，无论你使用大写或小写，风格上要一致。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;2、数据库、表及视图名称的大小区分与否取决于底层OS及FS。如果你是装在windows上的，是不区分大小写的，如果是安装在Linux上的，默认是区分大小写。因此很多时候我们把windows上的库移植到linux上就可能出问题。反过来移植更有问题。&lt;br&gt;3、存储过程、存储函数及事件调度器的名字不区分大小写，但触发器区分；&lt;br&gt;4、表的别名区分大小写；&lt;br&gt;5、对字段中的数据，如果字段类型为Binary类型，则区分大小写；非Binary不区分大小写(非Binary的排序取决于字符集及排序规则)。&lt;/p&gt;
&lt;h2 id=&quot;MySQL-DDL&quot;&gt;&lt;a href=&quot;#MySQL-DDL&quot; class=&quot;headerlink&quot; title=&quot;MySQL DDL&quot;&gt;&lt;/a&gt;MySQL DDL&lt;/h2&gt;&lt;h3 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.创建数据库&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE {DATABASE|SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] [CHARACTER SET=&amp;apos;&amp;apos;] [DEFAULT] [COLLATE=&amp;apos;&amp;apos;]

mysql&amp;gt; HELP CREATE DATABASE
Name: &amp;apos;CREATE DATABASE&amp;apos;
Description:
Syntax:
CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
    [create_specification] ...

create_specification:
    [DEFAULT] CHARACTER SET [=] charset_name
  | [DEFAULT] COLLATE [=] collation_name

CREATE DATABASE creates a database with the given name. To use this statement, you need the CREATE privilege for the database. CREATE SCHEMA is a synonym for CREATE DATABASE.

URL: http://dev.mysql.com/doc/refman/5.6/en/create-database.html
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【注意】:创建数据库时使用database或者schema都可以，对于oracle来讲，通常数据库被叫做schema，对Linux而言，schema或datable都表示数据库。&lt;br&gt;【示例】：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; create database t1 default charset utf8;
Query OK, 1 row affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.删除和修改数据库&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DROP {DATABASE | SCHEMA} [IF EXISTS] db_name
ALTER {DATABASE|SCHEMA} db_name [DEFAULT] [CHARACTER SET=&amp;apos;&amp;apos;] [DEFAULT] [COLLATE=&amp;apos;&amp;apos;]  #如果创建数据库时忘记指定其默认字符集默认排序规则，可以使用ALTER进行修改。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【注意】:如果想换数据库的名字，没有什么好办法，只能把数据库删除再重新创建或者备份数据库，然后删除，创建个新库，把表在导进去，这是比较理想的做法。还有一种比较粗暴的方法，到数据目录下，把那个目录名改一下就可以了。但改完后，这个数据库的数据字典中的信息并没有改变。因此千万不要试图通过修改那个目录名称来达到修改数据库名的目的，所以唯一的可靠做法就是备份、删除、创建新库、导入表，这个代价是很大的。&lt;/p&gt;
&lt;h3 id=&quot;表&quot;&gt;&lt;a href=&quot;#表&quot; class=&quot;headerlink&quot; title=&quot;表&quot;&gt;&lt;/a&gt;表&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/15.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;表创建&quot;&gt;&lt;a href=&quot;#表创建&quot; class=&quot;headerlink&quot; title=&quot;表创建&quot;&gt;&lt;/a&gt;表创建&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.第一种方式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name       
(create_definition,...)
[table_options]
[partition_options]   # 把一张表切割开，分成几张小表。
    TEMPORARY：创建临时表，临时表是保存在内存中，将占据内存空间，因此一般情况下非管理员在创建内存表上是没有权限的。

(create_definition,...)：
    字段的定义：字段名、类型和类型修饰符
    键、约束或索引：
        PRIMARY KEY, UNIQUE KEY, FOREIGN KEY, CHECK(检查约束)
        {INDEX|KEY}

[table_options]
    ENGINE [=] engine_name   ——指定表的存储引擎，如果不指定，将使用默认存储引擎。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【示例】：&lt;br&gt;查看默认存储引擎:&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/16.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;查看表的存储引擎：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/17.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;创建表时指定存储引擎为MyISAM：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; CREATE TABLE `t3`(Name VARCHAR(50) NOT NULL, Age TINYINT UNSIGNED NOT NULL, PRIMARY KEY(Name,Age)) ENGINE=&amp;apos;MyISAM&amp;apos;;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/18.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[table_options]
    AUTO_INCREMENT [=] value
    [DEFAULT] CHARACTER SET [=] charset_name
    [DEFAULT] COLLATE [=] collation_name
    COMMENT [=] &amp;apos;string&amp;apos;   #表的注释。如果表名不足以描述表的功能的话，给表加注释是一个好的习惯。
    DELAY_KEY_WRITE [=] {0 | 1}   ——延迟键写入。这一项在一定程度上能够提升性能的，但是有可能会影响查询。索引是加速查询的，但索引会降低写操作性能，为什么？因为我们更新表时必然得重建索引。所以一个修改非常频繁的表，其索引几乎是无效的。因为索引会经常被重建，索引的大量重建会导致性能很低。这就需要延迟键写入，把跟索引相关的信息几个合并起来，过一次会儿写入。
    ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}
    TABLESPACE tablespace_name [STORAGE {DISK|MEMORY|DEFAULT}]  #指定表空间。MySQL的表主要有两种类型，一种是MyISAM表，一种是InnoDB表。对于InnoDB表来说，如果使用默认的存储方式，我们可以通过TABLESPACE来指定多个共享表空间。如果是独立的表空间存储方式，也可以通过TABLESPACE来指定表空间名字。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;MyISAM表，每张表有三个文件，都位于数据库目录中：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tb_name.frm: 表结构定义&lt;/li&gt;
&lt;li&gt;tb_name.MYD: 数据文件&lt;/li&gt;
&lt;li&gt;tb_name.MYI: 索引文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;InnoDB表，有两种存储方式：&lt;/strong&gt;&lt;br&gt;（1）默认：每表有一个独立文件和一个多表共享的文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tb_name.frm: 表结构的定义，位于数据库目录(与数据库名同名的目录)中；&lt;/li&gt;
&lt;li&gt;ibdata#: 所有数据库的所有Innodb表共享的表空间文件，默认位于数据目录(datadir指向的目录)中；管理起来不方便，所以一般很少这么用。采用第二种方式，将来备份恢复时也很方便。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）独立的表空间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tb_name.frm: 每表有一个表结构文件&lt;/li&gt;
&lt;li&gt;tb_name.ibd: 一个独有的表空间文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【注意】:一般我们创建一张表时，表就会放在数据库目录下，但是对Innodb存储引擎例外。Innodb存储引擎的所有表默认都放在一个统一的表空间的文件中。&lt;br&gt;如何启用第二种方式呢？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW GLOBAL VARIABLES LIKE &amp;apos;innodb%&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/19.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这里已经开启了第二种。可以修改这个值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SET GLOBAL innodb_file_per_table=OFF;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【注意】：修改GLOBAL变量对当前会话不生效，需要退出重建会话。如果想要永久有效就得把这个配置写到配置文件的[mysqld]中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vim /etc/my.cnf
innodb_file_per_table=ON
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.表创建的第二种方式（复制表数据，也就是根据其他表来创建当前表）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
  [(create_definition,...)]
  [table_options]
  select_statement  #只是数据一致，但是字段属性跟源表并不一定一致。因此不是复制表，而是复制表中的数据。并自动判断实现字段的创建。对我们而言，这种方法不靠谱。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/20.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.表创建：第三种方式（只复制表结构，不复制数据）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
{ LIKE old_tbl_name | (LIKE old_tbl_name) }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以要先用第三种方式复制表结构，在使用INSERT语句往新表中插入数据，但数据不是自己手动创建的，而是从另外一张表中查询而来的。这样才能做到完整复制一张表。&lt;/p&gt;
&lt;h3 id=&quot;表删除&quot;&gt;&lt;a href=&quot;#表删除&quot; class=&quot;headerlink&quot; title=&quot;表删除&quot;&gt;&lt;/a&gt;表删除&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;DROP [TEMPORARY] TABLE [IF EXISTS]
  tbl_name [, tbl_name] ...
  [RESTRICT | CASCADE]  #CASCADE做级联删除，就是说如果某张表被其他表依赖，那么删除这个某表，使用CASCADE就会删除依赖这张某表的其他表。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;表修改&quot;&gt;&lt;a href=&quot;#表修改&quot; class=&quot;headerlink&quot; title=&quot;表修改&quot;&gt;&lt;/a&gt;表修改&lt;/h3&gt;&lt;p&gt;和表创建一样麻烦。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/21.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER TABLE tbl_name
  [alter_specification [, alter_specification] ...]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;修改字段定义&quot;&gt;&lt;a href=&quot;#修改字段定义&quot; class=&quot;headerlink&quot; title=&quot;修改字段定义&quot;&gt;&lt;/a&gt;修改字段定义&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.插入新字段&lt;/strong&gt;&lt;br&gt;插入新字段：可以一次插入单个字段，也可以一次插入多个字段。插入多个字段时，多个字段需要用()括起来。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/22.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.删除字段&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DROP [COLUMN] col_name
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/23.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.修改字段&lt;/strong&gt;&lt;br&gt;(1)仅修改字段名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CHANGE [COLUMN] old_col_name new_col_name column_definition
[FIRST|AFTER col_name]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(2)修改字段类型及属性等&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MODIFY [COLUMN] col_name column_definition
[FIRST | AFTER col_name]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;修改约束、键或索引等&quot;&gt;&lt;a href=&quot;#修改约束、键或索引等&quot; class=&quot;headerlink&quot; title=&quot;修改约束、键或索引等&quot;&gt;&lt;/a&gt;修改约束、键或索引等&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ADD {INDEX|KEY} [index_name]
[index_type] (index_col_name,...) [index_option] ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/24.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;表改名&quot;&gt;&lt;a href=&quot;#表改名&quot; class=&quot;headerlink&quot; title=&quot;表改名&quot;&gt;&lt;/a&gt;表改名&lt;/h4&gt;&lt;p&gt;使用ALTER命令：RENAME [TO|AS] new_tbl_name&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; ALTER TABLE `t5` RENAME TO `t7`;
Query OK, 0 rows affected (0.03 sec) 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者RENAME命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; RENAME TABLE old_name TO new_name;  
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;修改表的存储引擎&quot;&gt;&lt;a href=&quot;#修改表的存储引擎&quot; class=&quot;headerlink&quot; title=&quot;修改表的存储引擎&quot;&gt;&lt;/a&gt;修改表的存储引擎&lt;/h4&gt;&lt;p&gt;表引擎的修改背后mysql所执行的操作是创建一个你所指定存储引擎的新表，并把老的表中的数据导入到新表中。不建议通过ALTER直接修改表的存储引擎。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL中字符大小写&quot;&gt;&lt;a href=&quot;#MySQL中字符大小写&quot; class=&quot;headerlink&quot; title=&quot;MySQL中字符大小写&quot;&gt;&lt;/a&gt;MySQL中字符大小写&lt;/h2&gt;&lt;p&gt;1、SQL关键字及函数名不区分字符大小写； 但是为了提高缓存命中率，无论你使用大写或小写，风格上要一致。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据类型和sql_mode</title>
    <link href="http://yoursite.com/2018/03/23/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8Csql-mode/"/>
    <id>http://yoursite.com/2018/03/23/MySQL数据类型和sql-mode/</id>
    <published>2018-03-23T08:48:07.000Z</published>
    <updated>2018-03-25T11:59:41.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;DBA&quot;&gt;&lt;a href=&quot;#DBA&quot; class=&quot;headerlink&quot; title=&quot;DBA&quot;&gt;&lt;/a&gt;DBA&lt;/h2&gt;&lt;h3 id=&quot;开发DBA&quot;&gt;&lt;a href=&quot;#开发DBA&quot; class=&quot;headerlink&quot; title=&quot;开发DBA&quot;&gt;&lt;/a&gt;开发DBA&lt;/h3&gt;&lt;p&gt;数据库设计(E-R关系图)、SQL开发、内置函数、存储例程(存储过程和存储函数，存储过程没有返回值，函数有返回值)、触发器、事件调度器(event scheduler) 。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;strong&gt;1.什么是mysql存储过程?&lt;/strong&gt;&lt;br&gt;存储过程是存储在数据库服务器中的一组sql语句，通过在查询中调用一个指定的名称来执行这些sql语句命令。&lt;br&gt;&lt;strong&gt;2.为什么要使用mysql存储过程？&lt;/strong&gt;&lt;br&gt;应用程序分为两种，一种是基于web，一种是基于桌面，他们都和数据库进行交互来完成数据的存取工作。假设现在有一种应用程序包含了这两种，现在要修改其中的一个查询sql语句，那么我们可能要同时修改他们中对应的查询sql语句，当我们的应用程序很庞大很复杂的时候问题就出现这，不易维护！另外把sql查询语句放在我们的web程序或桌面中很容易遭到sql注入的破坏。而存储过程正好可以帮我们解决这些问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储函数(stored function)。返回一个计算结果，该结果可以用在表达式里。&lt;/li&gt;
&lt;li&gt;存储过程(stored procedure)。不直接返回一个结果，但可以用来完成一般的运算或是生成一个结果集并传递回客户。&lt;/li&gt;
&lt;li&gt;触发器(trigger)。与数据表相关联，当那个数据表被INSERT、DELETE或UPDATE语句修改时，触发器将自动执行。&lt;/li&gt;
&lt;li&gt;事件(event)。根据时间表在预定时刻自动执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;管理DBA&quot;&gt;&lt;a href=&quot;#管理DBA&quot; class=&quot;headerlink&quot; title=&quot;管理DBA&quot;&gt;&lt;/a&gt;管理DBA&lt;/h3&gt;&lt;p&gt;安装、升级，备份、恢复，用户管理、权限管理，监控、分析、基准测试，语句优化(要会写SQL语句)，数据字典，按需要配置服务器（服务器变量：MyISAM, InnoDB, 缓存, 日志）&lt;br&gt;运维人员虽然不是开发SQL的，但是我们需要对别人写出来的SQL语句做性能评估，去分析他写的SQL是不是足够高效。如果不是，我们需要对对方的SQL语句做改写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL注入攻击&lt;/strong&gt;指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。&lt;/p&gt;
&lt;h2 id=&quot;MySQL数据类型&quot;&gt;&lt;a href=&quot;#MySQL数据类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据类型&quot;&gt;&lt;/a&gt;MySQL数据类型&lt;/h2&gt;&lt;h3 id=&quot;数据类型的作用&quot;&gt;&lt;a href=&quot;#数据类型的作用&quot; class=&quot;headerlink&quot; title=&quot;数据类型的作用&quot;&gt;&lt;/a&gt;数据类型的作用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、存储的值类型；比如如果定义成字符型，往里面存数值是不允许的。就算你存1，也是被存储为字符了。
2、占据的存储空间大小；
3、定长，变长；
4、如何被索引及排序；
5、是否能够被索引。有些数据类型不能被索引的。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;数据字典&quot;&gt;&lt;a href=&quot;#数据字典&quot; class=&quot;headerlink&quot; title=&quot;数据字典&quot;&gt;&lt;/a&gt;数据字典&lt;/h3&gt;&lt;p&gt;系统编目(system catalog)&lt;br&gt;保存数据库服务器上的元数据。可以把初始化后的mysql库理解为mysql的数据字典。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;元数据：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系的名字    ——关系就是表&lt;/li&gt;
&lt;li&gt;每个关系的各字段的名字   ——字段就是属性&lt;/li&gt;
&lt;li&gt;各字段的数据类型和长度&lt;/li&gt;
&lt;li&gt;约束&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个关系上的视图的名字及视图的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;授权用户的名字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用户的授权和帐户信息  ——这些元数据是存储在user表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;统计类的数据：   ——很重要，可以评估数据库性能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个关系字段的个数；&lt;/li&gt;
&lt;li&gt;每个关系中行数；&lt;/li&gt;
&lt;li&gt;每个关系的存储方法；   ——表使用哪种存储引擎存储的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保存元数据的数据库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;information_schema    ——存储统计类元数据&lt;/li&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;performance_schema   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;performance_schema和information_schma一样，是两个虚库，有点类似于Linux的/proc文件系统，开机里面会有很多文件，但是一关机去看磁盘那个目录，里面没有任何数据。提供这两个接口就是为了兼容SQL语句的，能够实现对于整个数据库中任何信息的查找都能够基于SQL语句实现。所以mysql把这些信息虚拟成关系了。就像Linux一样，为什么提供/proc？/proc中存储的都是linux的内核参数，它把每个参数映射成一个文件中的数据。说白了就是把一个本来不是文件系统的东西映射成了一个文件系统，所以我们称/proc为伪文件系统。这样我们就可以操作文件系统的统一接口来操作内核。mysql也是同样的道理，本来获取mysql的这些数据需要通过其他方式，但是对于mysql的接口的操作方式绝大多数是通过SQL语句实现的。所以它也把这些信息抽象为关系的形式了。&lt;/p&gt;
&lt;h3 id=&quot;MySQL数据类型-1&quot;&gt;&lt;a href=&quot;#MySQL数据类型-1&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据类型&quot;&gt;&lt;/a&gt;MySQL数据类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;字符型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;char&lt;/li&gt;
&lt;li&gt;varchar&lt;/li&gt;
&lt;li&gt;binary&lt;/li&gt;
&lt;li&gt;varbinary&lt;/li&gt;
&lt;li&gt;text&lt;/li&gt;
&lt;li&gt;blob&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数值型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;精确数值型&lt;ul&gt;
&lt;li&gt;整型&lt;/li&gt;
&lt;li&gt;十进制数据：decimal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;近似数值型&lt;ul&gt;
&lt;li&gt;单精度浮点型&lt;/li&gt;
&lt;li&gt;双精度浮点型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日期时间型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日期型 DATE&lt;/li&gt;
&lt;li&gt;时间型 TIME&lt;/li&gt;
&lt;li&gt;日期时间型 DATETIME&lt;/li&gt;
&lt;li&gt;时间戳 TIMESTAMP&lt;/li&gt;
&lt;li&gt;YEAR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;布尔型：mysql没有真正意义上的布尔型，实际上使用tinyint来表示的，且只用1位表示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内建类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ENUM &lt;/li&gt;
&lt;li&gt;SET&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;数值型&quot;&gt;&lt;a href=&quot;#数值型&quot; class=&quot;headerlink&quot; title=&quot;数值型&quot;&gt;&lt;/a&gt;数值型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;TINYINT、SMALLINT、MEDIUMINT、INT和BIGINT 这5种是整型&lt;/li&gt;
&lt;li&gt;DECIMAL是十进制&lt;/li&gt;
&lt;li&gt;FLOAT：单精度&lt;/li&gt;
&lt;li&gt;DOUBLE：双精度&lt;/li&gt;
&lt;li&gt;BIT：按位实现数据存取的，但是不建议使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;字符型&quot;&gt;&lt;a href=&quot;#字符型&quot; class=&quot;headerlink&quot; title=&quot;字符型&quot;&gt;&lt;/a&gt;字符型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT，这几种不区分大小写&lt;/li&gt;
&lt;li&gt;BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB、ENUM、SET，这些都是二进制形式存取的，区分大小写，没有字符集      &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;日期时间型&quot;&gt;&lt;a href=&quot;#日期时间型&quot; class=&quot;headerlink&quot; title=&quot;日期时间型&quot;&gt;&lt;/a&gt;日期时间型&lt;/h4&gt;&lt;p&gt;DATE、TIME、DATETIME、TIMESTAMP、YEAR&lt;br&gt;会涉及到很多转换：&lt;br&gt;1、字符串varchar/char转日期&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select STR_TO_DATE(&amp;apos;2013-01-29 13:49:18&amp;apos;, &amp;apos;%Y-%m-%d %H:%i:%s&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、日期转字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select DATE_FORMAT(&amp;apos;2013-01-29 13:49:18&amp;apos;, &amp;apos;%Y-%m-%d %H:%i:%s&amp;apos;) 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;数据类型的修饰符&quot;&gt;&lt;a href=&quot;#数据类型的修饰符&quot; class=&quot;headerlink&quot; title=&quot;数据类型的修饰符&quot;&gt;&lt;/a&gt;数据类型的修饰符&lt;/h3&gt;&lt;h4 id=&quot;CHAR、VARCHAR和TEXT几种字符型常用的属性修饰符&quot;&gt;&lt;a href=&quot;#CHAR、VARCHAR和TEXT几种字符型常用的属性修饰符&quot; class=&quot;headerlink&quot; title=&quot;CHAR、VARCHAR和TEXT几种字符型常用的属性修饰符&quot;&gt;&lt;/a&gt;CHAR、VARCHAR和TEXT几种字符型常用的属性修饰符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;NOT NULL：非空约束&lt;/li&gt;
&lt;li&gt;NULL：允许为空&lt;/li&gt;
&lt;li&gt;DEFAULT ‘string’：指定默认值，只适用于char和varchar，不适用于TEXT类型&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CHARACTER SET ‘字符集’  #如果你不指定，默认从表继承，如果表没有，默认从库继承，如果库也没有，就从数据库服务器的全局继承。字符集对于我们将来存储、检索、比较等等是很关键的。&lt;/p&gt;
&lt;p&gt;  mysql&amp;gt; SHOW VARIABLES LIKE ‘%char%’; #查看当前数据库服务器的默认字符集&lt;br&gt;  mysql&amp;gt; SHOW CHARACTER SET  #查看支持的字符集&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;COLLATION ‘规则’: 排序规则。什么是排序规则呢？就算是gb2312的中文编码，你怎么对中文字符排序呢？谁应该大于谁，谁应该小于谁呢？我们有很多种方式，第一按拼音字母表，第二按照起笔(. — 丿)，第三按照笔画的多少排序等。所以同一种字符集内部要定义排序规则。&lt;/p&gt;
&lt;p&gt;  mysql&amp;gt; SHOW COLLATION;   #查看支持的排序规则。如果设定了字符集没有指定排序规则，每一种字符集都有其默认的排序规则。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【注意】:char是不需要字符结束符的，而varchar是有结束符的。char本身最多能存储255个字符，varchar最多能使用两个字节，65535个字符。而且能使用定长就不要使用变长，这跟我们在磁盘上快速查找记录有关系。变长的记录维护起来非常困难。无论是对插入、删除等对性能上都有负面影响。&lt;br&gt;另外要想存储大段文本，就要用text。但是不到万不得已的时候不要使用text，因为text本身索引起来很困难，并且text是作为对象存储的。什么对象存储？就是说不会直接存储到表中，而是存储在表之外的某个存储空间，而表中的那个字段存的仅仅是指向这个存储位置的指针。而且text不能使用全字段索引，但是char可以。&lt;/p&gt;
&lt;h4 id=&quot;BINARY、VARBINARY和BLOB几种字符型常用的属性修饰符&quot;&gt;&lt;a href=&quot;#BINARY、VARBINARY和BLOB几种字符型常用的属性修饰符&quot; class=&quot;headerlink&quot; title=&quot;BINARY、VARBINARY和BLOB几种字符型常用的属性修饰符&quot;&gt;&lt;/a&gt;BINARY、VARBINARY和BLOB几种字符型常用的属性修饰符&lt;/h4&gt;&lt;p&gt;默认是没有字符集的，因为它们是以二进制字节串的方式或者说是字节码的方式存储的。因此它们排序的时候是按照字节大小排序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NOT NULL&lt;/li&gt;
&lt;li&gt;NULL&lt;/li&gt;
&lt;li&gt;DEFAULT: 不适用于BLOB&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;整型的常用属性修饰符：&quot;&gt;&lt;a href=&quot;#整型的常用属性修饰符：&quot; class=&quot;headerlink&quot; title=&quot;整型的常用属性修饰符：&quot;&gt;&lt;/a&gt;整型的常用属性修饰符：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;AUTO_INCREMENT：自动增长。前提：非空，且惟一；支持索引，非负值；&lt;br&gt;【注意】:清空表后，重新插入数值，这个值继续增长，而不会从头开始计数。如果想把表中数据清空以后从头开始计数，alter表重置计数器，或者是清空表时用truncate，不用delete。&lt;/li&gt;
&lt;li&gt;UNSIGNED：无符号，表示不支持负值。&lt;/li&gt;
&lt;li&gt;NULL&lt;/li&gt;
&lt;li&gt;NOT NULL&lt;/li&gt;
&lt;li&gt;DEFAULT&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;浮点型常用修饰符&quot;&gt;&lt;a href=&quot;#浮点型常用修饰符&quot; class=&quot;headerlink&quot; title=&quot;浮点型常用修饰符&quot;&gt;&lt;/a&gt;浮点型常用修饰符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;NOT NULL&lt;/li&gt;
&lt;li&gt;NULL&lt;/li&gt;
&lt;li&gt;DEFAULT&lt;/li&gt;
&lt;li&gt;UNSIGNED&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;日期时间型的修饰符&quot;&gt;&lt;a href=&quot;#日期时间型的修饰符&quot; class=&quot;headerlink&quot; title=&quot;日期时间型的修饰符&quot;&gt;&lt;/a&gt;日期时间型的修饰符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;NOT NULL&lt;/li&gt;
&lt;li&gt;NULL&lt;/li&gt;
&lt;li&gt;DEFAULT&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;ENUM和SET的修饰符&quot;&gt;&lt;a href=&quot;#ENUM和SET的修饰符&quot; class=&quot;headerlink&quot; title=&quot;ENUM和SET的修饰符&quot;&gt;&lt;/a&gt;ENUM和SET的修饰符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;NOT NULL&lt;/li&gt;
&lt;li&gt;NULL&lt;/li&gt;
&lt;li&gt;DEFAULT ‘’&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SQL-MODE&quot;&gt;&lt;a href=&quot;#SQL-MODE&quot; class=&quot;headerlink&quot; title=&quot;SQL_MODE&quot;&gt;&lt;/a&gt;SQL_MODE&lt;/h2&gt;&lt;h3 id=&quot;MySQL-SQL-MODE&quot;&gt;&lt;a href=&quot;#MySQL-SQL-MODE&quot; class=&quot;headerlink&quot; title=&quot;MySQL SQL_MODE&quot;&gt;&lt;/a&gt;MySQL SQL_MODE&lt;/h3&gt;&lt;p&gt;MySQL SQL_MODE: SQL模式。&lt;br&gt;SQL模式就是定义mysql的工作模式的。比如下面那个例子，超出了范围怎么办呢？是截取后发waringings还是直接拒绝插入呢？SQL模式还能定义mysql在某些特性场景下能够模拟其他关系型数据库的行为，比如mysql有自己的工作特性，但是在一定程度上可以模拟oracle的工作特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; create table t2 (name CHAR(3));
Query OK, 0 rows affected (0.04 sec)

mysql&amp;gt; INSERT INTO t2 VALUES (&amp;apos;jerry&amp;apos;);
ERROR 1406 (22001): Data too long for column &amp;apos;name&amp;apos; at row 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改sql_mode是通过修改全局变量的值来实现的。&lt;br&gt;有这几种模式：TRADITIONAL, STRICT_TRANS_TABLES(只对支持事务的表有效), or STRICT_ALL_TABLES(对所有表都支持严格模式)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW GLOBAL VARIABLES like &amp;apos;sql_mode&amp;apos;;
+---------------+--------------------------------------------+
| Variable_name | Value                                      |
+---------------+--------------------------------------------+
| sql_mode      | STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION |
+---------------+--------------------------------------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;服务器变量&quot;&gt;&lt;a href=&quot;#服务器变量&quot; class=&quot;headerlink&quot; title=&quot;服务器变量&quot;&gt;&lt;/a&gt;服务器变量&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.设定服务器变量的值：（仅用于支持动态的变量，比如dataDir改了也没用）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;支持修改的服务器变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态变量：可以MySQL运行时修改。sql_mode支持运行时修改。&lt;/li&gt;
&lt;li&gt;静态变量：于配置文件中修改其值，并重启后方能生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器变量从其生效范围来讲，有两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局变量：服务器级别，修改之后仅对新建立的会话有效。&lt;/li&gt;
&lt;li&gt;会话变量：会话级别，仅对当前会话有效。&lt;br&gt;会话建立时，从全局继承各变量。继承完了，每个会话都独立管理自己的会话变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.查看服务器变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SHOW [{GLOBAL|SESSION}] VARIABLES [LIKE &amp;apos;&amp;apos;];   默认是查SESSION的变量值
mysql&amp;gt; SELECT @@{GLOBAL|SESSION}.VARILABLE_NAME; 
mysql&amp;gt; SELECT * FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME=&amp;apos;SOME_VARIABLE_NAME&amp;apos;;      #information_schema这个库里有个表叫GLOBAL_VARIABLES。
mysql&amp;gt; SELECT * FROM INFORMATION_SCHEMA.SESSION_VARIABLES WHERE VARIABLE_NAME=&amp;apos;SOME_VARIABLE_NAME&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/13.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;【示例】：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/14.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.修改变量&lt;/strong&gt;&lt;br&gt;前提：默认仅管理员有权限修改全局变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SET {GLOBAL|SESSION} VARIABLE_NAME=&amp;apos;VALUE&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【注意】:无论是全局还是会话级别的动态变量修改，在重启mysqld后都会失效；想永久有效，可定义在配置文件中的相应段中[mysqld]；另外，不是所有的服务器变量都可以写在配置文件中，绝大多数都可以。所以mysql服务器变量很独特，有3种生效方式：动态修改、定义配置文件或者执行命令时传递命令行参数。但这3者能使用的变量并不完全相同。有些变量可以作为命令行参数但是不能配置文件中。&lt;/p&gt;
&lt;p&gt;查看mysql支持的命令行参数有哪些以及哪些可以写在配置文件中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console ~]# mysqld --help --verbose
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DBA&quot;&gt;&lt;a href=&quot;#DBA&quot; class=&quot;headerlink&quot; title=&quot;DBA&quot;&gt;&lt;/a&gt;DBA&lt;/h2&gt;&lt;h3 id=&quot;开发DBA&quot;&gt;&lt;a href=&quot;#开发DBA&quot; class=&quot;headerlink&quot; title=&quot;开发DBA&quot;&gt;&lt;/a&gt;开发DBA&lt;/h3&gt;&lt;p&gt;数据库设计(E-R关系图)、SQL开发、内置函数、存储例程(存储过程和存储函数，存储过程没有返回值，函数有返回值)、触发器、事件调度器(event scheduler) 。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7安装mysql 5.7.21(二进制版本)</title>
    <link href="http://yoursite.com/2018/03/20/CentOS-7%E5%AE%89%E8%A3%85mysql-5-7-21-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%88%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/03/20/CentOS-7安装mysql-5-7-21-二进制版本/</id>
    <published>2018-03-20T01:45:45.000Z</published>
    <updated>2018-03-20T11:41:40.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;安装依赖&quot;&gt;&lt;a href=&quot;#安装依赖&quot; class=&quot;headerlink&quot; title=&quot;安装依赖&quot;&gt;&lt;/a&gt;安装依赖&lt;/h2&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;# yum install libaio* -y
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;下载安装MySQL二进制版本&quot;&gt;&lt;a href=&quot;#下载安装MySQL二进制版本&quot; class=&quot;headerlink&quot; title=&quot;下载安装MySQL二进制版本&quot;&gt;&lt;/a&gt;下载安装MySQL二进制版本&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/downloads/mysql/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MySQL社区版下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.下载解压&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cd /usr/local/
# wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz
# tar zxf mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz
# ln -sv mysql-5.7.21-linux-glibc2.12-x86_64 mysql
‘mysql’ -&amp;gt; ‘mysql-5.7.21-linux-glibc2.12-x86_64’
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.新建用户&lt;/strong&gt;&lt;br&gt;运行mysql最好不要用root去运行，而以普通用户身份。添加用户mysql。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# groupadd -r -g 300 mysql
# useradd -g mysql -r -s /sbin/nologin -u 300 mysql
# id mysql
uid=300(mysql) gid=300(mysql) groups=300(mysql)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3.创建目录并授权&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cd /usr/local/mysql
# mkdir data
# chown -R mysql:mysql .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4.初始化MySQL&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data
2018-03-20T10:19:23.020203Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).
2018-03-20T10:19:24.877676Z 0 [Warning] InnoDB: New log files created, LSN=45790
2018-03-20T10:19:25.111211Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.
2018-03-20T10:19:25.181304Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 2a1f5e46-2c28-11e8-8a64-00163e13578e.
2018-03-20T10:19:25.189269Z 0 [Warning] Gtid table is not ready to be used. Table &amp;apos;mysql.gtid_executed&amp;apos; cannot be opened.
2018-03-20T10:19:25.189787Z 1 [Note] A temporary password is generated for root@localhost: 77a.Fue3IeIg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意mysql临时密码在上面日志的最后一行的末尾：77a.Fue3IeIg，请先记下来。&lt;/strong&gt;&lt;br&gt;查看初始化后data目录生成的文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ls data/
auto.cnf  ib_buffer_pool  ibdata1  ib_logfile0  ib_logfile1  mysql  performance_schema  sys
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;5.生成RSA私钥，可以跳过此步骤&lt;/strong&gt;&lt;br&gt;mysql_ssl_rsa_setup需要openssl支持，用于启用数据量ssl连接，需要进一步配置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# bin/mysql_ssl_rsa_setup --datadir=/usr/local/mysql/data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;6.配置my.cnf&lt;/strong&gt;&lt;br&gt;将修改好的配置文件my.cnf传到/etc/目录下。my.cnf内容如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[mysql]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;socket          = /usr/local/mysql/mysql.sock&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# The MySQL server&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[mysqld]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;port            = 3306&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;socket          = /usr/local/mysql/mysql.sock&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#skip-grant-tables&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;datadir=/usr/local/mysql/data&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;log-error=/usr/local/mysql/db.err&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;pid-file=/usr/local/mysql/mysqld.pid&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;character-set-server = utf8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.拷贝启动脚本文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cp support-files/mysql.server /etc/init.d/mysqld 
# chkconfig --add mysqld
# service mysqld start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;8.设置开机启动&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# chkconfig mysqld on
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;9.配置环境变量，配置完重新打开一个shell&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vim /etc/profile.d/mysql.sh
export PATH=/usr/local/mysql/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;9.登录mysql，设置密码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysql -uroot -p77a.Fue3IeIg
密码是上面记录下来的临时密码
MySQL [(none)]&amp;gt; ALTER USER &amp;apos;root&amp;apos;@&amp;apos;localhost&amp;apos; identified by &amp;apos;test&amp;apos;;
MySQL [(none)]&amp;gt; flush privileges;
MySQL [(none)]&amp;gt; quit;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;10.在 Linux 下为了安全，默认是不允许 MySQL 服务器本机以外的机器访问 MySQL 数据库服务的，因此需要重新授权 root 账号。方便其他机器远程访问 MySQL 服务器，MySQL 命令如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MySQL [(none)]&amp;gt; grant all privileges on *.* to root@&amp;apos;%&amp;apos; identified by &amp;apos;Wisedu123@2018&amp;apos;;
MySQL [(none)]&amp;gt; flush privileges;
MySQL [(none)]&amp;gt; quit;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装依赖&quot;&gt;&lt;a href=&quot;#安装依赖&quot; class=&quot;headerlink&quot; title=&quot;安装依赖&quot;&gt;&lt;/a&gt;安装依赖&lt;/h2&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL介绍及安装部署</title>
    <link href="http://yoursite.com/2018/03/18/MySQL%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/03/18/MySQL介绍及安装部署/</id>
    <published>2018-03-18T04:08:49.000Z</published>
    <updated>2018-03-23T08:41:38.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;MySQL产品&quot;&gt;&lt;a href=&quot;#MySQL产品&quot; class=&quot;headerlink&quot; title=&quot;MySQL产品&quot;&gt;&lt;/a&gt;MySQL产品&lt;/h2&gt;&lt;p&gt;当年Sun公司买下了MySQL，后来Sun公司被Oracle收购了。也就是MySQL也变成Oracle的了。Oracle向来视MySQL为眼中钉，所以Oracle在收购Sun的时候遭到了欧盟的极力反对，他们担心MySQL。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;Oracle有前科的，对于自己的产品，有竞争对手的，把对方公司收购，在把产品打入冷宫，不卖了。Oracle当前做出承诺，5年内花人力物力研发MySQL。Oracle也的确这么做了，但是MySQL有两个版本：社区版和商业版。在Oracle收购Sun之后，在不到两年的时间，商业版价格翻了4倍。好在Oracle在收购Sun的时候还收购了一个Openoffice的组件，是Linux上的一个办公套件。Oracle收购之后第一件事，就是openoffice不再开源，开始收钱了。很遗憾的是，Oracle毙掉之后，大家不认账，没人买他的。后来，openoffice那个团队又在早期的openoffice基础上做了另外一套office叫Libreoffice，比openoffice还要好，依然开源。没过多久，Oracle把openoffice又开源了，但是没人在用了。所以不知道MySQL会不会面临这个命运。MySQL的原作者当前在Oracle收购Sun时就极力反对，在Sun被收购后，他又组织了当年的开源团队，在早期MySQL的基础上重新创建了另外一套叫做MariaDB。MariaDB开源，并且其在设计上比早期的MySQL更先进。而且其API和MySQL完全兼容，所以Redhat7不再附带MySQL，而是MariaDB。现在MySQL家族的产品主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL Server（mysqld、mysql）&lt;/li&gt;
&lt;li&gt;MySQL Cluster&lt;/li&gt;
&lt;li&gt;MySQL Proxy&lt;/li&gt;
&lt;li&gt;MySQL Adminitrator&lt;/li&gt;
&lt;li&gt;MySQL Query Browser&lt;/li&gt;
&lt;li&gt;MySQL Workbench    &lt;/li&gt;
&lt;li&gt;MySQL Migration Toolkit&lt;/li&gt;
&lt;li&gt;MySQL Embedded Server&lt;/li&gt;
&lt;li&gt;MySQL Drivers and Connectors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;MySQL Server：&lt;/strong&gt;分为企业级DB和社区版DB。&lt;br&gt;&lt;strong&gt;MySQL Cluster：&lt;/strong&gt;市面上几乎没有使用这种企业级集群。&lt;br&gt;&lt;strong&gt;MySQL Proxy：&lt;/strong&gt;由代理来判断谁能被读，谁能被写。&lt;br&gt;对于我们来说，会用到MySQL Server、MySQL Proxy和MySQL Drivers and Connectors。&lt;/p&gt;
&lt;h2 id=&quot;MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#MySQL逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL逻辑架构&quot;&gt;&lt;/a&gt;MySQL逻辑架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; MySQL是个多用户服务器，支持多个连接同时连接进来。可以通过线程池来定义最多可以有多少个用户同时连进来。多余的连接请求放在连接队列中，线程池里出去一个，就从队列里进去线程池一个。据说oracle为mysql的商业版引入了很强大的线程池机制。连接/线程处理是MySQL的重要组成部分。&lt;br&gt;    用户请求接进来以后，如果是个select语句，先查询缓存(mysql缓存是根据查询语句的hash码对比的，select的大小写都会导致hash码不一样)。如果命中，直接返回结果，如果未命中，接下来分析器做语句分析，分析之后缓存中还有可能命中。所以分析器分析后仍然要去查缓存。如果缓存还是未命中，接下来交给优化器，优化以后由执行引擎交给存储引擎做查询操作。&lt;br&gt;    优化器优化之后，真正负责执行语句的是存储引擎。mysql是插件式存储引擎的，所以不同的表可以使用不同的存储引擎。&lt;/p&gt;
&lt;h2 id=&quot;MySQL逻辑组件&quot;&gt;&lt;a href=&quot;#MySQL逻辑组件&quot; class=&quot;headerlink&quot; title=&quot;MySQL逻辑组件&quot;&gt;&lt;/a&gt;MySQL逻辑组件&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Connection Pool：Authentication, Thread Reuse, Connection Limits, Check Memory, Caches。&lt;br&gt;认证，线程重用， 连接限制， 检查内存， 实现连接缓存。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/5.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;存储引擎将数据转换成存储在文件系统中的文件，文件系统可以是NTFS、ufs、ext2/3、NFS、SAN、NAS。文件系统上的文件表现为文件和日志。文件有数据文件和索引文件。日志有重做、撤销、二进制、错误、查询和慢查询日志，一般不涉及撤销日志，所以这边日志有5种。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/6.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;备份工具、安全工具、恢复工具复制工具、集群工具等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/7.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;用户请求接进来了，&lt;strong&gt;连接管理器&lt;/strong&gt;负责接收用户请求，接进来后，&lt;strong&gt;线程管理器&lt;/strong&gt;需要生成一个线程响应用户请求(MySQL是单进程多线程模型的)，用户输入了帐号和密码后，需要一个&lt;strong&gt;用户模块&lt;/strong&gt;，用户肯定需要和用户模块打交道的，因为需要认证。只要连接进来，后续的sql语句也是和用户模块打交道，而不会和连接管理器打交道了。&lt;br&gt;    用户认证后，会发出很多SQL命令，由&lt;strong&gt;命令派发器&lt;/strong&gt;来派发给&lt;strong&gt;查询缓存&lt;/strong&gt;，查询缓存如果命中了则直接返回结果，当然完成了就需要&lt;strong&gt;记录日志&lt;/strong&gt;(记录日志是可选步骤)。如果查询缓存没命中，就要交给&lt;strong&gt;分析器&lt;/strong&gt;分析了。用户的语句有DDL、DML，分析结束后，如果是select就交给&lt;strong&gt;优化器&lt;/strong&gt;，如果是update、insert、delete、replace就交给&lt;strong&gt;表修改模块&lt;/strong&gt;，如果是repair就交给&lt;strong&gt;表维护模块&lt;/strong&gt;，如果是replication类操作就交给复制模块，还需要个&lt;strong&gt;状态报告模块&lt;/strong&gt;报告服务器执行状态。&lt;br&gt;    这些组件最终由&lt;strong&gt;访问控制模块&lt;/strong&gt;来控制，你到底有没有权限来操作，这个模块是做访问检查的。前面那个用户模块是做认证检查的，帐号密码没问题不代表可以访问里面的数据。访问控制模块检查没问题后，接下来就真正执行操作了。&lt;strong&gt;表管理器接口&lt;/strong&gt;的真正执行的操作依赖于&lt;strong&gt;存储引擎&lt;/strong&gt;。所以接下来要交给存储引擎的抽象接口。存储引擎抽象接口将用户请求在转发给各存储引擎。&lt;/p&gt;
&lt;h2 id=&quot;MySQL安装部署&quot;&gt;&lt;a href=&quot;#MySQL安装部署&quot; class=&quot;headerlink&quot; title=&quot;MySQL安装部署&quot;&gt;&lt;/a&gt;MySQL安装部署&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.MySQL的安装方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源码编译&lt;/li&gt;
&lt;li&gt;rpm包：&lt;ul&gt;
&lt;li&gt;OS Vendor提供的&lt;/li&gt;
&lt;li&gt;MySQL官方提供的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通用二进制格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.MySQL版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GA（General Availability）：要选择GA版&lt;/li&gt;
&lt;li&gt;RC（Release Candidate）：候选版，马上要发布为GA版本&lt;/li&gt;
&lt;li&gt;beta：公测版&lt;/li&gt;
&lt;li&gt;alpha：内测版&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3.MySQL官方提供的rpm包&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL-devel：开发需要的头文件和额外的库文件。&lt;/li&gt;
&lt;li&gt;MySQL-embedded：嵌入式环境下专用的。&lt;/li&gt;
&lt;li&gt;MySQL-ndb-management：MySQL集群管理器。&lt;/li&gt;
&lt;li&gt;MySQL-shared：被各种应用程序所依赖的贡献库。&lt;/li&gt;
&lt;li&gt;MySQL-shared-compat：兼容库。有些老的应用程序可能依赖mysql老版本的库。&lt;/li&gt;
&lt;li&gt;MySQL-test：测试套件。包含一些压测工具等等。&lt;/li&gt;
&lt;li&gt;MySQL-VERSION.PLATFORM.src.rpm：源代码包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对我们而言，需要MySQL-client、MySQL-server、MySQL-shared、MySQL-shared-compat和MySQL-test。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.二进制方式部署MySQL 5.6&lt;/strong&gt;&lt;br&gt;下载地址：&lt;a href=&quot;http://mirrors.sohu.com/mysql&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mirrors.sohu.com/mysql&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;操作系统版本&lt;/th&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;安装软件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;console&lt;/td&gt;
&lt;td&gt;CentOS 7.0&lt;/td&gt;
&lt;td&gt;114.55.29.246&lt;/td&gt;
&lt;td&gt;mysql-5.6.27-linux-glibc2.5-x86_64.tar.gz&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;（1）安装依赖包&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console local]# yum install libaio* -y
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（2）解压安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console local]# tar zxf mysql-5.6.27-linux-glibc2.5-x86_64.tar.gz 
[root@console local]# ln -sv mysql-5.6.27-linux-glibc2.5-x86_64 mysql
‘mysql’ -&amp;gt; ‘mysql-5.6.27-linux-glibc2.5-x86_64’
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（3）新建用户&lt;/strong&gt;&lt;br&gt;运行mysql最好不要用root去运行，而以普通用户身份。添加用户mysql。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console local]# groupadd -r -g 300 mysql
[root@console local]# useradd -g mysql -r -s /sbin/nologin -u 300 mysql
[root@console local]# id mysql
uid=300(mysql) gid=300(mysql) groups=300(mysql)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（4）修改mysql文件权限为mysql.mysql&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console local]# cd mysql
[root@console mysql]# chown -R mysql.mysql ./*
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（5）执行初始化操作，生成一个系统库叫mysql，它里面保存着有当前所有能够使用mysql服务器的用户帐号、所有数据库的名字、每个库中表的名字、表中字段的名字等等。&lt;/strong&gt;&lt;br&gt;脚本路径：/usr/local/mysql/scripts&lt;br&gt;创建数据文件目录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console mysql]# mkdir -pv /data/{mydata,binlog}
[root@console mysql]# scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/data/mydata
[root@console mysql]# ls /data/mydata
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（6）修改mysql目录下的文件属主为root，属组为mysql&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console mysql]# chown -R root .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（7）修改data目录属主、属组为mysql&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console mysql]# chown -R mysql.mysql /data
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（8）拷贝修改mysql的配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;copy写好的my.cnf到/etc/目录下。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# The following options will be passed to all MySQL clients&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[client]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#password       = your_password&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;port            = 3306&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;socket          = /tmp/mysql.sock&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# The MySQL server&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[mysqld]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;port            = 3306&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;socket          = /tmp/mysql.sock&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;skip-external-locking&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;key_buffer_size = 256M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;max_allowed_packet = 1M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;table_open_cache = 256&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sort_buffer_size = 1M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;read_buffer_size = 1M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;read_rnd_buffer_size = 4M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;myisam_sort_buffer_size = 64M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;thread_cache_size = 8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;query_cache_size= 16M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Try number of CPU&amp;apos;s*2 for thread_concurrency&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;thread_concurrency = 4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;datadir=/data/mydata&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;character-set-server = utf8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;max_connections = 1000&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Replication Master Server (default)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# binary logging is required for replication&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;log-bin=/data/binlog/master-bin&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# binary logging format - mixed recommended&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;binlog_format=mixed&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# required unique id between 1 and 2^32 - 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# defaults to 1 if master-host is not set&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# but will not function as a master if omitted&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;server-id       = 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[mysqldump]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;quick&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;max_allowed_packet = 16M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[mysql]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;no-auto-rehash&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[myisamchk]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;key_buffer_size = 128M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;sort_buffer_size = 128M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;read_buffer = 2M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;write_buffer = 2M&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[mysqlhotcopy]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;interactive-timeout&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（9）拷贝mysql的启动脚本，并加入系统服务&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console mysql]# cp support-files/mysql.server /etc/init.d/mysqld 
[root@console mysql]# chkconfig --add mysqld
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（10）启动mysql&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console mysql]# service mysqld start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（11）配置环境变量，配置完重新打开一个shell&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console mysql]# vim /etc/profile.d/mysql.sh
export PATH=/usr/local/mysql/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;（12）修改root密码，因为一装完root密码是空的&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@console ~]# mysql -uroot mysql 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; UPDATE user SET Password=PASSWORD(&amp;apos;wisedu123&amp;apos;) where USER=&amp;apos;root&amp;apos;;
mysql&amp;gt; FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/9.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;此时再以root登录就需要密码了。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/10.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（13）删除两个匿名帐号&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; use mysql
mysql&amp;gt; SELECT host,user,password FROM user;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; DROP USER &amp;apos;&amp;apos;@localhost;   #注意’’@localhost是两个单引号
mysql&amp;gt; DROP USER &amp;apos;&amp;apos;@console; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/12.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;MySQL初始化&quot;&gt;&lt;a href=&quot;#MySQL初始化&quot; class=&quot;headerlink&quot; title=&quot;MySQL初始化&quot;&gt;&lt;/a&gt;MySQL初始化&lt;/h2&gt;&lt;p&gt;MySQL是基于TCP的3306端口。虽然如此，但是还支持其他的通信方式，比如socket、memory、pipe。tcp是远程通信时用的，Linux或unix本机是基于socket，windows本机是基于memory或pipe。&lt;br&gt;MySQL服务器无论是通用二进制方式安装还是编译的方式安装，安装完成后要做MySQL的初始化。系统初始化时，默认库是mysql。这个库存储了当前mysql的各种元数据。这些初始化包含以下工作：&lt;/p&gt;
&lt;h3 id=&quot;提供配置文件&quot;&gt;&lt;a href=&quot;#提供配置文件&quot; class=&quot;headerlink&quot; title=&quot;提供配置文件&quot;&gt;&lt;/a&gt;提供配置文件&lt;/h3&gt;&lt;p&gt;配置文件：.cnf结尾 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集中式的配置:多个应用程序共用的配置文件&lt;ul&gt;
&lt;li&gt;[mysqld]&lt;/li&gt;
&lt;li&gt;[mysqld_safe]&lt;/li&gt;
&lt;li&gt;[client]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用配置文件的方式（安装mysql的方式不同，读取配置文件的顺序可能不同）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.它依次查找每个需要查找的文件，结果是所有文件并集；&lt;/li&gt;
&lt;li&gt;2.如果某参数在多个文件中出现多次，后读取的最终生效；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置文件顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# /usr/local/mysql/bin/mysqld --help --verbose | head -20
Default options are read from the following files in the given order:
/etc/mysql/my.cnf  /etc/my.cnf  ~/.my.cnf
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;删除所有匿名用户（5-7之前的版本）&quot;&gt;&lt;a href=&quot;#删除所有匿名用户（5-7之前的版本）&quot; class=&quot;headerlink&quot; title=&quot;删除所有匿名用户（5.7之前的版本）&quot;&gt;&lt;/a&gt;删除所有匿名用户（5.7之前的版本）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;mysql&amp;gt; DROP USER &amp;apos;&amp;apos;@&amp;apos;localhost&amp;apos;;
mysql&amp;gt; DROP USER &amp;apos;&amp;apos;@&amp;apos;www.abc.com&amp;apos;; #www.abc.com为主机名
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用户帐号由两部分组成：username@host，host指所能够远程访问时使用的客户端主机&lt;br&gt;host还可以使用通配符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;%: 任意长度的任意字符&lt;/li&gt;
&lt;li&gt;_: 匹配任意单个字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;给所有的root用户设定密码（5-7之前的版本）&quot;&gt;&lt;a href=&quot;#给所有的root用户设定密码（5-7之前的版本）&quot; class=&quot;headerlink&quot; title=&quot;给所有的root用户设定密码（5.7之前的版本）&quot;&gt;&lt;/a&gt;给所有的root用户设定密码（5.7之前的版本）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.第一种方式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; SET PASSWORD FOR username@host = PASSWORD(&amp;apos;your_passwrod&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.第二种方式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; UPDATE user SET password = PASSWORD(&amp;apos;your_password&amp;apos;) WHERE user = &amp;apos;root&amp;apos;;   ——这是修改授权表
mysql&amp;gt; FLUSH PRIVILEGES;   ——通知mysqld重读授权表
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3.第三种方式： 命令行mysqladmin工具&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# mysqladmin -uUserName -hHost password &amp;apos;new_password&amp;apos; -p    ——这里的host指mysqld服务器的ip，并不是帐号中的主机地址
# mysqladmin -uUserName -hHost -p flush-privileges
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;客户端工具&quot;&gt;&lt;a href=&quot;#客户端工具&quot; class=&quot;headerlink&quot; title=&quot;客户端工具&quot;&gt;&lt;/a&gt;客户端工具&lt;/h2&gt;&lt;p&gt;mysql, mysqladmin, mysqldump, mysqlcheck, mysqlimport&lt;br&gt;配置文件中[client]下面的配置是所有mysql客户端共享的配置&lt;br&gt;命令行客户端的通用的选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-u, –user=&lt;/li&gt;
&lt;li&gt;-h, –host=&lt;/li&gt;
&lt;li&gt;-p, –password=&lt;/li&gt;
&lt;li&gt;–protocol={tcp|socket|memory|pipe}&lt;/li&gt;
&lt;li&gt;–port=&lt;/li&gt;
&lt;li&gt;–socket=    例如：/tmp/mysql.sock &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非客户端类的管理工具：myisamchk, myisampack。 都是在mysql服务器上运行的，不能基于客户端服务器端通信方式进行使用的。myisamchk是检测工具，检测myisam表是不是有不一致的情况。myisampack是打包压缩工具。&lt;/p&gt;
&lt;h3 id=&quot;mysql客户端&quot;&gt;&lt;a href=&quot;#mysql客户端&quot; class=&quot;headerlink&quot; title=&quot;mysql客户端&quot;&gt;&lt;/a&gt;mysql客户端&lt;/h3&gt;&lt;p&gt;mysql这个命令行客户端工作模式: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;交互式模式 mysql&amp;gt; &lt;/li&gt;
&lt;li&gt;脚本模式(批处理模式) mysql &amp;lt; /path/to/mysql_script.sql&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.mysql交互式模式&lt;/strong&gt;&lt;br&gt;（1）客户端命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; help  ——获取客户端命令帮助
mysql&amp;gt; \?    ——获取客户端命令帮助
       \c
       \g
       \G
       \q
       \!
       \s
       \. /path/to/mysql_script.sql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，客户端命令里面偶尔可能还会用到其他的，比如”rehash    (#) Rebuild completion hash.”，MySQL其实也支持命令补全的，比如说你有一个库叫mysql，或者叫其他的库，等会我们去use设定某个默认库时，或者只要但凡用到库名的时候，你可以不用写全了，它可以自动给你补全。但是这一功能在mysql启动时默认是关闭的，因为要想能够实现此种功能意义上的补全，需要让mysql服务器启动时读取每一个mysql对象并且给它们生成一个hash表才能补全。这通常会导致mysql启动时被卡住，尤其是非常大的mysql数据库时。启动后如果想用补全，就使用#，重新生成补全的hash表的hash码。&lt;/p&gt;
&lt;p&gt;（2）服务器端命令：需要把命令写全后一并发送给服务器端执行的，因此需要命令结束符，默认为分号(;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.mysql的快捷键&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ctrl + w: 删除光标之前的单词&lt;/li&gt;
&lt;li&gt;Ctrl + u: 删除光标之前至命令行首的所有内容&lt;/li&gt;
&lt;li&gt;Ctrl + y: 粘贴使用Ctrl+w或Ctrl+u删除的内容&lt;/li&gt;
&lt;li&gt;Ctrl + a: 移动光标至行首&lt;/li&gt;
&lt;li&gt;Ctrl + e: 移动光标至行尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;mysqldmin工具&quot;&gt;&lt;a href=&quot;#mysqldmin工具&quot; class=&quot;headerlink&quot; title=&quot;mysqldmin工具&quot;&gt;&lt;/a&gt;mysqldmin工具&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;mysqladmin [options] command [arg] [command [arg]] ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;command:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create DB_NAME&lt;/li&gt;
&lt;li&gt;drop DB_NAME&lt;/li&gt;
&lt;li&gt;debug: 打开调试日志并记录于error log中；如果我们启动mysql总是出错的话，你可以使用mysqladmin debug，它可以限定通知mysql服务器运行过程中的所有信息都送往mysql的error log。&lt;/li&gt;
&lt;li&gt;status：显示mysql运行的简要状态信息&lt;ul&gt;
&lt;li&gt;–sleep #: 指定间隔时长刷新状态信息&lt;/li&gt;
&lt;li&gt;–count #: 显示的批次，显示几次。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;extended-status: 输出mysqld的各状态变量及其值，相当于执行“mysql&amp;gt; SHOW GLOBAL STATUS”&lt;/li&gt;
&lt;li&gt;variables: 输出mysqld的各服务器变量&lt;/li&gt;
&lt;li&gt;flush-hosts: 清空主机相关的缓存：DNS解析缓存，此前因为连接错误次数过多而被拒绝访问mysqld的主机列表。如果我们在某台客户端主机上连服务器，mysql默认好像是10次，在有限时间内错误过多可能就被放到黑名单中去了。此后再发连接请求，直接拒绝。一旦出现这种情况，就得去mysql服务器端flush-hosts。&lt;/li&gt;
&lt;li&gt;flush-logs: 日志滚动，只二进制日志和中继日志。&lt;/li&gt;
&lt;li&gt;refresh: 相当于同时使用flush-logs和flush-hosts&lt;/li&gt;
&lt;li&gt;flush-privileges: 通知服务器重读授权表。&lt;/li&gt;
&lt;li&gt;reload: 功能同flush-privileges。&lt;/li&gt;
&lt;li&gt;flush-status: 重置服务器状态变量的值。重置extended-status显示的变量值，不是所有变量。&lt;/li&gt;
&lt;li&gt;flush-tables: 关闭当前打开的表文件句柄。&lt;/li&gt;
&lt;li&gt;flush-threads：清空线程缓存。&lt;/li&gt;
&lt;li&gt;kill:　给线程id，杀死指定的线程，可以一次杀死多个线程，以逗号分隔，但不能有多余空格。mysql是单进程多线程的。&lt;/li&gt;
&lt;li&gt;password: 修改当前用户的密码。&lt;/li&gt;
&lt;li&gt;ping: 探测服务器是否在线。&lt;/li&gt;
&lt;li&gt;processlist：显示mysql服务器的线程列表。&lt;/li&gt;
&lt;li&gt;shutdown: 关闭mysqld进程。所以mysqladmin是个很危险的命令。&lt;/li&gt;
&lt;li&gt;start-slave&lt;/li&gt;
&lt;li&gt;stop-slave: 启动/关闭从服务器线程&lt;/li&gt;
&lt;li&gt;version：显示mysqld的版本。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【示例】：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@osb30 ~]# mysqladmin -uroot -p create testdb
Enter password: 
[root@osb30 ~]# mysqladmin -uroot -p status
Enter password: 
Uptime: 15116890  Threads: 23  Questions: 144580431  Slow queries: 12904887  Opens: 380  Flush tables: 1  Open tables: 338  Queries per second avg: 9.564
[root@osb30 ~]# mysqladmin -uroot -p version
Enter password: 
mysqladmin  Ver 8.42 Distrib 5.6.27, for Linux on x86_64
Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Server version          5.6.27
Protocol version        10
...
[root@osb30 ~]# mysqladmin -uroot -p ping
Enter password: 
mysqld is alive
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;GUI客户端工具：&quot;&gt;&lt;a href=&quot;#GUI客户端工具：&quot; class=&quot;headerlink&quot; title=&quot;GUI客户端工具：&quot;&gt;&lt;/a&gt;GUI客户端工具：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Navicat for mysql      商业版的&lt;/li&gt;
&lt;li&gt;Toad for mysql          &lt;/li&gt;
&lt;li&gt;mysql front            商业版的&lt;/li&gt;
&lt;li&gt;sqlyog                 商业版的&lt;/li&gt;
&lt;li&gt;phpMyAdmin             基于php的开源工具&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;mysql忘记root密码怎么办&quot;&gt;&lt;a href=&quot;#mysql忘记root密码怎么办&quot; class=&quot;headerlink&quot; title=&quot;mysql忘记root密码怎么办&quot;&gt;&lt;/a&gt;mysql忘记root密码怎么办&lt;/h2&gt;&lt;p&gt;在my.cnf文件中加入如下配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;skip-grant-tables=1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后用空密码方式使用root用户登录 MySQL：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql -u root
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改root用户的密码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql&amp;gt; update mysql.user set password=PASSWORD(&amp;apos;newpassword&amp;apos;) where User=&amp;apos;root&amp;apos;;  
mysql&amp;gt; flush privileges;  
mysql&amp;gt; quit 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MySQL产品&quot;&gt;&lt;a href=&quot;#MySQL产品&quot; class=&quot;headerlink&quot; title=&quot;MySQL产品&quot;&gt;&lt;/a&gt;MySQL产品&lt;/h2&gt;&lt;p&gt;当年Sun公司买下了MySQL，后来Sun公司被Oracle收购了。也就是MySQL也变成Oracle的了。Oracle向来视MySQL为眼中钉，所以Oracle在收购Sun的时候遭到了欧盟的极力反对，他们担心MySQL。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>关系数据库理论基础</title>
    <link href="http://yoursite.com/2018/03/13/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/03/13/关系数据库理论基础/</id>
    <published>2018-03-13T05:51:55.000Z</published>
    <updated>2018-03-18T04:05:28.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;最近开始做报表，于是把之前学习的mysql相关知识整理回顾下，温故而知新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h2&gt;&lt;p&gt;程序=指令+数据&lt;br&gt;    指令是CPU能够逐条解析运行的命令，CPU运行指令的主要目的是处理数据的。其实对于CPU所能够执行的程序，无论是指令还是数据都在内存当中。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;但是数据从何而来，数据是需要持久存储的。假设我们不需要用户通过键盘输入数据，程序的执行结果有可能产生输出。任何程序都很依赖I/O，说白了I/O提供数据，并保存数据。&lt;br&gt;    数据从何而来？第一种方式是程序员在开发程序时初始化的一些变量值，但是这些变量值在初始化时给到的数据量是很小的。还有其他的方式，文件、交互式输入，这两种都是I/O中的I。&lt;br&gt;    那么输出呢？当程序处理结束了，它的所有处理结果都在内存中，如果这个时候我们把进程终止了，所有数据都会丢失了，我们应该把输出保存在一个持久存储中。&lt;br&gt;    但是要考虑一个问题，我们如何将持久存储中的数据原样不动的载入内存中？能够存储在文件中的数据通常要做扁平化或者流式化的。要把这些扁平化或流式化的数据还原到内存中，如何还原？所有保存在文件中的内容都是字符。当然这里指的是文本文件，就算是二进制文件，里面就是01字节码。但是有些时候，比如我们希望读进内存时不是字符，而是数值。很显然一个文本文件是不能提供这个功能的。&lt;br&gt;    在考虑一种场景，现在有一个用户帐号文件，用户帐号200或者300个，我们把这些帐号密码保存到文本文件中。当用户登录时，我们需要去文件中逐个比较用户输入的字符串，前提是得把整个文件装入内存。就算你grep “root” /etc/passwd，也是需要先把/etc/passwd装入到内存中才行。如果用户数增加到1000万个，这个文本文件可能有10个G，而我们为了查找一个用户得把10个G从磁盘产生大量I/O调入内存，性能奇差。这显然也是无法想象的，无法接受。&lt;br&gt;    因此我们需要在更高层次的逻辑结构上将数据分割成片。如果我们把数据存于一个单个文件，而访问接口又只是文件接口的话，每次访问这个文件的数据，都得把整个文件装入内存。因此需要在文件的物理结构的基础之上在提供一层逻辑结构，在这个逻辑视角上，把物理层次所保存的所有数据切割成块，或者切割成片。当需要查找用户信息时，我们没必要把整个文件载入内存，而只要把那个数据所在的一个片或多个片装入内存。因此我们在文件系统层次更高级别之上提供一层逻辑性的管理机制，这种机制能够使得我们去装载数据时而不用牵一发而动全身。而提供这个管理机制的工具，向下负责管理这个文件，将文件切割成片，向上将文件切割成片的结果用一种用户习惯的方式展示给用户。用户看到的将是数据。这样的工具就是数据库管理系统(DBMS)。&lt;/p&gt;
&lt;h2 id=&quot;数据模型&quot;&gt;&lt;a href=&quot;#数据模型&quot; class=&quot;headerlink&quot; title=&quot;数据模型&quot;&gt;&lt;/a&gt;数据模型&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;要从逻辑层把数据映射到物理层上，那么这个软件自身必须要能够完成对物理层到逻辑层之间的数据组织，而在数据组织上，有3种数据组织模型。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;层次模型：早期的层次型数据库。倒置树状结构。&lt;/li&gt;
&lt;li&gt;网状模型：和层次模型一样，对于数据冗余和彼此间建立关联关系都很困难，而且网状模型异常复杂。&lt;/li&gt;
&lt;li&gt;关系模型：海量数据时，关联的数据库表太多，反而开销很大。&lt;br&gt;库和表，库是由表组成的。一个表可以没有行，只不过是个空表。但是不可以没有列，没有列怎么组织成表呢。我们又把列称为字段(field)。&lt;/li&gt;
&lt;li&gt;非关系型数据库模型：反关系型数据库，NoSQL：不仅仅是SQL，不要以为它不是SQL。NoSQL是一个技术流派，而不是一个数据库，有各种各样的流派。NoSQL不是新概念，它只不过是利用现代互联网海量数据视角重新焕发了青春。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论是上面4种中的哪种模型，都遵循上面介绍的数据库设计理念。无非就是背后物理层的数据组织以及在逻辑层映射的功能可能大为不同或略有不同而已。对于用户来看，通常都是两种接口，命令行和API。而API通常为程序员所使用。&lt;/p&gt;
&lt;h2 id=&quot;数据库分类&quot;&gt;&lt;a href=&quot;#数据库分类&quot; class=&quot;headerlink&quot; title=&quot;数据库分类&quot;&gt;&lt;/a&gt;数据库分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据冗余和不一致型：比如/etc/passwd，我们可以创建两个完全相同的用户，也是能保存进去的，这就是数据冗余。    &lt;/li&gt;
&lt;li&gt;数据访问困难：十万个帐号放在文本数据库中，想找其中的一个会很困难。使用grep去实现查找。&lt;/li&gt;
&lt;li&gt;数据孤立&lt;/li&gt;
&lt;li&gt;完整性问题&lt;/li&gt;
&lt;li&gt;原子性问题：一个机制，能够把多个操作当成一个操作，要么同时能执行，要么都不能执行。这就是原子性问题。    &lt;/li&gt;
&lt;li&gt;并发访问异常&lt;/li&gt;
&lt;li&gt;安全性问题 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;DBMS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;层次模型&lt;/li&gt;
&lt;li&gt;网状模型&lt;/li&gt;
&lt;li&gt;关系模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RDBMS&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关系型数据库：将数据组织在一个有字段和记录组成的二维关系表中，并且在这个关系表之外提供了很多辅助性工具以完成关系表中关系的维持及数据访问等功能。核心是二维关系表。&lt;br&gt;    一个数据库管理系统还应该提供安全性的机制，所以我们还得为管理系统提供认证、授权等功能。&lt;br&gt;    我们要想实现对数据访问时载入有限片的数据而不用是所有数据，还要提供索引等。&lt;br&gt;    对于用户来讲，需要只看到自己需要的数据，还要提供视图等。&lt;br&gt;    但是关系型数据库还遇到一个问题，如何把文件存入到数据库中？不大可能，除非把图片编码重新编码成字符保存到数据库中。如果不能，我们可以把一个文件在文件系统中的路径(字符串)存在表中。&lt;br&gt;    &lt;strong&gt;【注意】:关系型数据库只是一种概念，只是一种设计理念，能够把这种理念实现的通常是软件。这和前面讲协议是一样的，http是一种协议，其实现是由httpd、nginx等等来实现的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见的关系型数据库产品&quot;&gt;&lt;a href=&quot;#常见的关系型数据库产品&quot; class=&quot;headerlink&quot; title=&quot;常见的关系型数据库产品&quot;&gt;&lt;/a&gt;常见的关系型数据库产品&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;SQL Server&lt;/li&gt;
&lt;li&gt;DB2&lt;/li&gt;
&lt;li&gt;MySQL&lt;/li&gt;
&lt;li&gt;MariaDB&lt;/li&gt;
&lt;li&gt;PostgreSQL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1.早期三巨头&lt;/strong&gt;&lt;br&gt;Sybase  —&amp;gt;早期和Microsoft合作过。一起研发了一个面向windows的关系型数据库产品，后来Sybase不玩了。Microsoft就买断发展，后来就成了SQL Server。今天Sybase今天依然存在。&lt;br&gt;Informix  —&amp;gt;被IBM收购了。IBM有自己的DB2。&lt;br&gt;Oracle  —&amp;gt;oracle的产品不一定是最好的，但是oracle的销售做的是最好的。所以你把技术做的在牛在精，卖不出去就是没用。所以刚开始工作时9分靠技术，1分靠沟通。而两年到三年以后，工作业绩7分靠沟通，3分靠技术。当然，技术做好安身立命没问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.MySQL —&amp;gt; MariaDB&lt;/strong&gt;&lt;br&gt;    早期属于瑞典的AB公司，2009年卖给了sun公司，不幸的是sun被oracle收购了。oracle有些很不光彩的前科，把竞争对手买下来然后打入冷宫。虽然oracle承诺了5年不下手，但实际上这期间MySQL已经被蹂躏了无数遍。到今天为止，和MySQL合作的，用MySQL软件的，比如Facebook、Google、Twitter都在纷纷转向MariaDB。&lt;br&gt;    MySQL的原作者在sun被oracle收购以后，就另立门户了。在早期MySQL的基础上重新提供了另外一个分支MariaDB。MariaDB在兼容MySQL的基础上而且又整合了开源社区中的很强大的技术力量。比如早期MySQL整合进的存储引擎中有个innodb，innodb属于innobase公司，而innobase早在2008年被oracle收购了。但好在percona公司致力于MySQL优化方面，这个组织在改进早期innodb的基础上提供了增强版的innodb叫xtradb。而MariaDB中用的就是xtradb。&lt;br&gt;    早些年Facebook、Google、Twitter(还有一家公司，记不得了)内部的研发团队所研发出来的一些新技术不断的反馈回MySQL社区，但是MySQL可能变成oracle的商用产品，这些公司肯定也是不同意的。因此双方在MySQL的发展上产生了很大的分歧，所以这几家公司中的工程师整合了后来他们所研发的新技术又开发了另外一个分支，专门为互联网应用而生的增强版的、支持多主复制等的新产品，叫webscaledb。专门为web应用而生的数据库管理系统。诞生时间2014年。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.另外一个开源产品：PostgreSQL，简称pgsql&lt;/strong&gt;&lt;br&gt;    前身是互联网上最早的一批关系型数据库产品egresql，早期诞生在加州大学伯克利分校的。只是egresql在商业运作上和oracle竞争时完全败下阵来。以至于后来销声匿迹的比Sybase和Informix还早。&lt;br&gt;    事实上，就关系型数据库本身来讲，pgsql比mysql在技术上要优秀的多。不过市场决定一切。&lt;br&gt;    RHEL7内置不在是MySQL，而是MariaDB。&lt;br&gt;    这个世界唯一不变的是”不断的变化”。&lt;/p&gt;
&lt;p&gt;以上讲的产品都是C/S架构，以mysql为例，有客户端，也有服务端。两者之间的通信时通过mysql协议来通信的。另外一种独立的产品叫sqlite。这仅是一个简单的、工作在本地的、非服务化的、纯粹基于API的关系型数据库接口。【注意】:sqlite仅是一个引擎。说白了就是讲，你通过它能够将数据组织成关系型数据库的格式，背后仍然是把数据存于文件中。因此我们要通过sqlite存储数据怎么办呢？sqlite不监听在任何服务上，只有API。因此只有程序员在开发程序时调用这个API，就能够基于sqlite这个引擎来完成基于关系型数据库模式的数据存储了。所以它尤其适用于嵌入式平台上。&lt;/p&gt;
&lt;h2 id=&quot;关系型数据库分析&quot;&gt;&lt;a href=&quot;#关系型数据库分析&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库分析&quot;&gt;&lt;/a&gt;关系型数据库分析&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.一个通用的关系型数据库管理系统应该具有的逻辑架构&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/MySQL/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;首先作为一个数据库管理系统来讲，必须要能接收用户发出的请求，而用户的请求的来源方式有多种。大多是通过sql协议来的，只不过通过sql协议连进来的有这么两种模式，一种是基于API接口的，一种是基于交互式客户端的。而sqlite这种只有一种方式就是基于API。&lt;br&gt;    对于关系型数据库来讲，怎么接进来？对于sqlite来讲，它没有监听在C/S模式下，只要调用API。但是对于MySQL来讲，需要支持更大的并发连接请求，sqlite就没有并发的概念。所以前端应该有一个连接管理器，需要对用户发来的sql语句进行解析。SQL(Structure Query Language)语句分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DDL: CREATE, DROP, ALTER    ——数据定义语言：操作数据库对象的。比如库、表、索引、视图等。&lt;/li&gt;
&lt;li&gt;DML: SELECT, INSERT, UPDATE, DELETE    ——数据操作语言：管理数据的。&lt;/li&gt;
&lt;li&gt;DCL: GRANT, REVOKE    ——授权&lt;br&gt;  现在几乎所有的关系型数据库向外的接口都是通过sql语句输出的，只不过联络方式有所不同而已。因此一旦一个sql语句来了，查询求解引擎分析语法，然后执行语句，说白了就是mysql的解释器。这个执行引擎就类似于Linux内核，这和我们通过shell运行命令类似。这个解释器应该具备的功能包括：分析器、优化器、操作求解器和计划执行器等。当然这种分类并不严格。&lt;br&gt;  数据最后一定是存放在磁盘的文件中。因此这个查询执行引擎要和文件打交道，于是就有了文件访问接口，也就是文件存取方法接口。但是怎么样能避免I/O给系统带来的影响呢？把数据缓存到内存中操作，并且通过一些比较靠谱的机制保证这些数据不会因为系统断电丢失，或者说不会因为断电导致数据不一致。因此我们就需要缓存管理器。&lt;br&gt;  这些数据文件存放的是单个文件还是多个文件，我们需要一个磁盘空间管理器。怎么管理磁盘空间，怎么组织文件为一个文件还是多个文件等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.一个关系型数据库管理系统必然会面临以下几个问题：&lt;/strong&gt;&lt;br&gt;数据一致性、提供事务机制、提高性能等。&lt;br&gt;事务：事务就是 管理并发过程中，万一出现问题怎么办的。&lt;br&gt;ACID&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A: 原子性&lt;/li&gt;
&lt;li&gt;C: 一致性&lt;/li&gt;
&lt;li&gt;I：隔离性&lt;/li&gt;
&lt;li&gt;D：持久性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;隔离：隔离级别&lt;/strong&gt;    ——隔离事务，自上而下，级别越来越高。不同的数据库管理系统，必须有一个默认的事务隔离级别的。很多的关系型数据库，其默认隔离级别都是第二个读提交，这样性能会好一点。而MySQL是第三个可重读的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交：read uncommitted&lt;/li&gt;
&lt;li&gt;读提交：  read committed&lt;/li&gt;
&lt;li&gt;可重读：  repeatable read&lt;/li&gt;
&lt;li&gt;串行化：  serializable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;机械式硬盘：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随机读写&lt;/li&gt;
&lt;li&gt;顺序读写      &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种方式对内存而言没什么影响，但是对机械硬盘来讲就不一样了。很多时候对数据的写操作都是随机的，性能非常差。为了避免这种情况，所有的写操作先在内存中完成，也就是在缓存中完成。也就是说当需要写入数据时不是直接往数据库文件上写的，而是往日志中写。也就是说日志是补充性的存储空间，通常还不止一个，可能是一组。当你执行写操作时，不管你是往哪个数据库中写的，也无论你写的是什么，都先往日志文件上写，这个日志文件通常是大小固定的，在磁盘上有连续的存储空间。所以缓存管理器一旦缓存1秒钟的数据，或者一旦有个事务提交了，先把这个数据放到日志文件中。因为日志文件是连续的存储空间，所以存起来速度快多了。&lt;strong&gt;但是这有个前提，写的是事务日志。&lt;/strong&gt;日志文件会定期向磁盘上数据文件同步。同步完日志文件里的数据就清掉了。这些事务日志很重要，通常放在有硬件冗余的设备上。这就是通过事务日志把随机I/O转换成顺序I/O以提高用户体验的。&lt;br&gt;日志分为事务日志和历史日志。&lt;/p&gt;
&lt;p&gt;【考虑一种场景】：&lt;br&gt;万一事务走了一半，它里面有80个语句都发生了写操作，已经执行了50个，这50可能会导致一个日志文件存不下，日志文件中的某些数据已经存到磁盘中的数据文件中去了，这个时候服务器进程崩溃了，或者系统断电了，下次启动起来后，这个事务其实并没有完成，怎么办呢？应该撤回才对。事务本身有两种状态：提交/未提交。把这些未完成的事务都回滚回去，因此需要一个恢复管理器。恢复管理器不需要用户手动参与，下次开机以后会自动发现哪些事务提交了，还在日志文件中，它会把这些数据同步到磁盘文件中。而那些未提交的事务都回滚到事务执行前的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;索引：&lt;/strong&gt;将数据库中表的某个字段抽取出来创建成索引，这个一般是排好序的。&lt;strong&gt;索引怎么存呢？树状结构，B树。索引可能有n种数据格式，看场景。对于MySQL而言，通常是B树索引，但也有空间索引。&lt;/strong&gt;微信可以摇一摇，它开始找离你比较近的，你想过这个问题没有？什么人，在哪个数据库中找，怎么标注他是离你比较近的？这必须要根据你的空间地址位置。要计算你当前所在位置，然后根据距离做测算。所以索引有很多种存储机制。&lt;br&gt;    如果索引查询到，文件依然很大，可能有2G，所以还需要对索引在索引。所以索引有很多种类型。&lt;/p&gt;
&lt;h2 id=&quot;数据库范式&quot;&gt;&lt;a href=&quot;#数据库范式&quot; class=&quot;headerlink&quot; title=&quot;数据库范式&quot;&gt;&lt;/a&gt;数据库范式&lt;/h2&gt;&lt;p&gt;数据库设计遵循数据库范式。&lt;br&gt;&lt;strong&gt;RDMBS设计范式：&lt;/strong&gt;&lt;br&gt;设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。&lt;br&gt;目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴德斯科范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) 第一范式（1NF）&lt;/strong&gt;&lt;br&gt;    所谓第一范式（1NF）是指在关系模型中，对域(指的是字段)添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。&lt;br&gt;【说明】：在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) 第二范式(2NF)&lt;/strong&gt;&lt;br&gt;    第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或记录必须可以被唯一地区分。选取一个能区分每个实体的属性或属性组，作为实体的唯一标识。&lt;br&gt;    第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3) 第三范式（3NF）&lt;/strong&gt;&lt;br&gt;    第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个关系中不包含已在其它关系已包含的非主关键字信息。简而言之，第三范式就是属性不依赖于其它非主属性，也就是在满足2NF的基础上，任何非主属性不得传递依赖于主属性。&lt;/p&gt;
&lt;p&gt;【总结】:关系型数据库设计前三范式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字段的原子性&lt;/li&gt;
&lt;li&gt;主键&lt;/li&gt;
&lt;li&gt;非主属性不允许重复&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQL&lt;/h2&gt;&lt;p&gt;SQL: 是一种规范。早期只提供C/C++的API，后来IBM公司的一个研究员率先为关系型数据库引入SQL接口这种机制，这种规范，在后来，其他的关系型数据库都纷纷引入了SQL机制。这就像shell一样，bash、csh、ksh、zsh使用方式不尽相同，但是命令机制命令语法都是一样的。ANSI指定标准。&lt;br&gt;   SQL-86， SQL-89， SQL-92， SQL-99， SQL-03&lt;br&gt;MySQL遵循的是SQL-99。MySQL支持XML。&lt;/p&gt;
&lt;p&gt;关系数据库的约束：&lt;br&gt;    主键约束，外键约束，惟一键约束，条件约束，非空约束。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近开始做报表，于是把之前学习的mysql相关知识整理回顾下，温故而知新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h2&gt;&lt;p&gt;程序=指令+数据&lt;br&gt;    指令是CPU能够逐条解析运行的命令，CPU运行指令的主要目的是处理数据的。其实对于CPU所能够执行的程序，无论是指令还是数据都在内存当中。
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>基于Keepalived实现Nginx高可用</title>
    <link href="http://yoursite.com/2018/02/05/%E5%9F%BA%E4%BA%8EKeepalived%E5%AE%9E%E7%8E%B0Nginx%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/02/05/基于Keepalived实现Nginx高可用/</id>
    <published>2018-02-05T09:07:21.000Z</published>
    <updated>2018-03-01T09:16:13.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;高可用集群介绍&quot;&gt;&lt;a href=&quot;#高可用集群介绍&quot; class=&quot;headerlink&quot; title=&quot;高可用集群介绍&quot;&gt;&lt;/a&gt;高可用集群介绍&lt;/h2&gt;&lt;p&gt;前面介绍的Nginx可以实现对后端服务的负载均衡，Nginx就是调度器。但是我们还要考虑一个，调度器本身在工作的时候仍然会有一个风险，因为我们把整个站点的请求的依赖性都建立在了调度器上，调度器坏了怎么办？&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;只要是设备，都有可能会损坏。它一挂，整个服务器集群就挂了，我们不能允许这情况出现。怎么办？做一个备用的调度器，只是备用。随时监控祝调度器的心跳，只要它挂了就接替。调度器本身也是个服务，怎么工作成调度器。把主调度器的地址夺过来，自身启动调度服务，由它来负责调度。主调度器通过网络连接把自己的心跳信息随时向外传输，只要辅调度器能收到。这也是一种集群，高可用集群（HA，High Availability）。但是高可用集群必然有一台空闲着，资源浪费。&lt;br&gt;负载均衡集群具有高可用能力(但不是高可用集群)，因为比如说用户请求被分发到第三台服务器上，而这时候第三台挂了，调度器只需要重新分发请求到好的服务器上就可以了。&lt;br&gt;HA集群，每一个主节点(就是指服务器)需要向其他节点通知自己的心跳信息，但是LB集群的节点是没有的。所以LB集群具有高可用能力，而这个能力不是依赖于后面的服务器的，而是依赖于前端服务器调度的。现在的问题是如果前端服务器不知道这第三台服务器挂了依然将用户请求分发至第三台怎么办？这种机制称为后端服务器的健康状况检查。检查好了到坏了，也检查坏的到好的。一般说来前端主机都应该具备这样的能力，这才是一个正常情况下的负载集群。&lt;br&gt;负载均衡集群是以提高服务的并发处理能力为根本着眼点的，而高可用集群是以提供服务始终在线能力为根本着眼点的，它不管你能应付多个个请求，但是一定要让你随时在线，不会因为宕机而使服务不用用了。&lt;br&gt;如何衡量一个服务的可用性？服务正常在线时间/(正常在线时间+故障处理时间)=可用性。&lt;/p&gt;
&lt;h2 id=&quot;实现高可用集群的一些开源方案&quot;&gt;&lt;a href=&quot;#实现高可用集群的一些开源方案&quot; class=&quot;headerlink&quot; title=&quot;实现高可用集群的一些开源方案&quot;&gt;&lt;/a&gt;实现高可用集群的一些开源方案&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;heartbeat&lt;/li&gt;
&lt;li&gt;corosync(openais分裂出来的一个项目)&lt;/li&gt;
&lt;li&gt;cman&lt;/li&gt;
&lt;li&gt;keepalived&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面的3套组件工作模式基本都是相同的，keepalived则不相同。keepalived最初的诞生是为了给ipvs提供高可用性。而ipvs说白了就是内核中的一些规则而已，keepalived最初的主要目的就是能够自己调用ipvs的adm命令来生成规则，并且能够自动实现将用户所请求的访问地址转移到其他节点上实现的。&lt;/p&gt;
&lt;h2 id=&quot;Keepalived介绍&quot;&gt;&lt;a href=&quot;#Keepalived介绍&quot; class=&quot;headerlink&quot; title=&quot;Keepalived介绍&quot;&gt;&lt;/a&gt;Keepalived介绍&lt;/h2&gt;&lt;p&gt;对于Master和Backup来讲，Master这个节点会不停的向另外一个节点通告自己的心跳，但是通告机制是基于VRRP协议实现的，backup一旦接收不到主节点的心跳，就会把vip资源抢过来。而在backup节点，只需要把本地keepalived中那个生效的服务中某一个模块，把它生效起来就可以了。所以keepalived自身是模块化设计的，它有着诸多模块，有些模块就是去监控并生效ipvs规则的。而且keepalived还可以实现后端realserver的健康状况检查。&lt;br&gt;    虽然一开始是为了ipvs提供高可用，但是后来慢慢发展到可以为其他的服务提供高可用，比如对轻量级的调度器haproxy和nginx提供高可用。但是需要自己创建额外的脚本来实现。站在这个角度来讲，keepalived的核心大概是这个样子的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1.vrrp的实现&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2.跟vrrp相关的一些配置virtual server&lt;/strong&gt;   ——针对的是ipvs。&lt;br&gt;比如：基于vrrp所谓通告机制之上的对于其他资源的控制：比如对于虚拟服务器的控制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3.vrrp_script：&lt;/strong&gt;vrrp能够调用外部脚本的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说白了，keepalived就是vrrp协议的实现。&lt;strong&gt;vrrp：虚拟冗余路由协议。&lt;/strong&gt;为什么需要这个协议？比如说，公司有个局域网，有很多很多客户机，这些客户机都需要访问互联网或者其他网络的主机，要想和非本网段的主机通信都需要网关，但是一旦这个网关挂了怎么办？那所有非同网段的都访问不了了。那么如何去实现网关的可用性呢？第一种是让客户端自己发现问题，如果他发现上不了网了，我们在前面提供两个网关，这两个网关之间没有任何心跳信息传递，反正告诉客户端有两网关，其中一个不可用了自己改成另一个网关。第二种：在每一个主机上配置动态路由协议，让主机自动生成路由表。但是我们把pc机上的操作系统都配置为支持动态路由协议，这不是一件小工作。第三种：使用ARP网关。在每个主机上装一个ARP客户端，在前面的路由上装好ARP服务器端，那ARP客户端会自行去判定哪个可以用，哪个不可以用。这三种办法都需要依赖于客户端主机自身去做一些配置，才能保证其可用性。VRRP能够把两个网关虚拟成一个网关来使用，简单来讲，在两个网关前面抹上一层协议，这两个路由器之间可以通过选举决定谁是当前活动节点。一般情况下，只有一个是活动节点。&lt;strong&gt;【注意】:vrrp的ip地址是虚拟的，连mac地址也是虚拟的。vrrp协议专门生成了一段虚拟的mac地址来使用。所以这个活动节点拿到的不仅是是vip，还有vmac地址。&lt;/strong&gt;所以客户端网关地址指向vip就可以了，无论实际上是哪个网关对客户端来讲是透明的。&lt;br&gt;很多路由设备都是支持vrrp协议的，像华为的等。因为vrrp是个开放式协议，几乎所有的厂商生产的设备都能够支持。那keepalived就是在Linux操作系统上实现了vrrp。比如说我们想用keepalived实现对nginx的高可用，不仅需要转移vip，还需要将相应节点上的nginx服务启动起来，同时还要监控本机上的nginx服务。&lt;/p&gt;
&lt;h2 id=&quot;keepalived架构&quot;&gt;&lt;a href=&quot;#keepalived架构&quot; class=&quot;headerlink&quot; title=&quot;keepalived架构&quot;&gt;&lt;/a&gt;keepalived架构&lt;/h2&gt;&lt;p&gt;在一个节点上，会启动一个主进程。一般来讲，在一个主进程下会生成两个子进程。一个是用来实现VRRP，另外一个是实现Checkers，检查服务可用性。【注意】:这里提供的check是对ipvs后端realserver的健康状态监测，而我们去监控服务的健康状况则需要自己写脚本。只不过我们仍然把这些脚本归类于checkers。&lt;br&gt;    还有其他的组件，比如：I/O复用器、内存管理组件。还有最左边的是配置文件分析器，这个就是主进程，读取keepalived核心配置文件，分析主配置文件，生效主配置文件，并指挥这两个子进程工作。&lt;br&gt;    WatchDog：是Linux内核中的一个模块，它也是一个计时器，它可以帮助主进程去盯着这两个子进程。主进程并不负责具体的工作，所有的具体工作都是由子进程完成的。这两个子进程任何一个挂了，keepalived就不完整了。keepalived启动以后，这两个子进程每隔两秒钟定期的向主进程打开的unix套接字文件写数据，就是发心跳信息。万一哪一个子进程不再发了，那么主进程就认为子进程挂了，然后去重启这个子进程。基于watchdog监控子进程。&lt;br&gt;    看图中，官方给的图就说明主要是为ipvs提供高可用的，所以配置文件中的一大部分都是定义跟ipvs相关的配置。如果我们不用ipvs，这些配置大多都用不着。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/23.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;对于想要实现对nginx等服务的高可用，使用keepalived实现vrrp协议还不够，因为我们只转移VIP和VMAC，还需要监控和转移服务。有了chechers，我们就可以自己写一个脚本，这个checkers基于脚本调用每隔1秒钟或者两秒钟就来检查这个服务本身状态是否正常，比如取检查status，一旦得不到running信息，可以先重启这个服务。重启之后还不running就转移。怎么转移啊？vrrp是基于什么机制转移的？此时心跳信息依然正常的，并不是不通告心跳了，这个场景下心跳信息是正常的。此时就不能抢了，这个场景下的转移，依靠每个节点的优先级。优先级是从0-255。一般0和255不用，它们有特殊的用法。数字越大优先级越高。因此我们可以这么来定义，首先上来定义两个物理路由的优先级一大一小，比如100和99。一启动，100那个肯定是主的，99那个是从的。这个选举是通过比较物理路由的优先级的。每个节点上线都是backup，就比如一上来，大家都是村民，等人到齐了，就通过比较优先级选举村长。但是如果某个节点上线等了半天，其他节点不来，于是可以自认为自己是最高优先级的节点。这么个场景：100的那个节点服务已经挂了，脚本里重启服务也不行，但是心跳信息是好的，99那个又抢占不了，怎么办？这就是checkers的作用了，我们可以在检测到服务故障以后，人为的把当前节点的优先级降低，这样99那个就能依靠优先级高抢占VIP资源，然后尝试在99节点上启动服务。如何启动服务需要我们自己去写脚本。&lt;br&gt;    VIP资源转移，我们管理员应该知晓这些转移情况，所以还应该有一个通知机制。万一某个节点发生了故障，应该尽可能早的给管理员发封邮件。你如果配置了有邮件服务器的话，这样节点上资源发生转移的时候会收到邮件通知的。&lt;br&gt;    keepalived的转移速度和监控是非常轻量级的，尤其是对于那些用不着共享存储的、节点非常少的场景等应用的。但是对keepalived来讲，支不支持多节点呢？支持多个节点。但是对于同一组服务来讲，只能有一个节点是活动的，因为VIP和VMAC只能在一个节点上运行。所以是一主多从的模式，但是这种模式下，从越多，浪费越大。其实我们可以这样来做，让两个节点都活动起来。很简单，在两个节点上运行两组服务，一组服务是不可能的。在两个物理路由的基础上做两组虚拟路由。&lt;br&gt;如果说keepalived实现nginx的高可用，弄了两个vip，两台机器A和B都有Nginx服务，如何让用户访问到两个不同的节点呢？现在两个节点都是活动的，两个节点上nginx服务都在运行。而客户端端访问的时候只能访问一个，怎么能让客户端访问两个？&lt;strong&gt;使用DNS的两条A记录。&lt;/strong&gt;不同的用户解析的结果是不同的主机，我们并不要求绝对的均衡，因此这里nginx提供的是轻量级的反向代理，nginx本身不是提供web服务的。如果是web服务的话，最好就不要使用这种方案了。由此，两个nginx都能正常工作，都能分发用户请求到后端的上游服务器上去。&lt;br&gt;    基于DNS的转发，用户请求被解析的结果在一段时间内会缓存下来的，请求所访问的是同一个nginx。这就是分担负载模型的VRRP机制。基于这个机制，比如说你有3个节点，那就定义3组虚拟路由，其中每一组中，一个是组的，其他两个是备的。但是这多组虚拟路由之间不能干扰。如何让同一组物理路由设备上的不同虚拟路由呢？所以VRRP必须提供一套完善的管理机制。简单来讲，每一组虚拟路由得有自己独有的标识，称为虚拟路由VRID，虚拟路由id号。&lt;br&gt;    还有一个问题，如果有人知道你这做了高可用，他拿来一个主机放在这，并且配置好了vrrp协议，请问这个主机是否有机会成为主节点呢？之前讲其他的高可用集群解决方案时提到不可以让别人的节点随意加到集群中来，那么怎么解决这个问题？要通过认证来解决。VRRP的认证支持两种认证机制，明文字符串认证和MD5、SSHA-1散列认证。明文字符串认证是指各节点间配置好共享域密钥。散列认证配置起来麻烦一点。&lt;br&gt;    keepalived核心就是VRRP，能把VRRP玩转，服务可以通过写脚本，明白是怎么调用脚本的就可以了。如果需要对VRRP有个详细的了解，请搜索H3C的VRRP技术白皮书或者华为的。&lt;/p&gt;
&lt;h2 id=&quot;安装配置Keepalived&quot;&gt;&lt;a href=&quot;#安装配置Keepalived&quot; class=&quot;headerlink&quot; title=&quot;安装配置Keepalived&quot;&gt;&lt;/a&gt;安装配置Keepalived&lt;/h2&gt;&lt;h3 id=&quot;环境信息&quot;&gt;&lt;a href=&quot;#环境信息&quot; class=&quot;headerlink&quot; title=&quot;环境信息&quot;&gt;&lt;/a&gt;环境信息&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;服务名称&lt;/th&gt;
&lt;th&gt;操作系统版本&lt;/th&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;角色&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;vip&lt;/td&gt;
&lt;td&gt;CentOS 7.0&lt;/td&gt;
&lt;td&gt;10.108.72.112&lt;/td&gt;
&lt;td&gt;JDK1.7、elasticsearch-2.2.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Nignx1、Keepalived&lt;/td&gt;
&lt;td&gt;CentOS 6.5&lt;/td&gt;
&lt;td&gt;10.108.72.110&lt;/td&gt;
&lt;td&gt;Master&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Nignx2、Keepalived&lt;/td&gt;
&lt;td&gt;CentOS 6.5&lt;/td&gt;
&lt;td&gt;10.108.72.110&lt;/td&gt;
&lt;td&gt;Backup&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;Nginx安装&quot;&gt;&lt;a href=&quot;#Nginx安装&quot; class=&quot;headerlink&quot; title=&quot;Nginx安装&quot;&gt;&lt;/a&gt;Nginx安装&lt;/h3&gt;&lt;p&gt;关于Nginx的安装，参见前面的博客，这里不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;安装Keepalived&quot;&gt;&lt;a href=&quot;#安装Keepalived&quot; class=&quot;headerlink&quot; title=&quot;安装Keepalived&quot;&gt;&lt;/a&gt;安装Keepalived&lt;/h3&gt;&lt;p&gt;可以rpm安装，也可以源码安装，我这里选择了源码安装。&lt;br&gt;将keepalived-1.2.15.tar.gz上传到/opt/soft目录下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[nginx@master soft]# tar  -zxvf keepalived-1.2.15.tar.gz
[nginx @master soft]# ./configure --prefix=/opt/keepalived
[nginx @master soft]# make &amp;amp;&amp;amp; make install
[nginx @master soft]# cp /opt/keepalived/etc/rc.d/init.d/keepalived  /etc/rc.d/init.d/
[nginx @master soft]# cp /opt/keepalived/etc/sysconfig/keepalived  /etc/sysconfig/
[nginx @master soft]# mkdir /etc/keepalived
[nginx @master soft]# cp /opt/keepalived/etc/keepalived/keepalived.conf  /etc/keepalived/
[nginx @master soft]# cp /opt/keepalived/sbin/keepalived  /usr/sbin/
[nginx @master soft]#mkdir  /opt/keepalived/log
[nginx @master soft]#mkdir  /opt/keepalived/scripts
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;配置Keepalived&quot;&gt;&lt;a href=&quot;#配置Keepalived&quot; class=&quot;headerlink&quot; title=&quot;配置Keepalived&quot;&gt;&lt;/a&gt;配置Keepalived&lt;/h3&gt;&lt;p&gt;将提供的主、从keepalived.conf配置文件拷贝到/etc/keepalived目录下，参考配置文件中的配置项说明调整配置文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Master上的Keeplived配置文件，keepalived.conf&lt;/strong&gt;&lt;br&gt;    ! Configuration File for keepalived&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;global_defs {
        router_id LVS_DEVEL    
        #负载均衡器标识，同一网段内，可以相同
}

vrrp_script chk_nginx {    
        #调用定义的检测模块
        script &amp;quot;/opt/keepalived/scripts/check_nginx.sh&amp;quot;
        interval 2
        weight 2
}

vrrp_instance VI_1 {
    #设置为主
    state MASTER
    #监控网卡 
    interface eth0
    #主备服务器必须一样       
    virtual_router_id 51
    #权重值MASTER 一定要高于备用机器
    priority 101
    # MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒     
    advert_int 1         

    track_script {
           chk_nginx
    }

    cast_src_ip  10.108.72.110

    unicast_peer {
        10.108.72.111
    }

    authentication {
         #加密
        auth_type PASS
        #加密密码，主备要一致       
        auth_pass fudan123  
    }
    virtual_ipaddress {
       #虚拟IP 
        10.108.72.112      
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.backup上的Keeplived配置文件，keepalived.conf&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;! Configuration File for keepalived

global_defs {
        #负载均衡器标识，同一网段内，可以相同
        router_id LVS_DEVEL
}

#调用定义的检测模块
vrrp_script chk_nginx {
       #检查脚本
        script &amp;quot;/etc/keepalived/scripts/check_nginx.sh&amp;quot;
        #检查时间间隔 
        interval 2
        weight 2
}

vrrp_instance VI_1 {
    #设置为备
    state BACKUP
    #监控网卡        
    interface eth0
    #主备服务器必须一样
    virtual_router_id 51
    #权重值 BACKUP 一定要低于 MASTER
    priority 100
    # MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒   
    advert_int 1        

    track_script {
        chk_nginx
    }
    #多播的源IP，设置为本机IP
    cast_src_ip  10.108.72.111

    unicast_peer {
        10.108.72.110
    }
    authentication {
        auth_type PASS
        auth_pass fudan123
    }
    virtual_ipaddress {
        #虚拟IP
        10.108.72.112
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Keepalived监控脚本&quot;&gt;&lt;a href=&quot;#Keepalived监控脚本&quot; class=&quot;headerlink&quot; title=&quot;Keepalived监控脚本&quot;&gt;&lt;/a&gt;Keepalived监控脚本&lt;/h3&gt;&lt;p&gt;将提供的keepalived监控脚本分别拷贝到主、从服务器的/opt/keepalived/scripts目录下，并将脚本设置为可执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Master机器的监控脚本&lt;/strong&gt;&lt;br&gt;check_nginx.sh&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#!/bin/bash&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;counter=$(ps -C nginx --no-heading|wc -l)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if [ &amp;quot;$&amp;#123;counter&amp;#125;&amp;quot; = &amp;quot;0&amp;quot; ]; then&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        service nginx start&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        counter=$(ps -C nginx --no-heading|wc -l)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if [ &amp;quot;$&amp;#123;counter&amp;#125;&amp;quot; = &amp;quot;0&amp;quot; ]; then&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         /etc/init.d/keepalived stop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        fi&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fi&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2.Backup机器的监控脚本&lt;/strong&gt;&lt;br&gt;check_nginx.sh&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#!/bin/bash&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;counter=$(ps -C nginx --no-heading|wc -l)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if [ &amp;quot;$&amp;#123;counter&amp;#125;&amp;quot; = &amp;quot;0&amp;quot; ]; then&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;         service nginx start&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        counter=$(ps -C nginx --no-heading|wc -l)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if [ &amp;quot;$&amp;#123;counter&amp;#125;&amp;quot; = &amp;quot;0&amp;quot; ]; then&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                /etc/init.d/keepalived stop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        fi&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;fi&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Keepalived启动、关闭&quot;&gt;&lt;a href=&quot;#Keepalived启动、关闭&quot; class=&quot;headerlink&quot; title=&quot;Keepalived启动、关闭&quot;&gt;&lt;/a&gt;Keepalived启动、关闭&lt;/h3&gt;&lt;p&gt;1.将Keepalived加入系统服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chkconfig  --add keepalived
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.设置为开机自启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;chkconfig keepalived on
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.启动、关闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service keepalived start/stop
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;测试Nginx高可用&quot;&gt;&lt;a href=&quot;#测试Nginx高可用&quot; class=&quot;headerlink&quot; title=&quot;测试Nginx高可用&quot;&gt;&lt;/a&gt;测试Nginx高可用&lt;/h3&gt;&lt;p&gt;1.在主服务器（10.108.72.110）测试与备服务器连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tcpdump -vvv  -i ens160 host  10.108.72.111
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.在备服务器（10.108.72.111）测试与主服务器连接&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tcpdump -vvv  -i ens160 host  10.108.72.110
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.先是两台都开启keepalived，然后通过VIP（10.108.72.112）访问；&lt;br&gt;4.再关掉第一台的keepalived，再通过VIP（10.108.72.112）访问，看看能否访问。&lt;/p&gt;
&lt;h3 id=&quot;查看VIP在哪台机器上&quot;&gt;&lt;a href=&quot;#查看VIP在哪台机器上&quot; class=&quot;headerlink&quot; title=&quot;查看VIP在哪台机器上&quot;&gt;&lt;/a&gt;查看VIP在哪台机器上&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;ip addr show
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;高可用集群介绍&quot;&gt;&lt;a href=&quot;#高可用集群介绍&quot; class=&quot;headerlink&quot; title=&quot;高可用集群介绍&quot;&gt;&lt;/a&gt;高可用集群介绍&lt;/h2&gt;&lt;p&gt;前面介绍的Nginx可以实现对后端服务的负载均衡，Nginx就是调度器。但是我们还要考虑一个，调度器本身在工作的时候仍然会有一个风险，因为我们把整个站点的请求的依赖性都建立在了调度器上，调度器坏了怎么办？
    
    </summary>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置HTTPS</title>
    <link href="http://yoursite.com/2018/01/30/Nginx%E9%85%8D%E7%BD%AEHTTPS/"/>
    <id>http://yoursite.com/2018/01/30/Nginx配置HTTPS/</id>
    <published>2018-01-30T04:24:12.000Z</published>
    <updated>2018-01-31T11:06:19.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;HTTPS简介&quot;&gt;&lt;a href=&quot;#HTTPS简介&quot; class=&quot;headerlink&quot; title=&quot;HTTPS简介&quot;&gt;&lt;/a&gt;HTTPS简介&lt;/h2&gt;&lt;p&gt;1.https简介&lt;br&gt;HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.https协议原理&lt;br&gt;首先，客户端与服务器建立连接，各自生成私钥和公钥，是不同的。服务器返给客户端一个公钥，然后客户端拿着这个公钥把要搜索的东西加密，称之为密文，并连并自己的公钥一起返回给服务器，服务器拿着自己的私钥解密密文，然后把响应到的数据用客户端的公钥加密，返回给客户端，客户端拿着自己的私钥解密密文，把数据呈现出来。&lt;/p&gt;
&lt;h3 id=&quot;TLS-SSL&quot;&gt;&lt;a href=&quot;#TLS-SSL&quot; class=&quot;headerlink&quot; title=&quot;TLS/SSL&quot;&gt;&lt;/a&gt;TLS/SSL&lt;/h3&gt;&lt;p&gt;TCP/IP的4层模型：最底层物理层、网络层、传输层、应用层。&lt;br&gt;OSI7层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。&lt;br&gt;以TCP/IP层为例，哪一层可以实现数据的加密和解密？在TCP层和应用层之间引入了半个层，并且称这半个层位为SSL。可以这么理解，把SSL当成一个库，让上层应用层的某种协议如果在传输数据到TCP层之前调用了SSL的功能，那么这个协议就可以实现加密的功能了。比如说，本来http在应用层封装起来，接下来就要交给应用层了，但是加了SSL层，http在传送给TCP层之前经过SSL进行了一次封装，而SSL本身就是实现数据安全通信的，因此，http变成了https。同样，smtp就变成了smtps，ftp就变成了ftps。众多的应用层的协议都可以通过调用SSL库的功能来实现数据的安全传输的。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/13.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;SSL(Secure Socket Layer,，安全的套接字层)，目前比较流行的是SSLv2、SSLv3。它只是一个库，因此要想实现SSL的功能，只需要在我们系统中提供SSL相关的库文件，就能够将http封装成https，也就意味着可以支持https协议了。http和https是两个不同的协议。但是SSL到底是某一家公司的协议，虽然也是开放的，国际标准化组织就不干了，他们决定研发一个更为开放的，通用的协议，TLS就出现了。&lt;br&gt;TLS(Transport Layer Security，传输层安全)：TLSv1，相当于SSLv3。&lt;/p&gt;
&lt;h3 id=&quot;两台主机间TLS-SSL会话的建立：以http为例&quot;&gt;&lt;a href=&quot;#两台主机间TLS-SSL会话的建立：以http为例&quot; class=&quot;headerlink&quot; title=&quot;两台主机间TLS/SSL会话的建立：以http为例&quot;&gt;&lt;/a&gt;两台主机间TLS/SSL会话的建立：以http为例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;第一步：http是基于TCP的，因此双方在建立会话之前需要3次握手。&lt;br&gt;这是http会话的建立，下面就可以互相通信了。但是有了https后就不是3次握手后直接通信了。&lt;/li&gt;
&lt;li&gt;第二步：双方协商。客户端向服务器端发起请求，双方协商建立SSL会话，比如选择SSL协议的哪个版本、密钥加密算法等等。&lt;/li&gt;
&lt;li&gt;第三步：server端将自己的证书发给客户端。(一般而言客户端都是没有证书的) 。客户端拿到证书后要验证拿到的证书是不是自己信任的机构颁发的，再验证证书完整性。&lt;/li&gt;
&lt;li&gt;第四步：客户端传递加密后的对称密码给服务器端。https的主要作用在于web服务器的数据传递或者称为会话交换通过加密的方式实现的。加密一定要使用对称加密的方式，非对称加密方式速度太慢，既然是对称加密了，就需要对称加密密钥。如何生成这个密码呢？这里不是密钥交换实现的，而是客户端选择生成一个随机的对称密钥。并且将这个密码通过server端的公钥加密后传递给server端。&lt;/li&gt;
&lt;li&gt;第五步：拿着客户端发来的密码给数据加密，并发送给客户端。&lt;br&gt;【注意】:密钥是客户端自己选择的，加密后发送给客户端的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;常用的加解密算法简介&quot;&gt;&lt;a href=&quot;#常用的加解密算法简介&quot; class=&quot;headerlink&quot; title=&quot;常用的加解密算法简介&quot;&gt;&lt;/a&gt;常用的加解密算法简介&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.对称加密：加密和解密使用同样的密码&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DES：数据加密标准，56位的密钥长度。&lt;/li&gt;
&lt;li&gt;3DES：3重DES。&lt;/li&gt;
&lt;li&gt;AES：高级加密标准，Advanced。使用128的密钥。AES192、AES256、AES512。。。&lt;/li&gt;
&lt;li&gt;Blowfish&lt;/li&gt;
&lt;li&gt;IDEA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.单向加密&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MD4&lt;/li&gt;
&lt;li&gt;MD5:128位。指输出长度，不是密钥长度。&lt;/li&gt;
&lt;li&gt;SHA1:160位。SHA192、SHA256、SHA384&lt;/li&gt;
&lt;li&gt;CRC-32：循环冗余校验码。不是加密算法，只是一种校验码机制，提供校验功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3.公钥加密：&lt;/strong&gt;一对密钥，长度也是可以变化的，512、768、1024、2048、4096。。。越长速度越慢。核心：加密/签名。一般不会使用公钥加密来加密数据的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;身份认证（数字签名）&lt;/li&gt;
&lt;li&gt;数据加密&lt;/li&gt;
&lt;li&gt;密钥交换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RSA算法：既能实现加密，也能实现签名。有公开有要钱的。&lt;br&gt;DSA算法：只能实现签名。公开的。&lt;br&gt;ElGamal算法：商业算法，要钱的。&lt;/p&gt;
&lt;p&gt;加密解密需要算法来实现，因此需要一种工具或程序能够在主机上提供算法的实现。在Linux上，不同的加密机制所提供的工具是不同的。比如说，对于能够实现对称加密的工具叫openssl，gpg也可以。&lt;/p&gt;
&lt;h2 id=&quot;OpenSSL&quot;&gt;&lt;a href=&quot;#OpenSSL&quot; class=&quot;headerlink&quot; title=&quot;OpenSSL&quot;&gt;&lt;/a&gt;OpenSSL&lt;/h2&gt;&lt;p&gt;SSL的开源实现。OpenSSL功能非常强大，几乎实现了市面上主流的所有加密算法。OpenSSL是个软件，由3部分组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;libcrpto：通用加密库。提供了各种加密函数。&lt;/li&gt;
&lt;li&gt;libssl：TLS/SSL协议的实现。就是那半层。基于会话的、实现了身份认证、数据机密性、会话完整性的TLS/SSL库。&lt;/li&gt;
&lt;li&gt;openssl：多用途命令行工具。能够实现单向加密、对称加密和非对称加密。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OpenSSL还可实现私有证书颁发机构。为什么要实现私有证书颁发机构？我们很多功能都是建立在证书上，假如说我们买不起证书，我们就想在公司内部实现加密解密，而且我们也不跟外人通信。因此就需要个私有的证书颁发机构。&lt;/p&gt;
&lt;p&gt;查看系统上有没有安装openssl：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rpm -q openssl   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要新版本，去 &lt;a href=&quot;http://www.openssl.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.openssl.org/&lt;/a&gt; 下载编译安装。&lt;br&gt;下面开始建立私有CA，颁发证书，配置Nginx实现HTTPS访问网站。&lt;/p&gt;
&lt;h2 id=&quot;OpenSSL实现私有CA&quot;&gt;&lt;a href=&quot;#OpenSSL实现私有CA&quot; class=&quot;headerlink&quot; title=&quot;OpenSSL实现私有CA&quot;&gt;&lt;/a&gt;OpenSSL实现私有CA&lt;/h2&gt;&lt;h3 id=&quot;环境信息&quot;&gt;&lt;a href=&quot;#环境信息&quot; class=&quot;headerlink&quot; title=&quot;环境信息&quot;&gt;&lt;/a&gt;环境信息&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;操作系统版本&lt;/th&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;安装软件&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;res&lt;/td&gt;
&lt;td&gt;CentOS 7.0&lt;/td&gt;
&lt;td&gt;172.16.7.75&lt;/td&gt;
&lt;td&gt;openssl&lt;/td&gt;
&lt;td&gt;私有CA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;res&lt;/td&gt;
&lt;td&gt;CentOS 7.0&lt;/td&gt;
&lt;td&gt;172.16.7.180&lt;/td&gt;
&lt;td&gt;openresty&lt;/td&gt;
&lt;td&gt;Nginx服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;比如在公司内部模拟实现https，就得给web服务器发一个证书，不用去买，自己做一个。在给自己颁发证书之前，自己先建立一个证书颁发机构。Openssl可以帮你去实现私有CA。首先私有CA自己要有证书。&lt;/p&gt;
&lt;h3 id=&quot;创建私有CA&quot;&gt;&lt;a href=&quot;#创建私有CA&quot; class=&quot;headerlink&quot; title=&quot;创建私有CA&quot;&gt;&lt;/a&gt;创建私有CA&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.生成一对密钥&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@res ~]# cd /etc/pki/CA/ 
[root@res CA]# openssl genrsa -out private/cakey.pem 2048
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/14.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.生成自签发证书&lt;/strong&gt;&lt;br&gt;CA机构也有自己的证书的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@res CA]# openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3655
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/15.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.要想把它扮演成私有CA来使用，还要修改openssl.cnf，新建几个需要的文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@res CA]# cd /etc/pki/tls/
[root@res tls]# vim openssl.cnf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/16.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/17.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.生成几个必备的文件和目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@res tls]# cd /etc/pki/CA/
[root@res CA]# mkdir certs crl newcerts
[root@res CA]# touch index.txt
[root@res CA]# echo 01 &amp;gt; serial
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上是CA的环境准备和密钥生成以及自签证书的过程。别的主机可以到这个CA申请证书。比如说Nginx服务器过来申请证书。&lt;/p&gt;
&lt;h3 id=&quot;Nginx服务器申请证书&quot;&gt;&lt;a href=&quot;#Nginx服务器申请证书&quot; class=&quot;headerlink&quot; title=&quot;Nginx服务器申请证书&quot;&gt;&lt;/a&gt;Nginx服务器申请证书&lt;/h3&gt;&lt;p&gt;以下操作都是在172.16.7.180机器上操作。&lt;br&gt;任何一个应用要想用到证书，它必须要有私钥，因为必须从私钥中提取出公钥，每一种应用都必须有自己的证书。第一步：生成私钥。【注意】：如果生成的密钥长度不合适，可以重新生成导出到同一个文件中就覆盖了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.生成一对密钥&lt;/strong&gt;&lt;br&gt;这里我在生成时对密钥进行了加密&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@res ~]# mkdir /opt/ssl/
[root@res ~]# cd /opt/ssl/
[root@res ssl]# (umask 077; openssl genrsa 2048 &amp;gt; res.key)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/18.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.生成证书签署请求&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@res ssl]# openssl req -new -key res.key -out res.csr
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/19.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;Commone Name一定要是你要授予证书的服务器域名或主机名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.把证书签署请求送给CA机构，CA生成证书&lt;/strong&gt;&lt;br&gt;【注意】:这个请求要发给CA才可以，要让CA去签名才有效。当然在一台主机上就不用了，直接签了。如果不在一台主机上，要发给服务器的，远程传过去。可以传到CA机器的/tmp目录下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;登录上CA机器172.16.7.75：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@res CA]# cd /etc/pki/tls/
[root@res tls]# openssl ca -in /tmp/res.csr -out /tmp/res.crt -days 3650
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/20.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.CA机构将证书返回给申请单位，这里即172.16.7.180机器，我将证书放到/opt/ssl目录下&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置Nginx&quot;&gt;&lt;a href=&quot;#配置Nginx&quot; class=&quot;headerlink&quot; title=&quot;配置Nginx&quot;&gt;&lt;/a&gt;配置Nginx&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.配置Nginx支持http和https共存&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/21.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.如果只需要https，禁止http，配置如下：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/22.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.配置http强制转https&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    listen       80;
    server_name  static.res.com;

    rewrite ^(.*)$  https://$host$1 permanent;

}

server {
    listen       443 ssl;
    server_name  static.res.com;

    ssl on;
    #证书和私钥
    ssl_certificate /opt/ssl/res.crt;
    ssl_certificate_key /opt/ssl/res.key;


    access_log  logs/res.access.log  res;
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【注意】：我这里这个域名是假的，所以需要在客户端（你用哪个机器访问网站，哪台机器就是客户端）编辑hosts文件，配置如下的解析：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;172.16.7.180 static.res.com
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTPS简介&quot;&gt;&lt;a href=&quot;#HTTPS简介&quot; class=&quot;headerlink&quot; title=&quot;HTTPS简介&quot;&gt;&lt;/a&gt;HTTPS简介&lt;/h2&gt;&lt;p&gt;1.https简介&lt;br&gt;HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。
    
    </summary>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx实现TCP负载均衡</title>
    <link href="http://yoursite.com/2018/01/28/Nginx%E5%AE%9E%E7%8E%B0TCP%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2018/01/28/Nginx实现TCP负载均衡/</id>
    <published>2018-01-28T01:45:57.000Z</published>
    <updated>2018-01-28T02:35:15.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;nginx在版本1.9.0以后支持tcp的负载均衡，具体可以参照官网关于模块&lt;a href=&quot;https://nginx.org/en/docs/stream/ngx_stream_core_module.html#tcp_nodelay&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ngx_stream_core_module&lt;/a&gt;的说明。一直以来，Nginx 并不支持tcp协议，所以后台的一些基于TCP的业务就只能通过其他高可用负载软件来完成了，比如Haproxy或者LVS。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;编译Nginx启用ngx-stream-core-module模块&quot;&gt;&lt;a href=&quot;#编译Nginx启用ngx-stream-core-module模块&quot; class=&quot;headerlink&quot; title=&quot;编译Nginx启用ngx_stream_core_module模块&quot;&gt;&lt;/a&gt;编译Nginx启用ngx_stream_core_module模块&lt;/h2&gt;&lt;p&gt;ngx_stream_core_module 这个模块在1.90版本后将被启用。但是并不会默认安装，需要在编译时通过指定 –with-stream 参数来激活这个模块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cd /usr/local/
# wget https://nginx.org/download/nginx-1.12.2.tar.gz
# tar zxf nginx-1.12.2.tar.gz
# cd nginx-1.12.2/
# ./configure --prefix=/usr/local/nginx --with-stream
# make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;配置Nginx负载均衡MySQL&quot;&gt;&lt;a href=&quot;#配置Nginx负载均衡MySQL&quot; class=&quot;headerlink&quot; title=&quot;配置Nginx负载均衡MySQL&quot;&gt;&lt;/a&gt;配置Nginx负载均衡MySQL&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;# cd /usr/local/nginx/conf/
# vim nginx.conf
#user  nobody;
worker_processes  1;

error_log  logs/error.log debug;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;

events {
    worker_connections  1024;
}

stream {
    upstream mysql {
        server 172.16.206.30:3306;
    }
    server {
        listen 3306;
        proxy_connect_timeout 8s;
        proxy_timeout 24h;
        proxy_pass mysql;
    }
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  &amp;apos;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &amp;apos;
                  &amp;apos;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &amp;apos;
                  &amp;apos;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&amp;apos;;

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    gzip  on;

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;stream与http同级别。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;nginx在版本1.9.0以后支持tcp的负载均衡，具体可以参照官网关于模块&lt;a href=&quot;https://nginx.org/en/docs/stream/ngx_stream_core_module.html#tcp_nodelay&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ngx_stream_core_module&lt;/a&gt;的说明。一直以来，Nginx 并不支持tcp协议，所以后台的一些基于TCP的业务就只能通过其他高可用负载软件来完成了，比如Haproxy或者LVS。
    
    </summary>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置详解及优化</title>
    <link href="http://yoursite.com/2018/01/23/Nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/23/Nginx配置详解及优化/</id>
    <published>2018-01-23T07:06:27.000Z</published>
    <updated>2018-04-24T10:27:29.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;上篇博文中介绍了安装部署OpenResty，这篇博文主要记录下Nginx的配置及优化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h2&gt;&lt;p&gt;Nginx的代码是由一个核心和一系列的模块组成, 核心主要用于提供Web Server的基本功能，以及Web和Mail反向代理的功能；&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;还用于启用网络协议，创建必要的运行时环境以及确保不同的模块之间平滑地进行交互。不过，大多跟协议相关的功能和某应用特有的功能都是由nginx的模块实现的。这些功能模块大致可以分为事件模块、阶段性处理器、输出过滤器、变量处理器、协议、upstream和负载均衡几个类别，这些共同组成了nginx的http功能。事件模块主要用于提供OS独立的(不同操作系统的事件机制有所不同)事件通知机制如kqueue或epoll等。协议模块则负责实现nginx通过http、tls/ssl、smtp、pop3以及imap与对应的客户端建立会话。&lt;/p&gt;
&lt;p&gt;Nginx的核心模块为Main和Events，此外还包括标准HTTP模块、可选HTTP模块和邮件模块，其还可以支持诸多第三方模块。Main用于配置错误日志、进程及权限等相关的参数，Events用于配置IO模型，如epoll、kqueue、select或poll等，它们是必备模块。&lt;/p&gt;
&lt;p&gt;Nginx的主配置文件由几个段组成，这个段通常也被称为nginx的上下文，每个段的定义格式如下所示。需要注意的是，其每一个指令都必须使用分号(;)结束，否则为语法错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;section&amp;gt; {
    &amp;lt;directive&amp;gt; &amp;lt;parameters&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;配置文件有哪些&quot;&gt;&lt;a href=&quot;#配置文件有哪些&quot; class=&quot;headerlink&quot; title=&quot;配置文件有哪些&quot;&gt;&lt;/a&gt;配置文件有哪些&lt;/h2&gt;&lt;p&gt;1.主配置文件：nginx.conf&lt;br&gt;2.可以使用include指令引入其他地方的配置文件，比如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include conf.d/*.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.fastcgi的配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fastcgi_params、uwsgi_params
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.配置指令(必须以分号结尾)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Directive  value1 [value2...];

支持使用变量：
    内置变量：由模块引入；
    自定义变量：
        set  variable  value; 

    引用变量：$variable
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;配置文件组织结构&quot;&gt;&lt;a href=&quot;#配置文件组织结构&quot; class=&quot;headerlink&quot; title=&quot;配置文件组织结构&quot;&gt;&lt;/a&gt;配置文件组织结构&lt;/h2&gt;&lt;p&gt;主配置文件结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main block
event {
    ...
}
http {
    ...
    server{
        location{  
            ...          
        }           
    }
}
mail{
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;配置main段&quot;&gt;&lt;a href=&quot;#配置main段&quot; class=&quot;headerlink&quot; title=&quot;配置main段&quot;&gt;&lt;/a&gt;配置main段&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.user USERNAME  [GROUPNAME];&lt;/strong&gt;&lt;br&gt;指定用于运行worker进程的用户和组，如果不设置，默认是nobody。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user  nginx  nginx;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.pid  /PATH/TO/PID_FILE;&lt;/strong&gt;&lt;br&gt;指定nginx进程的pid文件路径，也可以使用默认的。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pid  /var/run/nginx.pid;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3.error_log&lt;/strong&gt;&lt;br&gt;用于配置错误日志，可用于main、http、server及location上下文中；语法格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error_log file | stderr [ debug | info | notice | warn | error | crit | alert | emerg ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error_log  logs/error.log debug;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4.worker_processes&lt;/strong&gt;&lt;br&gt;worker进程是单线程进程。如果Nginx用于CPU密集型的场景中，如SSL或gzip，且主机上的CPU个数至少有2个，那么应该将此参数值设定为与CPU核心数相同；如果负载以IO密集型为主，如响应大量内容给客户端，则worker数应该为CPU个数的1.5或2倍。比如：Nginx所在服务器有2颗CPU，每颗两核，那么可以配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;worker_processes  4; #启动的work线程数
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此参数与Events上下文中的work_connections变量一起决定了maxclient的值：&lt;br&gt;maxclients = work_processes * work_connections&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.worker_cpu_affinity&lt;/strong&gt;&lt;br&gt;通过sched_setaffinity()将worker绑定至CPU上，只能用于main上下文。语法格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;worker_cpu_affinity cpumask ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;worker_processes     4;
worker_cpu_affinity 0001 0010 0100 1000;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;6.worker_priority&lt;/strong&gt;&lt;br&gt;为worker进程设定优先级(指定nice值)，此参数只能用于main上下文中，默认为0；语法格式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;worker_priority number
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;7.worker_rlimit_nofile&lt;/strong&gt;&lt;br&gt;设定worker进程所能够打开的文件描述符个数的最大值。语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;worker_rlimit_nofile number
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;配置Events段&quot;&gt;&lt;a href=&quot;#配置Events段&quot; class=&quot;headerlink&quot; title=&quot;配置Events段&quot;&gt;&lt;/a&gt;配置Events段&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.worker_connections&lt;/strong&gt;&lt;br&gt;设定每个worker所处理的最大连接数，它与来自main上下文的worker_processes一起决定了maxclients的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nginx作为http服务器的时候：
max_clients = worker_processes * worker_connections
nginx作为反向代理服务器的时候：
max_clients = worker_processes * worker_connections/4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.use&lt;/strong&gt;&lt;br&gt;在有着多于一个的事件模型IO的应用场景中，可以使用此指令设定nginx所使用的IO机制，默认为./configure脚本选定的各机制中最适用当前OS的版本。语法格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use [ kqueue | rtsig | epoll | /dev/poll | select | poll | eventport ]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;一个配置示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user nginx;
# the load is CPU-bound and we have 16 cores
worker_processes 16;
error_log logs/error.log debug;
pid logs/nginx.pid;

events {
    use epoll;
    worker_connections 2048;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;配置http段&quot;&gt;&lt;a href=&quot;#配置http段&quot; class=&quot;headerlink&quot; title=&quot;配置http段&quot;&gt;&lt;/a&gt;配置http段&lt;/h2&gt;&lt;p&gt;http上下文专用于配置用于http的各模块，此类指令非常的多，每个模块都有其专用指定，具体请参数&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nginx官方文档关于模块部分的说明&lt;/a&gt;。大体上来讲，这些模块所提供的配置指令还可以分为如下几个类别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端类指令：如client_body_buffer_size、client_header_buffer_size、client_header_timeout和keepalive_timeout等；&lt;/li&gt;
&lt;li&gt;文件IO类指令：如aio、directio、open_file_cache、open_file_cache_min_uses、open_file_cache_valid和sendfile等；&lt;/li&gt;
&lt;li&gt;hash类指令：用于定义Nginx为某特定的变量分配多大的内存空间，如types_hash_bucket_size、server_names_hash_bucket_size和variables_hash_bucket_size等；&lt;/li&gt;
&lt;li&gt;套接字类指令：用于定义Nginx如何处理tcp套接字相关的功能，如tcp_nodelay(用于keepalive功能启用时)和tcp_nopush(用于sendfile启用时)等；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;套接字或主机相关配置&quot;&gt;&lt;a href=&quot;#套接字或主机相关配置&quot; class=&quot;headerlink&quot; title=&quot;套接字或主机相关配置&quot;&gt;&lt;/a&gt;套接字或主机相关配置&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;server {
    &amp;lt;directive&amp;gt; &amp;lt;parameters&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用于定义虚拟主机相关的属性。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    listen PORT; #listen指令监听在不同的端口；
    server_name NAME; #server_name指令指向不同的主机名；
    root /PATH/TO/DOCUMENTROOT;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;1.listen&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;listen address[:port] [default_server] [ssl] [http2 | spdy] 
listen port [default_server] [ssl] [http2 | spdy]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;default_server：设置默认虚拟主机；用于基于IP地址，或使用了任意不能对应于任何一个server的name时所返回站点；&lt;/li&gt;
&lt;li&gt;ssl：用于限制只能通过ssl连接提供服务；&lt;/li&gt;
&lt;li&gt;spdy：SPDY protocol（speedy），在编译了spdy模块的情况下，用于支持SPDY协议；&lt;/li&gt;
&lt;li&gt;http2：http version 2；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.server_name NAME […];&lt;/strong&gt;&lt;br&gt;后可跟一个或多个主机名；名称还可以使用通配符和正则表达式(~)；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先做精确匹配；例如：www.wisedu.com&lt;/li&gt;
&lt;li&gt;左侧通配符；例如：*.wisedu.com&lt;/li&gt;
&lt;li&gt;右侧通配符，例如：www.wisedu.*&lt;/li&gt;
&lt;li&gt;正则表达式，例如：~^.*.wisedu.com$&lt;/li&gt;
&lt;li&gt;default_server &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3.tcp_nodelay on|off;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Syntax:    tcp_nodelay on | off;
Default:    tcp_nodelay on;
Context:    http, server, location
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对keepalive模式下的连接是否使用TCP_NODELAY选项；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.tcp_nopush on|off;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Syntax:    tcp_nopush on | off;
Default:    tcp_nopush off;
Context:    http, server, location
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是否启用TCP_NOPUSH(FREEBSE）或TCP_CORK(Linux)选项；仅在sendfile为on时有用；&lt;br&gt;&lt;strong&gt;tcp_nopush和tcp_nodelay选项：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;先来了解下Nagle算法：&lt;/strong&gt;&lt;br&gt;在网络拥塞控制领域，有一个非常有名的算法叫做&lt;strong&gt;Nagle算法（Nagle algorithm）&lt;/strong&gt;，这是使用它的发明人John Nagle的名字来命名的，John Nagle在1984年首次用这个算法来尝试解决福特汽车公司的网络拥塞问题（RFC 896），该问题的具体描述是：如果我们的应用程序一次产生1个字节的数据，而这个1个字节数据又以网络数据包的形式发送到远端服务器，那么就很容易导致网络由于太多的数据包而过载。比如，当用户使用Telnet连接到远程服务器时，每一次击键操作就会产生1个字节数据，进而发送出去一个数据包，所以，在典型情况下，传送一个只拥有1个字节有效数据的数据包，却要发费40个字节长包头（即ip头20字节+tcp头20字节）的额外开销，这种有效载荷（payload）利用率极其低下的情况被统称之为愚蠢窗口症候群（Silly Window Syndrome）。可以看到，这种情况对于轻负载的网络来说，可能还可以接受，但是对于重负载的网络而言，就极有可能承载不了而轻易的发生拥塞瘫痪。&lt;br&gt;针对上面提到的这个状况，Nagle算法的改进在于：如果发送端欲多次发送包含少量字符的数据包（一般情况下，后面统一称长度小于MSS的数据包为小包，与此相对，称长度等于MSS的数据包为大包，为了某些对比说明，还有中包，即长度比小包长，但又不足一个MSS的包），则发送端会先将第一个小包发送出去，而将后面到达的少量字符数据都缓存起来而不立即发送，直到收到接收端对前一个数据包报文段的ACK确认、或当前字符属于紧急数据，或者积攒到了一定数量的数据（比如缓存的字符数据已经达到数据包报文段的最大长度）等多种情况才将其组成一个较大的数据包发送出去。&lt;br&gt;TCP中的Nagle算法默认是启用的，但是它并不是适合任何情况，对于telnet或rlogin这样的远程登录应用的确比较适合（原本就是为此而设计），但是在某些应用场景下我们却又需要关闭它。&lt;br&gt;Nagle算法是指发送方发送的数据不会立即发出, 而是先放在缓冲区, 等缓存区满了再发出。发送完一批数据后, 会等待接收方对这批数据的回应, 然后再发送下一批数据。Negale 算法适用于发送方需要发送大批量数据, 并且接收方会及时作出回应的场合, 这种算法通过减少传输数据的次数来提高通信效率。如果发送方持续地发送小批量的数据, 并且接收方不一定会立即发送响应数据, 那么Negale算法会使发送方运行很慢. 对于GUI 程序, 如网络游戏程序(服务器需要实时跟踪客户端鼠标的移动), 这个问题尤其突出。客户端鼠标位置改动的信息需要实时发送到服务器上, 由于Negale 算法采用缓冲, 大大减低了实时响应速度, 导致客户程序运行很慢。这个时候就需要使用TCP_NODELAY选项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tcp_nopush&lt;/strong&gt;&lt;br&gt;官方:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tcp_nopush
Syntax: tcp_nopush on | off
Default: off
Context: http, server, location
Reference: tcp_nopush

This directive permits or forbids the use of thesocket options TCP_NOPUSH on FreeBSD or TCP_CORK on Linux. This option is onlyavailable when using sendfile.
Setting this option causes nginx to attempt to sendit’s HTTP response headers in one packet on Linux and FreeBSD 4.x
You can read more about the TCP_NOPUSH and TCP_CORKsocket options here.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;linux 下是tcp_cork，上面的意思就是说，当使用sendfile函数时，tcp_nopush才起作用，它和指令tcp_nodelay是互斥的。tcp_cork是linux下tcp/ip传输的一个标准了，这个标准的大概的意思是，一般情况下，在tcp交互的过程中，当应用程序接收到数据包后马上传送出去，不等待，而tcp_cork选项是数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞。&lt;br&gt;也就是说tcp_nopush = on 会设置调用tcp_cork方法，这个也是默认的，结果就是数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞。&lt;br&gt;以快递投递举例说明一下（以下是我的理解，也许是不正确的），当快递东西时，快递员收到一个包裹，马上投递，这样保证了即时性，但是会耗费大量的人力物力，在网络上表现就是会引起网络堵塞，而当快递收到一个包裹，把包裹放到集散地，等一定数量后统一投递，这样就是tcp_cork的选项干的事情，这样的话，会最大化的利用网络资源，虽然有一点点延迟。&lt;br&gt;对于nginx配置文件中的tcp_nopush，tcp_nopush on;这个选项对于www，ftp等大文件很有帮助。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tcp_nodelay&lt;/strong&gt;&lt;br&gt;TCP_NODELAY和TCP_CORK基本上控制了包的“Nagle化”，Nagle化在这里的含义是采用Nagle算法把较小的包组装为更大的帧。 John Nagle是Nagle算法的发明人，后者就是用他的名字来命名的，他在1984年首次用这种方法来尝试解决福特汽车公司的网络拥塞问题（欲了解详情请参看IETF RFC 896）。他解决的问题就是所谓的silly window syndrome，中文称“愚蠢窗口症候群”，具体含义是，因为普遍终端应用程序每产生一次击键操作就会发送一个包，而典型情况下一个包会拥有一个字节的数据载荷以及40个字节长的包头，于是产生4000%的过载，很轻易地就能令网络发生拥塞,。 Nagle化后来成了一种标准并且立即在因特网上得以实现。它现在已经成为缺省配置了，但在我们看来，有些场合下把这一选项关掉也是合乎需要的。&lt;br&gt;现在让我们假设某个应用程序发出了一个请求，希望发送小块数据。我们可以选择立即发送数据或者等待产生更多的数据然后再一次发送两种策略。如果我们马上发送数据，那么交互性的以及客户/服务器型的应用程序将极大地受益。如果请求立即发出那么响应时间也会快一些。以上操作可以通过设置套接字的TCP_NODELAY = on 选项来完成，这样就禁用了Nagle 算法。&lt;br&gt;另外一种情况则需要我们等到数据量达到最大时才通过网络一次发送全部数据，这种数据传输方式有益于大量数据的通信性能，典型的应用就是文件服务器。应用 Nagle算法在这种情况下就会产生问题。但是，如果你正在发送大量数据，你可以设置TCP_CORK选项禁用Nagle化，其方式正好同 TCP_NODELAY相反（TCP_CORK和 TCP_NODELAY是互相排斥的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.sendfile on|off;&lt;/strong&gt;&lt;br&gt;是否启用sendfile功能；&lt;br&gt;先来看下nginx作为web服务器的工作方式：&lt;br&gt;用户请求进来了，先到达网卡，由内核处理下交给了监听在80套接字上的应用程序，即交给worker进程，这个worker进程通过连接建立、通过接入分析发现用户请求的是一个静态页面，下面就是I/O了。首先进程向内核发出系统调用。内核为它准备一个缓冲，然后内核从磁盘中加载这个文件到缓冲中，然后将这个文件复制给worker进程自己的地址空间，然后进程将这个文件封装成响应报文，这个封装过程是，进程封装http请求首部，然后交给内核封装TCP首部、IP首部，然后交给客户端。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/10.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;然后你会发现这个文件是这么走的：从硬盘到内核空间，从内核到用户空间，从用户空间再到内核空间，白白绕一圈。如果说这个请求直接在内核中就封装好(http请求首部封装其实也是在内核封装的)，这样就避免了两次复制(注意是复制，内核任何时候和进程交互都是复制，除非共享内存)。复制虽然时间短，但是架不住多啊。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/11.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这就是sendfile机制，读过来就响应了。send只支持很小的文件，sendfile64支持更大的文件。&lt;br&gt;现在流行的web 服务器里面都提供 sendfile 选项用来提高服务器性能，那到底 sendfile是什么，怎么影响性能的呢？&lt;br&gt;sendfile实际上是 Linux2.0+以后的推出的一个系统调用，web服务器可以通过调整自身的配置来决定是否利用sendfile这个系统调用。先来看一下不用 sendfile的传统网络传输过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;read(file,tmp_buf, len);
write(socket,tmp_buf, len);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;硬盘 &amp;gt;&amp;gt; kernel buffer &amp;gt;&amp;gt; user buffer&amp;gt;&amp;gt; kernel socket buffer &amp;gt;&amp;gt;协议栈&lt;br&gt;一般来说一个网络应用是通过读硬盘数据，然后写数据到socket 来完成网络传输的。上面2行用代码解释了这一点，不过上面2行简单的代码掩盖了底层的很多操作。来看看底层是怎么执行上面2行代码的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;①系统调用 read()产生一个上下文切换：从 user mode 切换到 kernel mode，然后 DMA 执行拷贝，把文件数据从硬盘读到一个 kernel buffer 里。&lt;/li&gt;
&lt;li&gt;②数据从 kernel buffer拷贝到 user buffer，然后系统调用 read() 返回，这时又产生一个上下文切换：从kernel mode 切换到 user mode。&lt;/li&gt;
&lt;li&gt;③系统调用write()产生一个上下文切换：从 user mode切换到 kernel mode，然后把步骤2读到 user buffer的数据拷贝到 kernel buffer（数据第2次拷贝到 kernel buffer），不过这次是个不同的 kernel buffer，这个 buffer和 socket相关联。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;④系统调用 write()返回，产生一个上下文切换：从 kernel mode 切换到 user mode（第4次切换了），然后 DMA 从 kernel buffer拷贝数据到协议栈（第4次拷贝了）。&lt;br&gt;上面4个步骤有4次上下文切换，有4次拷贝，我们发现如果能减少切换次数和拷贝次数将会有效提升性能。在kernel2.0+ 版本中，系统调用 sendfile() 就是用来简化上面步骤提升性能的。sendfile() 不但能减少切换次数而且还能减少拷贝次数。&lt;br&gt;再来看一下用 sendfile() 来进行网络传输的过程：&lt;/p&gt;
&lt;p&gt;  sendfile(socket,file, len);&lt;br&gt;  硬盘 &amp;gt;&amp;gt; kernel buffer (快速拷贝到kernel socket buffer) &amp;gt;&amp;gt;协议栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;①系统调用sendfile()通过 DMA把硬盘数据拷贝到 kernel buffer，然后数据被 kernel直接拷贝到另外一个与 socket相关的 kernel buffer。这里没有 user mode和 kernel mode之间的切换，在 kernel中直接完成了从一个 buffer到另一个buffer的拷贝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;②DMA 把数据从 kernelbuffer 直接拷贝给协议栈，没有切换，也不需要数据从 user mode 拷贝到 kernel mode，因为数据就在 kernel 里。&lt;br&gt;步骤减少了，切换减少了，拷贝减少了，自然性能就提升了。这就是为什么说在 Nginx 配置文件里打开 sendfile on 选项能提高 web server性能的原因。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/12.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4.gzip  on;&lt;/strong&gt;&lt;br&gt;对于响应用户的内容是不是先压缩再发送，可以节省带宽。如果网络带宽小，用户访问量大的话可以使用这种方式。&lt;/p&gt;
&lt;h3 id=&quot;路径相关的指令&quot;&gt;&lt;a href=&quot;#路径相关的指令&quot; class=&quot;headerlink&quot; title=&quot;路径相关的指令&quot;&gt;&lt;/a&gt;路径相关的指令&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.root&lt;/strong&gt;&lt;br&gt;设置web资源的路径映射；用于指明请求的URL所对应的文档的目录路径；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    ...
    root  /data/www/vhost1;
}
http://www.wisedu.com/images/logo.jpg --&amp;gt; /data/www/vhosts/images/logo.jpg

server {
    ...
    server_name  www.wisedu.com;

    location /images/ {
         root  /data/imgs/;
         ...
    }
}
http://www.wisedu.com/images/logo.jpg --&amp;gt; /data/imgs/images/logo.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.location [ = | ~ | ~* | ^~ ] uri { … }&lt;br&gt;  location @name { … }&lt;/strong&gt;&lt;br&gt;功能：允许根据用户请求的URI来匹配定义的各location，匹配到时，此请求将被相应的location块中的配置所处理；简言之，即用于为需要用到专用配置的uri提供特定配置。&lt;br&gt;&lt;strong&gt;先来看下location [ = | ~ | ~* | ^~ ] uri { … } &lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;location URI{}：对当前路径及所有对象都生效。&lt;/li&gt;
&lt;li&gt;location = URI{}：只对当前路径生效，不包括子路径。这是精确匹配。&lt;/li&gt;
&lt;li&gt;location ~ URI{}：&lt;/li&gt;
&lt;li&gt;location ~&lt;em&gt; URI{}：模式匹配URI，此处的URI可使用正则表达式，~区分字符大小写。~&lt;/em&gt;不区分字符大小写。&lt;/li&gt;
&lt;li&gt;location ^~ URI{}：明确说明不使用正则表达式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【注意】：如果被两个location匹配到，nginx是有优先级的。=优先级最高，^~优先级第二，模式匹配优先级第三，没加任何符号的优先级最低。&lt;br&gt;官方例子：&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#location&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nginx.org/en/docs/http/ngx_http_core_module.html#location&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location = / {
    [ configuration A ]
}

location / {
    [ configuration B ]
}

location /documents/ {
    [ configuration C ]
}

location ^~ /images/ {
    [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ configuration E ]
}
The “/” request will match configuration A, the “/index.html” request will match configuration B, the “/documents/document.html” request will match configuration C, the “/images/1.gif” request will match configuration D, and the “/documents/1.jpg” request will match configuration E.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;补充一个，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location / {
    [ configuration A ]
}
location /abc {
    [ configuration B ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;访问 &lt;a href=&quot;http://ip:port/abc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ip:port/abc&lt;/a&gt; 将被 location /abc 匹配到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再来看下location @name { … }，命名的location&lt;/strong&gt;&lt;br&gt;The “@” prefix defines a named location. Such a location is not used for a regular request processing, but instead used for request redirection. They cannot be nested, and cannot contain nested locations.&lt;br&gt;@：内部服务跳转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
  location /img/ {
    set $memcached_key $uri;
    memcached_pass     name:11211;
    default_type       text/html;
    error_page         404 @fallback; #以 /img/ 开头的请求，如果连接的状态为 404。则会匹配到 @fallback 这条规则上。
  }

  location @fallback {
    proxy_pass http://backend;
  } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3.alias&lt;/strong&gt;&lt;br&gt;定义路径别名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location  /images/ {
    root /data/imgs/;
}

location  /images/  {
    alias /data/imgs/;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;访问/images/test.jpg，对应的结果如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;root指令：给定的路径对应于location的“/”这个URL；&lt;br&gt;/images/test.jpg –&amp;gt;  /data/imgs/images/test.jpg &lt;/li&gt;
&lt;li&gt;alias指令：给定的路径对应于location的“/uri/“这个URL；&lt;br&gt;/images/test.jpg –&amp;gt;  /data/imgs/test.jpg，注意alias把location后配置的路径images丢弃掉了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【注意】：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用alias时，目录名后面一定要加”/“。&lt;/li&gt;
&lt;li&gt;alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。&lt;/li&gt;
&lt;li&gt;alias只能位于location块中。（root可以不放在location中）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4.index&lt;/strong&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;index file ...;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置默认主页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.error_page code … [=[response]] uri;&lt;/strong&gt;&lt;br&gt;根据http的状态码重定向错误页面；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error_page  404  /404.html
error_page  404  =200  /404.html  （以指定的响应状态码进行响应）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;6.try_files file … uri;&lt;br&gt;  try_files file … =code;&lt;/strong&gt;&lt;br&gt;其作用是按顺序检查文件是否存在，尝试查找第1至第N-1个文件，返回第一个找到的文件或文件夹（结尾加斜线表示为文件夹），如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。（必须不能匹配至当前location，而应该匹配至其它location，否则会导致死循环）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location / {
    try_files $uri $uri/ @fallback; # $uri为Nginx内置变量，下面会讲到。
    root   /home/data/FS/desgin_style/;
}

location @fallback {
    proxy_pass_header Server;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Scheme $scheme;

    proxy_pass http://backend;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;客户端请求相关的配置&quot;&gt;&lt;a href=&quot;#客户端请求相关的配置&quot; class=&quot;headerlink&quot; title=&quot;客户端请求相关的配置&quot;&gt;&lt;/a&gt;客户端请求相关的配置&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.keepalive_timeout timeout [header_timeout];&lt;/strong&gt;&lt;br&gt;设定keepalive连接的超时时长；0表示禁止长连接；默认为75s。&lt;br&gt;KeepAlive，意思为是否长连接。如果设置了超时时间，那么在这个时间内，那么当Nginx完成用户的请求后，那么Nginx进程不会断开用户的请求连接，依然保持连接状态。设置成0s则当Nginx完成用户的请求后，那么Nginx进程会立即断开和用户的请求连接。&lt;br&gt;完成用户的请求后，连接依然存在着，这样的好处是：当该用户的请求在过来时，Nginx会用这个已经建立的连接，不需要重新创建连接。这样会节省CPU的资源。但是却耗费了内存。为什么呢？可以假设这样的场景。假如keepalive 超时时间为10s，而每1s中有100个用户请求访问，每个用户3次连接，每个连接耗费2M内存，那么10s内建立的连接次数为1000次（跟用户每s请求次数无关），消耗内存为1000x2=2000M，相反，如果不保持长连接，同样的环境场景下，每1s内有100x3个连接，下一秒还是100x3个连接，也就是说永远都是100x3个连接，那么1s内甚至10s内消耗的内存为100x3x2=600M。 然而，在这10s内创建的连接次数100x3x10=3000次，这样肯定消耗了更多的cpu资源。毕竟每次tcp连接都是需要cpu去处理的。&lt;br&gt;问题来了，既然知道长连接与否的利与弊，那么如何判定什么时候On，什么时候Off？&lt;br&gt;在上面的举例中，涉及到了一个数，那就是每个用户在1s内请求的次数，如果把3改为1，是不是10s内得到的连接次数总和是一样的。那么这样无论是On还是Off，消耗的CPU资源是一样的。所以，我们考虑3种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;①用户浏览一个网页时，除了网页本身外，还引用了多个 javascript 文件，多个 css 文件，多个图片文件，并且这些文件都在同一个 HTTP 服务器上。&lt;/li&gt;
&lt;li&gt;②用户浏览一个网页时，除了网页本身外，还引用一个 javascript 文件，一个图片文件。&lt;/li&gt;
&lt;li&gt;③用户浏览的是一个动态网页，由程序即时生成内容，并且不引用其他内容。&lt;br&gt;对于上面3中情况，我认为：1 最适合打开 KeepAlive ，2 随意，3 最适合关闭 KeepAlive（连接消耗的内存比较大）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下：&lt;br&gt;在内存非常充足的服务器上，不管是否关闭 KeepAlive 功能，服务器性能不会有明显变化；&lt;br&gt;如果服务器内存较少，或者服务器有非常大量的文件系统访问时，或者主要处理动态网页服务，关闭 KeepAlive 后可以节省很多内存，而节省出来的内存用于文件系统Cache，可以提高文件系统访问的性能，并且系统会更加稳定。&lt;br&gt;目前的服务器，CPU很强，所以不用考虑频繁的tcp连接对cpu造成的压力，那还让它长连接干什么，故，建议关闭你的长连接吧！！！&lt;br&gt;PS： 如果，你的服务器上请求量很大，那你最好还是关闭这个参数吧。我试过一次，打开长连接，并且设置超时时间为30s，结果仅仅十几s就把所有的Nginx进程跑满。这样很危险的，直接让用户等待，等30s，这不扯淡嘛？即使是你设置成3s，照样会让用户等待3s，这样很不合理的。所以，归根结蒂还是关闭长连接吧，这样效率会更高。&lt;/p&gt;
&lt;p&gt;举个网上的具体例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.项目环境：nginx（前段代理，仅作代理用途）+3个tomcat（都在同一个服务器上），做的web项目&lt;/li&gt;
&lt;li&gt;2.涉及到的业务逻辑：文件上传（可能有大文件，比如说android游戏，100m）；客户端接口请求；网站后台管理&lt;/li&gt;
&lt;li&gt;3.问题重现流程：&lt;ul&gt;
&lt;li&gt;3.1 配置好tomcat后，直接加上nginx前段代理（仅配置了http代理）&lt;/li&gt;
&lt;li&gt;3.2 问题一：当管理员后台上传文件时，大文件无法上传成功，出现time-out，经重复测试，发现上传时间超过1分钟以后，就会返回超时信息，小文件没有问题&lt;/li&gt;
&lt;li&gt;3.3 经调研得知nginx默认设置的http连接超时时间为75s，超过75s，会断掉当前的http连接，而大文件上传时经常会超过75s，这就导致大文件无法上传成功，当时的解决方案是，设置nginx http连接超时时间为30分钟，即参数keepalive_timeout=1800；文件上传问题基本解决；&lt;/li&gt;
&lt;li&gt;3.4项目运行2天后，发现服务器突然宕机了，重启nginx可以解决问题，但是2个小时后又再次宕机，重启nginx又解决了问题，调研了一个中午，并且查看nginx的错误日志（socket() failed (24: Too many open files) while connecting to upstream），发现问题来源与nginx的连接数（设置的默认值为1024）达到上限&lt;/li&gt;
&lt;li&gt;3.5发现这个问题后，我就想应该把nginx的连接数调大点，于是设置 worker_connections  10240；重启nginx，短时间没有出现问题，但是运行过程中，我再次查看错误日志，发现（socket() failed (24: Too many open files) while connecting to upstream）时不时的出现&lt;/li&gt;
&lt;li&gt;3.6 此时发现调整nginx的连接数并不能完全解决问题，于是google，百度之，发现问题所在，罪魁祸首是：nginx的keepalive_timeout(参看&lt;a href=&quot;http://fengzheng369.blog.163.com/blog/static/752209792012418103813580/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://fengzheng369.blog.163.com/blog/static/752209792012418103813580/&lt;/a&gt; )设置项时间太长，客户端接口访问其实是一个比较快速的过程，访问完成了已经不需要继续使用http连接了，但是由于对nginx的错误配置，导致接口访问完成后http连接并没有被释放掉，所以导致连接数越来越大，最终nginx崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4.那么这个问题应该如何解决呢？&lt;br&gt;将keepalive_timeout时间调小会导致上传操作可能无法完成；调大点的话，许多无效的http连接占据着nginx的连接数。这貌似是一个两难的问题。&lt;br&gt;解决方案一：将接口请求，后台管理，文件上传这三个业务逻辑分开，nginx对这三种业务逻辑分开转发，每个业务逻辑单独设置一个keepalive-timeout(未实验)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2.keepalive_requests number;&lt;/strong&gt;&lt;br&gt;在keepalived连接上所允许请求的最大资源数量；默认为100；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.keepalive_disable none | browser …;&lt;/strong&gt;&lt;br&gt;指明禁止为何种浏览器使用keepalive功能；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.send_timeout #;&lt;/strong&gt;&lt;br&gt;发送响应报文的超时时长，默认为60s; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.client_body_buffer_size size;&lt;/strong&gt;&lt;br&gt;接收客户请求报文body的缓冲区大小；默认为16k；超出此指定大小时，其将被移存于磁盘上；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.client_body_temp_path path [level1 [level2 [level3]]];&lt;/strong&gt;&lt;br&gt;设定用于存储客户端请求body的临时存储路径及子目录结构和数量；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;client_body_temp_path  /var/tmp/client_body  2 2;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;7.client_max_body_size 10m;&lt;/strong&gt;&lt;br&gt;允许客户端请求的最大的单个文件字节数，这个参数可以限制body的大小，默认是1m。如果上传的文件较大，那么需要调大这个参数。&lt;/p&gt;
&lt;h3 id=&quot;对客户端请求的进行限制&quot;&gt;&lt;a href=&quot;#对客户端请求的进行限制&quot; class=&quot;headerlink&quot; title=&quot;对客户端请求的进行限制&quot;&gt;&lt;/a&gt;对客户端请求的进行限制&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1.limit_excpet  METHOD {…}&lt;/strong&gt;&lt;br&gt;对指定范围之外的其它的方法进行访问控制；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;limit_except  GET {
    allow  172.16.0.0/16;
    deny all;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.对客户端限速&lt;/strong&gt;&lt;br&gt;我们经常会遇到这种情况，服务器流量异常，负载过大等等。对于大流量恶意的攻击访问，会带来带宽的浪费，服务器压力，影响业务，往往考虑对同一个ip的连接数，并发数进行限制。下面说说ngx_http_limit_conn_module 模块来实现该需求。该模块可以根据定义的键来限制每个键值的连接数，如同一个IP来源的连接数。并不是所有的连接都会被该模块计数，只有那些正在被处理的请求（这些请求的头信息已被完全读入）所在的连接才会被计数。&lt;br&gt;nginx的限速功能通过limit_zone、limit_conn和limit_rate指令进行配置。首先需要在http上下文配置一个limit_zone，然后在需要的地方使用limit_conn和limit_rate 进行限速设置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;limit_conn_zone&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法: limit_conn_zone $variable zone=name:size;
默认值: none
配置段: http
该指令描述会话状态存储区域。键的状态中保存了当前连接数，键的值可以是特定变量的任何非空值（空值将不会被考虑）。$variable定义键，zone=name定义区域名称，后面的limit_conn指令会用到的。size定义各个键共享内存空间大小。如：

limit_conn_zone $binary_remote_addr zone=addr:10m;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【说明】：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端的IP地址作为键。注意，这里使用的是$binary_remote_addr变量，而不是$remote_addr变量。&lt;/li&gt;
&lt;li&gt;$remote_addr变量的长度为7字节到15字节，而存储状态在32位平台中占用32字节或64字节，在64位平台中占用64字节。&lt;/li&gt;
&lt;li&gt;$binary_remote_addr变量的长度是固定的4字节，存储状态在32位平台中占用32字节或64字节，在64位平台中占用64字节。&lt;/li&gt;
&lt;li&gt;1M共享空间可以保存3.2万个32位的状态，1.6万个64位的状态。如果共享内存空间被耗尽，服务器将会对后续所有的请求返回 503 (Service Temporarily Unavailable) 错误。&lt;/li&gt;
&lt;li&gt;limit_zone 指令和limit_conn_zone指令同等意思，已经被弃用，就不再做说明了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;limit_conn&lt;/strong&gt;&lt;br&gt;语法：limit_conn zone_name number&lt;br&gt;默认值：none&lt;br&gt;配置段：http, server, location&lt;br&gt;指定每个给定键值的最大同时连接数，当超过这个数字时被返回503 (Service Temporarily Unavailable)错误。如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;limit_conn_zone $binary_remote_addr zone=addr:10m;
server {
    location /www.ttlsa.com/ {
        limit_conn addr 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同一IP同一时间只允许有一个连接。&lt;br&gt;当多个 limit_conn 指令被配置时，所有的连接数限制都会生效。比如，下面配置不仅会限制单一IP来源的连接数，同时也会限制单一虚拟服务器的总连接数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;limit_conn_zone $binary_remote_addr zone=perip:10m;
limit_conn_zone $server_name zone=perserver:10m;
server {
    limit_conn perip 10;
    limit_conn perserver 100;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;limit_rate&lt;/strong&gt;&lt;br&gt;语法：limit_rate rate&lt;br&gt;默认值：0&lt;br&gt;配置段：http, server, location, if in location&lt;br&gt;对每个连接的速率限制。参数rate的单位是字节/秒，设置为0将关闭限速。 按连接限速而不是按IP限制，因此如果某个客户端同时开启了两个连接，那么客户端的整体速率是这条指令设置值的2倍。&lt;/p&gt;
&lt;h3 id=&quot;Nginx反向代理配置&quot;&gt;&lt;a href=&quot;#Nginx反向代理配置&quot; class=&quot;headerlink&quot; title=&quot;Nginx反向代理配置&quot;&gt;&lt;/a&gt;Nginx反向代理配置&lt;/h3&gt;&lt;p&gt;Nginx通过proxy模块实现反向代理功能。在作为web反向代理服务器时，nginx负责接收客户请求，并能够根据URI、客户端参数或其它的处理逻辑将用户请求调度至上游服务器上(upstream server)。nginx在实现反向代理功能时的最重要指令为proxy_pass，它能够将location定义的某URI代理至指定的上游服务器(组)上。如下面的示例中，location的/uri将被替换为上游服务器上的/newuri。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /uri {
    proxy_pass http://www.magedu.com:8080/newuri; # 指定将请求代理至upstream server的URL路径；
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;补充：&lt;strong&gt;上游&lt;/strong&gt;，有发源的意思。故上游服务器指的产生内容的服务器。&lt;/p&gt;
&lt;p&gt;不过，这种处理机制中有两个例外。一个是如果location的URI是通过模式匹配定义的，其URI将直接被传递至上游服务器，而不能为其指定转换的另一个URI。例如下面示例中的/forum将被代理为&lt;a href=&quot;http://www.magedu.com/forum。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.magedu.com/forum。&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location ~ ^/bbs {
    proxy_pass http://www.magedu.com;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二个例外是，如果在loation中使用的URL重定向，那么nginx将使用重定向后的URI处理请求，而不再考虑上游服务器上定义的URI。如下面所示的例子中，传送给上游服务器的URI为/index.php?page=&lt;match&gt;，而不是/index。&lt;/match&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location / {
    rewrite /(.*)$ /index.php?page=$1 break;
    proxy_pass http://localhost:8080/index;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;proxy模块的指令&quot;&gt;&lt;a href=&quot;#proxy模块的指令&quot; class=&quot;headerlink&quot; title=&quot;proxy模块的指令&quot;&gt;&lt;/a&gt;proxy模块的指令&lt;/h4&gt;&lt;p&gt;proxy模块的可用配置指令非常多，它们分别用于定义proxy模块工作时的诸多属性，如连接超时时长、代理时使用http协议版本等。下面对常用的指令做一个简单说明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;proxy_connect_timeout：nginx将一个请求发送至upstream server之前等待的最大时长；&lt;/li&gt;
&lt;li&gt;proxy_cookie_domain：将upstream server通过Set-Cookie首部设定的domain属性修改为指定的值，其值可以为一个字符串、正则表达式的模式或一个引用的变量；&lt;/li&gt;
&lt;li&gt;proxy_cookie_path: 将upstream server通过Set-Cookie首部设定的path属性修改为指定的值，其值可以为一个字符串、正则表达式的模式或一个引用的变量；&lt;/li&gt;
&lt;li&gt;proxy_hide_header：设定发送给客户端的报文中需要隐藏的首部；&lt;/li&gt;
&lt;li&gt;proxy_pass：指定将请求代理至upstream server的URL路径；&lt;/li&gt;
&lt;li&gt;proxy_set_header：将发送至upsream server的报文的某首部进行重写；&lt;/li&gt;
&lt;li&gt;proxy_redirect：重写location并刷新从upstream server收到的报文的首部；&lt;/li&gt;
&lt;li&gt;proxy_send_timeout：在连接断开之前两次发送至upstream server的写操作的最大间隔时长；&lt;/li&gt;
&lt;li&gt;proxy_read_timeout：在连接断开之前两次从接收upstream server接收读操作的最大间隔时长；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下面的一个示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;proxy_redirect off;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
client_max_body_size 10m;
client_body_buffer_size 128k;
proxy_connect_timeout 30;
proxy_send_timeout 15;
proxy_read_timeout 15;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;nginx proxy_pass 后面的url 加与不加/的区别：&lt;/strong&gt;&lt;br&gt;在nginx中配置proxy_pass时，当在后面的url加上了/，相当于是绝对根路径，则nginx不会把location中匹配的路径部分代理走;如果没有/，则会把匹配的路径部分也给代理走。&lt;br&gt;下面四种情况分别用&lt;a href=&quot;http://192.168.1.4/proxy/test.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://192.168.1.4/proxy/test.html&lt;/a&gt; 进行访问。&lt;/p&gt;
&lt;p&gt;第一种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location  /proxy/ {
    proxy_pass http://127.0.0.1:81/;
}
会被代理到http://127.0.0.1:81/test.html 这个url
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二种(相对于第一种，最后少一个 /)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location  /proxy/ {
    proxy_pass http://127.0.0.1:81;
}
会被代理到http://127.0.0.1:81/proxy/test.html 这个url
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第三种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location  /proxy/ {
    proxy_pass http://127.0.0.1:81/ftlynx/;
}
会被代理到http://127.0.0.1:81/ftlynx/test.html 这个url。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第四种情况(相对于第三种，最后少一个 / )：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location  /proxy/ {
    proxy_pass http://127.0.0.1:81/ftlynx;
}
会被代理到http://127.0.0.1:81/ftlynxtest.html 这个url
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;location后加/和不加/的区别&lt;/strong&gt;&lt;br&gt;首先是location进行的是模糊匹配&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有“/”时，location /abc/def可以匹配/abc/defghi请求，也可以匹配/abc/def/ghi等&lt;/li&gt;
&lt;li&gt;而有“/”时，location /abc/def/不能匹配/abc/defghi请求，只能匹配/abc/def/anything这样的请求&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Nginx实现负载均衡-–upstream模块&quot;&gt;&lt;a href=&quot;#Nginx实现负载均衡-–upstream模块&quot; class=&quot;headerlink&quot; title=&quot;Nginx实现负载均衡 –upstream模块&quot;&gt;&lt;/a&gt;Nginx实现负载均衡 –upstream模块&lt;/h4&gt;&lt;p&gt;与proxy模块结合使用的模块中，最常用的当属upstream模块。upstream模块可定义一个新的上下文，它包含了一组服务器，这些服务器可能被赋予了不同的权重、不同的类型甚至可以基于维护等原因被标记为down。直白点就是说如果后端一个服务器是在抗不住了，nginx还可以代理用户请求至多个服务器，也就是一个location里定义多个服务器，即实现负载均衡的效果。还能检查后端server的健康状况。&lt;br&gt;例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream backend {
    server 172.16.7.151:8080 weight=5;
    server 172.16.7.152:8090 weight=3;
}

server {
    listen 80;
    server_name www.wisedu.com;

    location / {
        proxy_pass http://backend;
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;server也可以使用域名，但是需要内网有DNS服务器，或者在hosts文件做解析。也可以是IP:port。&lt;br&gt;upstream模块定义在http段，可以定义多个upstream，但是每一个都要有自己独立的名称。&lt;/p&gt;
&lt;p&gt;upstream模块常用的指令有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ip_hash：基于客户端IP地址完成请求的分发，它可以保证来自于同一个客户端的请求始终被转发至同一个upstream服务器；&lt;pre&gt;&lt;code&gt;upstream lb {
       ip_hash;
       server 172.16.7.151:8080;
       server 172.16.7.152:8090;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;keepalive：每个worker进程为发送到upstream服务器的连接所缓存的个数；&lt;/li&gt;
&lt;li&gt;least_conn：最少连接调度算法；检查后端的连接状况，挑一个当前连接数最少的来负责响应。&lt;/li&gt;
&lt;li&gt;server：定义一个upstream服务器的地址，还可包括一系列可选参数，如：&lt;ul&gt;
&lt;li&gt;weight：权重；&lt;/li&gt;
&lt;li&gt;max_fails：最大失败连接次数，失败连接的超时时长由fail_timeout指定；&lt;/li&gt;
&lt;li&gt;fail_timeout：等待请求的目标服务器发送响应的时长；&lt;/li&gt;
&lt;li&gt;backup：用于fallback的目的，所有服务均故障时才启动此服务器；&lt;/li&gt;
&lt;li&gt;down：手动标记其不再处理任何请求；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;upstream模块的负载均衡算法主要有三种，轮调(round-robin)、ip哈希(ip_hash)和最少连接(least_conn)三种。默认是轮调算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;健康状况检查&lt;/strong&gt;&lt;br&gt;如果某台机器挂了怎么办？可以进行健康状况检查。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream webserv {
    server 172.16.7.151:8080 weight=1 max_fails=2 fail_timeout=2;
    server 172.16.7.152:8090 weight=1 max_fails=2 fail_timeout=2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;健康状况检查还应该有一个功能，万一所有服务器都宕掉怎么办？必须要有个Sorry-Server，下面以本机作为Sorry-Server，可以在定义个虚拟主机:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    listen 8080;
    server_name localhost;

    root /web/errorpages;
    index index.html
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;upstream添加配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream webserv {
    server 172.16.7.151:8080 weight=1 max_fails=2 fail_timeout=2;
    server 172.16.7.152:8090 weight=1 max_fails=2 fail_timeout=2;
    server 127.0.0.1:8080 backup;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。&lt;/p&gt;
&lt;h3 id=&quot;Nginx的URL重写功能和if指令&quot;&gt;&lt;a href=&quot;#Nginx的URL重写功能和if指令&quot; class=&quot;headerlink&quot; title=&quot;Nginx的URL重写功能和if指令&quot;&gt;&lt;/a&gt;Nginx的URL重写功能和if指令&lt;/h3&gt;&lt;h4 id=&quot;URL重写rewrite&quot;&gt;&lt;a href=&quot;#URL重写rewrite&quot; class=&quot;headerlink&quot; title=&quot;URL重写rewrite&quot;&gt;&lt;/a&gt;URL重写rewrite&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.什么叫rewrite&lt;/strong&gt;&lt;br&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /images/ {       ——这是我们当前服务器上的目录
    rewrite http://172.16.2.27/images/;      ——把你转到另外一台服务器上的目录去了。
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.Nginx的rewrite&lt;br&gt;Nginx的rewrite支持正则表达式   ——可以将一类URL转成另一类URL&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Syntax: rewrite regex replacement [flag];
Default:    —
Context:    server, location, if
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;server区块中如果有包含rewrite规则,则会最先执行,而且只会执行一次, 然后再判断命中哪个location的配置。如果location中也配置了rewrite，会再去执行该location中的rewrite，当该location中的rewrite执行完毕时，rewrite并不会停止，而是根据rewrite过的URL再次判断location并执行其中的配置。那么，这里就存在一个问题，如果rewrite写的不正确的话，是会在location区块间造成无限循环的。所以nginx才会加一个最多重试10次的上限。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location / {
    root html;
    index index.html index.htm;
    rewrite ^/bbs/(.*)$ /forum/$1
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;flag：支持4种标志。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;last：本次重写完成之后重启下一轮检查。一般场景下用的都是last。&lt;/li&gt;
&lt;li&gt;break：本次重写完成之后不启用下一轮检查，直接响应。&lt;/li&gt;
&lt;li&gt;redirect：返回302临时重定向，地址栏会显示跳转后的地址&lt;/li&gt;
&lt;li&gt;permanent： 返回301永久重定向，地址栏会显示跳转后的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测验一下break与last的区别:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location /test1.txt/ {
    rewrite /test1.txt/ /test2.txt break;
}

location ~ test2.txt {
    return 508;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用break会停止匹配下面的location,直接发起请求www.xxx.com/test2.txt，由于不存在文件test2.txt，则会直接显示404。&lt;br&gt;使用last的话，会继续搜索下面是否有符合条件(符合重写后的/test2.txt请求)的location。此时，/test2.txt刚好与面location的条件对应上了，进入花括号{}里面的代码执行，这里会返回508。&lt;/p&gt;
&lt;h4 id=&quot;if指令&quot;&gt;&lt;a href=&quot;#if指令&quot; class=&quot;headerlink&quot; title=&quot;if指令&quot;&gt;&lt;/a&gt;if指令&lt;/h4&gt;&lt;p&gt;在location中使用if语句可以实现条件判断，其通常有一个return语句，且一般与有着last或break标记的rewrite规则一同使用。但其也可以按需要使用在多种场景下，需要注意的是，不当的使用可能会导致不可预料的后果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream imageservers {
    server 172.16.100.8:80 weight 2;
    server 172.16.100.9:80 weight 3;
}

location / {
    if ($request_method == “PUT”) {
        proxy_pass http://upload.wisedu.com:8080;
    } 

    if ($request_uri ~ &amp;quot;\.(jpg|gif|jpeg|png)$&amp;quot;) {
        proxy_pass http://imageservers;
        break; #这里的break也是停止rewrite检查
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;if语句中的判断条件&lt;/p&gt;
&lt;p&gt;正则表达式匹配：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;==: 等值比较；
~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；
~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；
!~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；
!~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;文件及目录匹配判断：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-f, !-f：判断指定的路径是否为存在且为文件；
-d, !-d：判断指定的路径是否为存在且为目录；
-e, !-e：判断指定的路径是否存在，文件或目录均可；
-x, !-x：判断指定路径的文件是否存在且可执行；
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;http核心模块的内置变量&quot;&gt;&lt;a href=&quot;#http核心模块的内置变量&quot; class=&quot;headerlink&quot; title=&quot;http核心模块的内置变量&quot;&gt;&lt;/a&gt;http核心模块的内置变量&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;$uri: 当前请求的uri，不带参数；
$request_uri: 请求的uri，带完整参数；
$host: http请求报文中host首部；如果请求中没有host首部，则以处理此请求的虚拟主机的主机名代替；
$hostname: nginx服务运行在的主机的主机名；
$remote_addr: 客户端IP
$remote_port: 客户端Port
$remote_user: 使用用户认证时客户端用户输入的用户名；
$request_filename: 用户请求中的URI经过本地root或alias转换后映射的本地的文件路径；
$request_method: 请求方法
$server_addr: 服务器地址
$server_name: 服务器名称
$server_port: 服务器端口
$server_protocol: 服务器向客户端发送响应时的协议，如http/1.1, http/1.0
$scheme: 在请求中使用scheme, 如https://www.magedu.com/中的https；
$http_HEADER: 匹配请求报文中指定的HEADER，$http_host匹配请求报文中的host首部
$sent_http_HEADER: 匹配响应报文中指定的HEADER，例如$http_content_type匹配响应报文中的content-type首部；
$document_root：当前请求映射到的root配置；
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上篇博文中介绍了安装部署OpenResty，这篇博文主要记录下Nginx的配置及优化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h2&gt;&lt;p&gt;Nginx的代码是由一个核心和一系列的模块组成, 核心主要用于提供Web Server的基本功能，以及Web和Mail反向代理的功能；
    
    </summary>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>安装部署Openresty</title>
    <link href="http://yoursite.com/2018/01/21/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Openresty/"/>
    <id>http://yoursite.com/2018/01/21/安装部署Openresty/</id>
    <published>2018-01-21T11:55:10.000Z</published>
    <updated>2018-01-29T01:57:59.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;由于公司的一个产品用了Nginx Lua写了认证，所以在选型时选了OpenResty。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是OpenResty&quot;&gt;&lt;a href=&quot;#什么是OpenResty&quot; class=&quot;headerlink&quot; title=&quot;什么是OpenResty&quot;&gt;&lt;/a&gt;什么是OpenResty&lt;/h2&gt;&lt;p&gt;Nginx 是俄罗斯人发明的， Lua 是巴西几个教授发明的，中国人章亦春把 LuaJIT VM 嵌入到 Nginx 中，实现了 OpenResty 这个高性能服务端解决方案。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;最先将Nginx，Lua组合到一起的是OpenResty，它有一个ngx_lua模块，将Lua嵌入到了Nginx里面；随后Tengine也包含了ngx_lua模块。至于二者的区别：OpenResty是Nginx的Bundle；而Tengine则是Nginx的Fork。值得一提的是，OpenResty和Tengine均是国人自己创建的项目，前者主要由章亦春和晓哲开发，后者主要由淘宝打理。&lt;/p&gt;
&lt;h2 id=&quot;Nginx特性&quot;&gt;&lt;a href=&quot;#Nginx特性&quot; class=&quot;headerlink&quot; title=&quot;Nginx特性&quot;&gt;&lt;/a&gt;Nginx特性&lt;/h2&gt;&lt;h3 id=&quot;HTTP服务器&quot;&gt;&lt;a href=&quot;#HTTP服务器&quot; class=&quot;headerlink&quot; title=&quot;HTTP服务器&quot;&gt;&lt;/a&gt;HTTP服务器&lt;/h3&gt;&lt;p&gt;即web服务器，具有支持一个基本的web服务器应该具备的绝大多数功能。 (&lt;a href=&quot;http://www.netcraft.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.netcraft.com/&lt;/a&gt; 在这个站点上随时统计更新的有全球web服务器的占有状况)&lt;br&gt;灵活的配置：nginx和apache差不多，也是一个进程生成许多子进程，而这个子进程本身有worker进程，专门负责响应用户请求的。nginx是一个进程响应多个请求，事实上可以称为一个线程响应多个请求。除此之外还有许多其他进程，比如说管理缓存的进程，管理会话的进程。有了这样的架构设计，将来在重新添加配置之后，可以将新的连接都使用新配置，而老的连接即已经建立的连接使用原有的配置，所以在线升级的时候不需要中断正在处理的请求，这称为nginx热部署(无非就是平滑升级)。&lt;br&gt;重写(rewrite)模块：web服务器httpd的重写功能异常强大，但是也比较复杂。nginx比较简单，只需要使用正则表达式重写URL。对于任何一个web服务器来说，URL重写是个非常重要的功能，尤其是反向代理的服务器。&lt;/p&gt;
&lt;h3 id=&quot;模块化设计&quot;&gt;&lt;a href=&quot;#模块化设计&quot; class=&quot;headerlink&quot; title=&quot;模块化设计&quot;&gt;&lt;/a&gt;模块化设计&lt;/h3&gt;&lt;p&gt;nginx是高度模块化的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心模块：core module&lt;/li&gt;
&lt;li&gt;Standard HTTP modules&lt;/li&gt;
&lt;li&gt;Optional HTTP modules&lt;/li&gt;
&lt;li&gt;Mail modules&lt;/li&gt;
&lt;li&gt;3rd party modules&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;支持热部署&quot;&gt;&lt;a href=&quot;#支持热部署&quot; class=&quot;headerlink&quot; title=&quot;支持热部署&quot;&gt;&lt;/a&gt;支持热部署&lt;/h3&gt;&lt;p&gt;不停机更新配置文件、更换日志、更新服务器程序版本。&lt;/p&gt;
&lt;h3 id=&quot;主要用途&quot;&gt;&lt;a href=&quot;#主要用途&quot; class=&quot;headerlink&quot; title=&quot;主要用途&quot;&gt;&lt;/a&gt;主要用途&lt;/h3&gt;&lt;p&gt;nginx有两个作用。第一，web服务器。具有web服务器要求的所有功能。第二，轻量级的反向代理服务器，能够反向代理两种应用：web和mail，只不过反向代理mail的功能很少被提到。我们的主要着眼点也是它的web服务器和web服务器反向代理。&lt;br&gt;Nginx基于File AIO(异步I/O)，在文件级别上磁盘I/O上基于异步I/O来实现的；同时对于异步通信，nginx基于事件驱动加上边缘触发来完成一个线程处理多个请求，这对于c10k问题是十分有效的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;Nginx工作模式、框架、模型&quot;&gt;&lt;a href=&quot;#Nginx工作模式、框架、模型&quot; class=&quot;headerlink&quot; title=&quot;Nginx工作模式、框架、模型&quot;&gt;&lt;/a&gt;Nginx工作模式、框架、模型&lt;/h2&gt;&lt;p&gt;nginx会按需同时运行多个进程：一个主进程(master)和几个工作进程(worker)，配置了缓存时还会有缓存加载器进程(cache loader)和缓存管理器进程(cache manager)等。所有进程均是仅含有一个线程，并主要通过“共享内存”的机制实现进程间通信。主进程以root用户身份运行，而worker、cache loader和cache manager均应以非特权用户身份运行。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master进程(线程)监控worker进程(线程)，包括运行是否正常等。&lt;/li&gt;
&lt;li&gt;worker进程：master的子进程，响应用户请求。&lt;/li&gt;
&lt;li&gt;cache loader进程：在反向代理的时候用于管理缓存的进程。&lt;/li&gt;
&lt;li&gt;·······&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/8.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;注意：master进程是以管理员启动的，因为nginx要启动为web服务器或反向代理的时候，它应该工作在80端口，只有管理员才有权限启用小于1023的端口，所以启动主进程的时候必须使用管理员身份。然后由master进程启动worker进程，而且master启动worker进程的时候完全以普通用户的身份运行，所以让我们的系统安全性得到提升。&lt;br&gt;nginx是高度模块化的，所以nginx的核心模块，像master进程、worker进程所处理的web应用非常简单，最多就是个web服务器，而额外的更多功能比如SSL、FLV流等都不是worker进程自己提供的，而是由额外的模块提供，所以在每个worker进程内部，它可能调用很多个模块，用到哪个模块再去加载哪个模块，而这些模块以流水线的方式工作，也就是一个模块只负责一个功能。比如说第一个分析头部，第二个帮助去的数据，第三个创建响应等等。每个请求，在内部串联起来的模块还不一样，所以每个请求到来了，worker一分析，到底要使用几个模块，这几个模块组成流水线，随时等待响应。&lt;br&gt;正是由于这种机制的存在，master负责装在主配置文件，如果我们改了nginx配置文件，由master分析一下配置文件中有没有语法错误，就算重新装在配置文件有语法错误，但是并不会影响worker进程，最多master返回错误告诉你配置文件有语法错误，需要重新装载。一装载成功了，并不会让运行中的worker进程都使用这个配置是文件的，让这些已经建立的连接继续使用老的配置文件，当某个worker进程建立的连接都退出了，此时把worker进程挂了，再重新启动个新worker进程，新worker进程响应新请求，而这个新worker进程用的就是新配置。&lt;br&gt;&lt;strong&gt;【nginx进程分工】：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;主进程master：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;读取并验正配置信息；&lt;/li&gt;
&lt;li&gt;创建、绑定及关闭套接字；&lt;/li&gt;
&lt;li&gt;启动、终止及维护worker进程的个数；&lt;/li&gt;
&lt;li&gt;无须中止服务而重新配置工作特性；&lt;/li&gt;
&lt;li&gt;控制非中断式程序升级，启用新的二进制程序并在需要时回滚至老版本；   ——nginx自身升级&lt;/li&gt;
&lt;li&gt;重新打开日志文件，实现日志滚动；&lt;/li&gt;
&lt;li&gt;编译嵌入式perl脚本；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;worker进程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接收、传入并处理来自客户端的连接；&lt;/li&gt;
&lt;li&gt;提供反向代理及过滤功能；&lt;/li&gt;
&lt;li&gt;nginx任何能完成的其它任务；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;cache loader进程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查缓存存储中的缓存对象；&lt;/li&gt;
&lt;li&gt;使用缓存元数据建立内存数据库；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;cache manager进程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存的失效及过期检验；&lt;br&gt;【注意】：cache loader和cache manager只是在使用nginx作为反向代理并使用了缓存功能的时候才启动，不是所有时候都运行的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;安装OpenResty&quot;&gt;&lt;a href=&quot;#安装OpenResty&quot; class=&quot;headerlink&quot; title=&quot;安装OpenResty&quot;&gt;&lt;/a&gt;安装OpenResty&lt;/h2&gt;&lt;p&gt;使用的版本是openresty-1.9.7.3.tar.gz&lt;br&gt;&lt;strong&gt;1.安装依赖包&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# yum install readline-devel pcre-devel openssl-devel gcc -y
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.安装openresty&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cd /usr/local
# wget https://openresty.org/download/openresty-1.9.7.3.tar.gz
# tar zxf openresty-1.9.7.3.tar.gz
# cd openresty-1.9.7.3/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看可配置的选项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ./configure --help
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/9.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;常用的配置参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;–-prefix=path&lt;br&gt;设置安装目录，默认为/usr/local/openresty&lt;/li&gt;
&lt;li&gt;–user=name&lt;br&gt;设置工作进程使用的非特权用户的用户名，默认为nobody。安装完成后可以在nginx.conf中通过user指令修改。&lt;/li&gt;
&lt;li&gt;–group=name&lt;br&gt;设置工作进程使用的非特权用户组的名称，默认组名和–user的名称一致。安装完成后可以在nginx.conf配置文件中通过user指令指定。&lt;/li&gt;
&lt;li&gt;–-with-http_ssl_module&lt;br&gt;启用添加HTTPS协议支持到HTTP服务器的模块，该模块默认不启用。构建和运行该模块需要OpenSSL库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ./configure
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译和安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# gmake &amp;amp;&amp;amp; gmake install
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装完成后，在/usr/local/下多了个openresty目录，nginx部署安装在/usr/local/openresty/nginx。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.将nginx加入系统服务&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;【Redhat7之前的版本】：&lt;/strong&gt;&lt;br&gt;(1)    上传脚本nginx启动脚本到/etc/init.d/目录下&lt;br&gt;(2)    授权脚本执行权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# chmod a+x nginx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(3)    加入系统服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# chkconfig --add nginx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(4)    nginx开启自启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# chkconfig nginx on
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(5)    nginx启停重载&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# service nginx start/stop/restart/reload
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;【Redhat7版本】：&lt;/strong&gt;&lt;br&gt;(1)    启动服务单元&lt;br&gt;把写好的nginx.service放到/etc/systemd/system/目录下。&lt;br&gt;(2)    设置开机启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# systemctl enable nginx.service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(3)    启动/停止/重载nginx服务&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# systemctl start/stop/reload nginx.service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;脚本nginx的内容如下：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;49&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;50&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;52&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;53&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;54&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;55&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;56&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;57&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;58&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;59&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;60&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;61&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;62&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;63&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;65&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;66&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;67&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;68&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;69&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;70&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;71&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;72&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;73&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;74&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;75&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;76&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;77&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;78&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;79&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;80&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;81&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;82&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;83&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;84&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;85&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;86&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;87&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;88&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;89&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;90&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;91&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;92&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;93&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;94&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;95&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#!/bin/sh&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# nginx - this script starts and stops the nginx daemon&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# chkconfig:   - 85 15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# description: Nginx is an HTTP(S) server, HTTP(S) reverse \&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#               proxyand IMAP/POP3 proxy server&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# processname: nginx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# config:      /etc/nginx/nginx.conf&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# config:      /etc/sysconfig/nginx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# pidfile:     /var/run/nginx.pid&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Source function library.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;. /etc/rc.d/init.d/functions&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Source networking configuration.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;. /etc/sysconfig/network&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Check that networking is up.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &amp;quot;$NETWORKING&amp;quot; = &amp;quot;no&amp;quot; ] &amp;amp;&amp;amp; exit 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;nginx=&amp;quot;/usr/local/openresty/nginx/sbin/nginx&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;prog=$(basename $nginx)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NGINX_CONF_FILE=&amp;quot;/usr/local/openresty/nginx/conf/nginx.conf&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ -f /etc/sysconfig/nginx ] &amp;amp;&amp;amp; . /etc/sysconfig/nginx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;lockfile=/var/lock/subsys/nginx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;start() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [ -x $nginx ] || exit 5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [ -f $NGINX_CONF_FILE ] || exit 6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    echo -n $&amp;quot;Starting $prog: &amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    daemon $nginx -c $NGINX_CONF_FILE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    retval=$?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    echo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [ $retval -eq 0 ] &amp;amp;&amp;amp; touch $lockfile&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return $retval&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;stop() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    echo -n $&amp;quot;Stopping $prog: &amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    killproc $prog -QUIT&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    retval=$?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    echo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [ $retval -eq 0 ] &amp;amp;&amp;amp; rm -f $lockfile&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return $retval&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;killall -9 nginx&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;restart() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    configtest || return $?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    stop&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    sleep 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    start&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;reload() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    configtest || return $?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    echo -n $&amp;quot;Reloading $prog: &amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    killproc $nginx -HUP&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;RETVAL=$?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    echo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;force_reload() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    restart&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;configtest() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$nginx -t -c $NGINX_CONF_FILE&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;rh_status() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    status $prog&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;rh_status_q() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    rh_status &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;case &amp;quot;$1&amp;quot; in&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    start)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        rh_status_q &amp;amp;&amp;amp; exit0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    $1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    stop)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        rh_status_q || exit 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    restart|configtest)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    reload)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        rh_status_q || exit 7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        $1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    force-reload)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        force_reload&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    status)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        rh_status&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    condrestart|try-restart)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        rh_status_q || exit 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            ;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    *)  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      echo $&amp;quot;Usage: $0 &amp;#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&amp;#125;&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        exit 2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;esac&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务单元nginx.service的内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Unit]
Description=nginx - high performance web server
Documentation=http://nginx.org/en/docs/
After=network.target remote-fs.target nss-lookup.target

[Service]
Type=forking
PIDFile=/usr/local/openresty/nginx/logs/nginx.pid
ExecStartPre=/usr/local/openresty/nginx/sbin/nginx -t -c /usr/local/openresty/nginx/conf/nginx.conf
ExecStart=/usr/local/openresty/nginx/sbin/nginx -c /usr/local/openresty/nginx/conf/nginx.conf
ExecReload=/bin/kill -s HUP $MAINPID
ExecStop=/bin/kill -s QUIT $MAINPID
PrivateTmp=true

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;【补充】:&lt;br&gt;RHEL/CentOS 7.0中一个最主要的改变，就是切换到了systemd。它用于替代红帽企业版Linux前任版本中的SysV和Upstart，对系统和服务进行管理。systemd兼容SysV和Linux标准组的启动脚本。&lt;br&gt;Systemd 是 Linux 系统中最新的初始化系统（init），它主要的设计目标是克服 sysvinit 固有的缺点，提高系统的启动速度。systemd 和 ubuntu 的 upstart 是竞争对手，已经取代了UpStart。&lt;br&gt;Systemd也是一个Linux操作系统下的系统和服务管理器。它被设计成向后兼容SysV启动脚本，并提供了大量的特性，如开机时平行启动系统服务，按需启动守护进程，支持系统状态快照，或者基于依赖的服务控制逻辑。&lt;br&gt;先前的使用SysV初始化或Upstart的红帽企业版Linux版本中，使用位于/etc/rc.d/init.d/目录中的bash初始化脚本进行管理。而在RHEL 7/CentOS 7中，这些启动脚本被服务单元取代了。服务单元以.service文件扩展结束，提供了与初始化脚本同样的用途。要查看、启动、停止、重启、启用或者禁用系统服务，你要使用systemctl来代替旧的service命令。&lt;br&gt;注：为了向后兼容，旧的service命令在CentOS 7中仍然可用，它会重定向所有命令到新的systemctl工具。&lt;/p&gt;
&lt;h2 id=&quot;Nginx日志切割&quot;&gt;&lt;a href=&quot;#Nginx日志切割&quot; class=&quot;headerlink&quot; title=&quot;Nginx日志切割&quot;&gt;&lt;/a&gt;Nginx日志切割&lt;/h2&gt;&lt;p&gt;日志对于统计排错来说非常有利的。nginx日志相关的配置如access_log、log_format、error_log等。这部分配置内容将在下一篇博文中讲解，这里先来简单提一下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log_format res &amp;apos;$http_host $remote_addr [$time_local] &amp;quot;$request&amp;quot; $status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &amp;quot;$http_user_agent&amp;quot; $request_time $upstream_response_time&amp;apos;; #定义日志格式，并给这个日志格式命名为res
access_log  logs/res.access.log  res; #access_log在虚拟主机段中配置，logs/res.access.log定义了存放该虚拟主机日志文件的名字及存放路径，记录的日志格式为上面定义的res所对应的日志格式
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nginx每个虚拟主机都应该使用一个单独的日志，这里使用Linux自带的logrotate进行切割。如果不切割，每个日志文件会越来越大。&lt;br&gt;关于logrotate的介绍及配置这里不多介绍，可以自行google。下面开始定义切割Nginx的logrotate的配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# vim /etc/logrotate.d/nginx
/usr/local/openresty/nginx/logs/*.log {
    notifempty
    weekly
    rotate 4
    nocompress
    copytruncate
    postrotate
    systemctl reload nginx.service 
    endscript
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的配置是每周切割一次Nginx日志，保留最近的4个日志文件。&lt;br&gt;对于配置中的 &lt;strong&gt;systemctl reload nginx.service&lt;/strong&gt; 需要换成服务器上重载Nginx的命令，如果是centos6系列，可能命令就是 &lt;strong&gt;service nginx reload&lt;/strong&gt;。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;关于Nginx的具体配置将在下篇博文中分享。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于公司的一个产品用了Nginx Lua写了认证，所以在选型时选了OpenResty。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是OpenResty&quot;&gt;&lt;a href=&quot;#什么是OpenResty&quot; class=&quot;headerlink&quot; title=&quot;什么是OpenResty&quot;&gt;&lt;/a&gt;什么是OpenResty&lt;/h2&gt;&lt;p&gt;Nginx 是俄罗斯人发明的， Lua 是巴西几个教授发明的，中国人章亦春把 LuaJIT VM 嵌入到 Nginx 中，实现了 OpenResty 这个高性能服务端解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>I/O模型</title>
    <link href="http://yoursite.com/2018/01/18/I-O%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/01/18/I-O模型/</id>
    <published>2018-01-18T09:08:21.000Z</published>
    <updated>2018-01-21T12:12:42.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;I-O类型&quot;&gt;&lt;a href=&quot;#I-O类型&quot; class=&quot;headerlink&quot; title=&quot;I/O类型&quot;&gt;&lt;/a&gt;I/O类型&lt;/h2&gt;&lt;p&gt;从不同的角度来划分，有两种不同的方式：&lt;br&gt;&lt;strong&gt;同步I/O和异步I/O&lt;/strong&gt;    ——synchronous, asynchronous&lt;br&gt;同步和异步关注的是消息通知机制。说白了就是如何通知调用者的。I/O就是一方能够提供服务，一方需要调用别人的服务，&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;所以I/O请求就是调用方向被调用方请求运行一个应用，通常是一个函数，可以理解成是一个库调用、函数调用或者系统调用。假如是一次系统调用，调用方向被调用方发起一次系统调用请求，被调用方本地要把这个系统调用运行完成，所以要在本地处理处理，把处理的结果响应给调用方。问题是调用方什么时候知道自己的请求结束了呢？自己的请求对方响应了呢？所以这就是同步和异步两种模式。&lt;br&gt;所谓同步是调用发出之后不会立即返回，但一旦返回，则返回是最终结果；(被调用者一直在处理处理，处理到最后返回结果给调用者)&lt;br&gt;所谓异步是调用发出之后，被调用方返回消息，但返回的并非最终结果；被调用者通过状态、通知机制(比如打电话通知你)等来通知调用者，或通过回调函数来处理结果。 (当调用者发出请求以后，被调用者立即就告诉调用者了，比如：请求已收到，等着叫号吧。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞I/O和非阻塞I/O&lt;/strong&gt;    ——block, nonblock&lt;br&gt;阻塞和非阻塞关注的是调用者等待被调用返回结果时的状态。&lt;br&gt;阻塞是指调用结果返回之前，调用者(一般是进程或者线程)会被挂起；调用者只有在得到返回结果之后才能继续；&lt;br&gt;非阻塞是指调用者在结果返回之前，不会被挂起，即调用不会阻塞调用者。&lt;/p&gt;
&lt;p&gt;【例子】：你去一个饭馆吃饭去了，点了一碗面，师傅在现做。然后你就在那等着，这期间不能做其他的事情，这就是阻塞。还有一种方案是在等面的时候该干嘛干嘛去，比如出去玩了会游戏等，估摸着面差不多的时候回到饭馆，吃面。这就是非阻塞。&lt;/p&gt;
&lt;h2 id=&quot;I-O模型&quot;&gt;&lt;a href=&quot;#I-O模型&quot; class=&quot;headerlink&quot; title=&quot;I/O模型&quot;&gt;&lt;/a&gt;I/O模型&lt;/h2&gt;&lt;p&gt;同步、异步和阻塞、非阻塞看起来很像，但是关注的点不同，一个关注着调用者如何等待结果，一个关注着被调用者如何通知调用者调用完成的。所以压根不是一回事。站在这个角度来划分的话，I/O可以分成5种模型：&lt;br&gt;  ● 阻塞式I/O(blocking I/O)&lt;br&gt;  ● 非阻塞式I/O(nonblocking I/O)&lt;br&gt;  ● 复用式I/O(I/O multiplexing)&lt;br&gt;  ● 事件驱动式I/O(signal driven I/O)&lt;br&gt;  ● 异步I/O(asynchronous I/O)&lt;/p&gt;
&lt;p&gt;下面以磁盘I/O来解释，这些概念非常关键。例如，用户程序发起一个I/O调用，如从磁盘上做一次read操作(用户空间的进程是没有权限直接访问文件的，进程向用户内核发起I/O调用，请求说我要读取某数据)：&lt;br&gt;(1)内核从磁盘将数据加载到内核内存空间；&lt;br&gt;(2)将内核内存中的数据copy一份到进程内存空间。&lt;br&gt;以上两步中真正被称为I/O的那一步其实只是第(2)步，第(1)步只是内核处理数据的过程。&lt;/p&gt;
&lt;h3 id=&quot;阻塞式I-O-blocking-I-O&quot;&gt;&lt;a href=&quot;#阻塞式I-O-blocking-I-O&quot; class=&quot;headerlink&quot; title=&quot;阻塞式I/O(blocking I/O)&quot;&gt;&lt;/a&gt;阻塞式I/O(blocking I/O)&lt;/h3&gt;&lt;p&gt;下图中，左侧竖线代表调用者，右侧竖线代表被调用者。整个I/O调用在右侧内核来看，分为两步。如上。所谓阻塞式I/O指的是调用方发起调用后将会被挂起，这个进程或线程将转为不可中断式睡眠状态。调用者在得到返回结果之前，什么事都不能做，一直处于等待过程当中。想象一下，假如是个web服务器，第一个用户请求来了，由一个进程响应用户请求，这个进程向内核发起I/O调用请求，加载用户请求的页面资源，在加载这个页面资源的过程当中，假设它工作于阻塞式I/O的话，它就会被挂起，它显然不能响应用户的其他请求。Apache的prefork并不是工作在阻塞式I/O之下。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;非阻塞式I-O-nonblocking-I-O&quot;&gt;&lt;a href=&quot;#非阻塞式I-O-nonblocking-I-O&quot; class=&quot;headerlink&quot; title=&quot;非阻塞式I/O(nonblocking I/O)&quot;&gt;&lt;/a&gt;非阻塞式I/O(nonblocking I/O)&lt;/h3&gt;&lt;p&gt;左侧是调用者，右侧是被调用者。对于被调用者，依然是两个阶段，数据从磁盘到内核内存，然后数据从内核内存到进程内存。对于非阻塞式I/O，调用者也把这个过程分成两个阶段(左侧也是两个阶段)，第1阶段，当调用者发出请求之后，被调用者立即告诉你：请求已收到，你等着吧。但问题是等到什么时候呢？就像去面馆点了一碗面一样，然后你出去玩了，但是你怎么知道面好了呢？为了及时得到吃面，所以你不得不每隔几秒钟回去看看面好了没有。这种就叫做盲等，效率并不高。这种不会直接转为睡眠状态，直到好了告诉你。一旦老板告诉你面OK了，是指面已经在柜台上了，其实是指数据从磁盘到内核内存了，你想吃还得自己从柜台上端过去。所以第二阶段你去端面，在这个过程你是什么事情都是做不了的，所以虽然是非阻塞，第2阶段依然是阻塞的。&lt;br&gt;所以对于非阻塞式I/O，第一阶段是盲等，第二阶段依然是阻塞的。很显然第二种模式相对第一种模式，性能并没有提升。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;复用式I-O-I-O-multiplexing&quot;&gt;&lt;a href=&quot;#复用式I-O-I-O-multiplexing&quot; class=&quot;headerlink&quot; title=&quot;复用式I/O(I/O multiplexing)&quot;&gt;&lt;/a&gt;复用式I/O(I/O multiplexing)&lt;/h3&gt;&lt;p&gt;任何一个进程，它只能处理一个I/O，因为它一旦被一个I/O阻塞了，直到被唤醒之前，其他人干的事情它一概不知。但作为web服务器进程，它其实是处理两路I/O的，第一路用户通过网络进来，这是网络I/O，第二路是自己向内核发请求加载数据，这是磁盘I/O。这是两路不同的I/O，因此一旦进程被阻塞在磁盘I/O上，如果这个时候网络I/O发生异动了，这个进程是不会知道的。默认情况下，只能处理完一路I/O，在去处理另一路I/O。&lt;br&gt;再举个例子，比如终端执行一个命令，然后阻塞在磁盘I/O上，你不要了，按了ctrl+c，按道理这个进程处于不可中断睡眠，它应该是不知道的。怎么才能取消。现实中是能取消的，这就是多路I/O(或者说是复用I/O)的工作机制了。&lt;br&gt;默认情况下，调用者向被调用者发起调用请求时，如果阻塞了，调用者就任何事都做不了，任何信号都处理不了。为了避免这种情况，有人就在内核中开发了复用式I/O的程序，当调用者需要发起I/O调用时，而是内核给调用者准备了个代理人，调用者将请求发给这个代理人，代理人在把这个请求转为内核可以理解的请求，这样一来，调用者就被阻塞在代理人上，而不是阻塞在内核中完成任务的那个事情上。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;再举个例子，银行很多人在办业务，都在那排队，假如柜台是单进程模型的，在某个时刻只能处理一个业务。这个银行柜台就相当于内核准备的代理人，比如第一个用户想通过这个银行柜台开一张银行卡。向营业员发调用请求，给我开张银行卡，营业员在把请求结果响应给调用者之前，一般而言，这个调用者要一直在柜台坐在那等着。但是也有第二种情况，比如银行业务是两段式的，营业员不直接面对客户，每个营业员配一个助理，这个助理就站在柜台前，负责处理用户请求。所以当任何一个用户请求来了，用户请求扔给助理，助理帮你负责送到内部去。银行柜台有多个，分别办理不同的业务，比如说某个请求既要开张银行卡，又要存款。假设两个业务能同时进行的话，请求者跟助理说我要开张银行卡，于是助理把这个请求扔给一柜台了，自己就闲出来了。然后请求者又扔给助理一个请求，说我要存钱，于是助理又要第二个请求扔给第二个柜台了。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/4.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;内核的那个代理人就相当于助理，帮我们实现多路I/O。如果没有这个助理，想完成复用是不可能的。这个助理在内核中就是一种特殊的系统调用。早期的内核有个select()调用，就是这种模式。另外一个poll()调用，也是这种模式。select()是由BSD研发的，后来BSD内部吵架，又模仿select()写了个poll()。两者功能是一样的，只不过一个是BSD风格的，一个是SysV风格的。&lt;br&gt;此后，任何调用者在发起系统调用时，它把调用请求不是扔给内核，而是扔给内核中的助理了。或者说是向内核助理注册一个I/O。select()在实现多路I/O时有限制，要求最多不能超出1024路，如果你想超出，拿内核源码改一改。改成2048，没问题，但是1024的限制是由道理的，因为超出后性能会下降的。我们在讲到prefork模型时，说最多能接受1024个请求并发，其实prefork就是基于select()多路复用I/O模型来实现的。&lt;br&gt;对于这种复用式I/O，依然是阻塞型的，只不过它不是阻塞在自己真正的那个调用之上，而是阻塞在那个助理上，也是select()或poll()上。&lt;br&gt;因此两个阶段，第一个阶段数据从磁盘到内核空间，这个阶段调用者是被阻塞的，只不过没阻塞在内核的I/O调用上，而是阻塞在select()或poll()上。select()这个时候还可以接受其他请求。阻塞在select()之上的最大好处就是可以继续接受其他请求，因为它能够接受其他信号进来。但是对于第二阶段来讲，调用者依然是阻塞的。第二阶段是真正的I/O过程，这个时候调用者就不是阻塞在select()之上，而是阻塞在自己真正的调用之上。&lt;br&gt;复用式I/O对性能并没有提升，最多只是能处理额外的事情而已，并不是在性能上有什么提升。&lt;/p&gt;
&lt;h3 id=&quot;事件驱动式I-O-signal-driven-I-O&quot;&gt;&lt;a href=&quot;#事件驱动式I-O-signal-driven-I-O&quot; class=&quot;headerlink&quot; title=&quot;事件驱动式I/O(signal driven I/O)&quot;&gt;&lt;/a&gt;事件驱动式I/O(signal driven I/O)&lt;/h3&gt;&lt;p&gt;调用者发起调用之后，在第一阶段，内核立即返回结果给调用者，告诉调用者：你的请求我已经收到了，你该干嘛干嘛去，一旦我这边完成了，我会通知你。就相当于你去吃面了，老板告诉你面做好了我会打电话通知你的。这不是盲等，你该干嘛干嘛，不需要回来看，过一会老板通知你OK了，你就回来了。回来后，面在柜台上，我们去端面。端面的过程才是真正的I/O过程，这个过程是不能干其他事情的。(也像我们去餐馆，没位置，留了个电话号码，然后出去玩了，等服务员电话。)&lt;br&gt;这个过程中，第一段是非阻塞的，第二段是阻塞的。作为web服务器来讲，这有什么用呢？一个进程，第一个用户请求来了，进程向内核发起系统调用，加载文件，内核说你该干嘛干嘛去。于是这个进程就闲下来了，这样它就可以处理其它请求了。这就是为什么一个进程可以处理多个请求的原因。但是这个并不意味着性能一定好。虽然已经比阻塞和盲等有优势了，但是它第二段依然是阻塞的。面已经OK了，你仍然得自己端，所以在内核空间数据复制到进程空间这段，仍然是阻塞的。&lt;br&gt;为什么叫事件驱动呢？因为一旦数据从磁盘到内核空间后，内核会通知调用者。所以调用者本身使用回调函数来处理。&lt;br&gt;假如第二个请求数据已经准备好了，等着调用者进程将数据从内核空间复制到用户空间，但是假如此时调用者阻塞在第一个请求上，正在复制第一个请求的数据到进程空间，怎么办？内核通知完了在特定时间内你没有接收，这个信号就消失了。怎么办？所以通知与否，怎么通知，这就引入了两种通知机制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种：水平触发。通知一次，你没响应，没来处理，内核就再通知一次。没来处理留再通知一次，直到你处理为止。多次通知看上去更可靠，但是浪费资源。(类似老板一直打电话给你，直到你接电话)&lt;/li&gt;
&lt;li&gt;第二种：边缘触发。只通知一次，但是如果调用者没响应怎么办呢？把通知事件通过回调函数让调用者自行获取，或者把通知信息放置某处，或者过一会儿调用者自己去要。(老板打了一遍电话，你没接，怕面凉了，就端到厨房。过一会你看到未接电话，知道面好了，就回来了，跟老板要。这叫回调。至于什么是回调函数，可以看：&lt;a href=&quot;https://www.zhihu.com/question/19801131&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/19801131&lt;/a&gt;)&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/5.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;异步I-O-asynchronous-I-O&quot;&gt;&lt;a href=&quot;#异步I-O-asynchronous-I-O&quot; class=&quot;headerlink&quot; title=&quot;异步I/O(asynchronous I/O)&quot;&gt;&lt;/a&gt;异步I/O(asynchronous I/O)&lt;/h3&gt;&lt;p&gt;当调用者向内核发调用，内核说请求已收到，该干嘛干嘛去。于是内核在后台默默地完成第一步，默默地完成第二步。然后才告诉调用者，饭已OK了，过来吃吧。饭都不用你端了，直接由营业员端到你事先定义好的座位上。因此第一个阶段不用阻塞，第二个阶段不用阻塞。&lt;br&gt;作为一个web服务器来讲，当第一个用户请求进来时，用户请求资源，这个进程向内核发起系统调用，内核自己把数据从磁盘到内核空间，在复制到进程空间，所有东西都准备好了，告诉进程OK了，进程就立即打包响应报文响应给客户端。&lt;br&gt;httpd的event模型就是事件驱动型I/O，但是据说新版2.4也支持异步I/O。在异步模型下，生产力大大解放。内核从磁盘加载数据到内核内存中，一般都会缓存下来。如果第二个用户请求的资源和前面的用户请求的资源是一样的，直接响应就可以了。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;五种I-O模型对比&quot;&gt;&lt;a href=&quot;#五种I-O模型对比&quot; class=&quot;headerlink&quot; title=&quot;五种I/O模型对比&quot;&gt;&lt;/a&gt;五种I/O模型对比&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/7.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;有通知机制的我们称为异步I/O，无通知机制的我们称为同步I/O。见上图最下面，前面3个是同步I/O，后面2个是异步I/O。&lt;/p&gt;
&lt;p&gt;Nginx在设计时，用的就是事件驱动型I/O，而且基于边缘触发来实现。Nginx还支持异步I/O。而且还能完成mmap机制，内存映射机制。&lt;/p&gt;
&lt;p&gt;Nginx基于File AIO(异步I/O)，在文件级别上磁盘I/O上基于异步I/O来实现的；同时对于异步通信，nginx基于事件驱动加上边缘触发来完成一个线程处理多个请求，这对于c10k问题是十分有效的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;HTTPD的MPM&quot;&gt;&lt;a href=&quot;#HTTPD的MPM&quot; class=&quot;headerlink&quot; title=&quot;HTTPD的MPM&quot;&gt;&lt;/a&gt;HTTPD的MPM&lt;/h2&gt;&lt;p&gt;httpd的MPM（多道处理模块）&lt;br&gt;  ● prefork：进程模型的。用的是复用型I/O。&lt;br&gt;  ● worker：线程模型的。用的是复用型I/O。并发有限，select()最多1024个。&lt;br&gt;  ● event：线程模型的。用的是事件驱动式I/O。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prefork工作模型&lt;br&gt;有一个主进程，主进程生成多个子进程，每个子进程处理一个请求。主进程是以管理员的身份启动的，所以它能够监听在80端口上。端口&amp;lt;1024的被称为特权端口，只有管理员才有权限使用的。&lt;/li&gt;
&lt;li&gt;worker工作模型&lt;br&gt;有一个主进程，主进程生成多个子进程，每个子进程在生成多个线程，每个线程响应一个请求。&lt;/li&gt;
&lt;li&gt;event工作模型&lt;br&gt;有一个主进程，生成多个子进程，每个子进程响应多个请求。当然你也可以理解有一个主进程，生成多个子线程，对Linux而言，子进程和线程并没有严格意义上的区分。而event模型中最著名的、最典型的特性是事件驱动机制。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;I-O类型&quot;&gt;&lt;a href=&quot;#I-O类型&quot; class=&quot;headerlink&quot; title=&quot;I/O类型&quot;&gt;&lt;/a&gt;I/O类型&lt;/h2&gt;&lt;p&gt;从不同的角度来划分，有两种不同的方式：&lt;br&gt;&lt;strong&gt;同步I/O和异步I/O&lt;/strong&gt;    ——synchronous, asynchronous&lt;br&gt;同步和异步关注的是消息通知机制。说白了就是如何通知调用者的。I/O就是一方能够提供服务，一方需要调用别人的服务，
    
    </summary>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置HTTP/2.0</title>
    <link href="http://yoursite.com/2018/01/16/Nginx%E9%85%8D%E7%BD%AEHTTP-2-0/"/>
    <id>http://yoursite.com/2018/01/16/Nginx配置HTTP-2-0/</id>
    <published>2018-01-16T05:53:17.000Z</published>
    <updated>2018-01-29T11:57:21.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;最近将公司前端组件的Nginx配置了http 2.0，特此在此记录一下。突然发现博客里竟然没有什么关于Nginx的文章，毕竟是一直在使用的，后面会写几篇关于自己这几年使用Nginx的一些总结。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;从 2015 年 5 月 14 日 HTTP/2 协议正式版的发布到现在已经快有一年了，越来越多的网站部署了 HTTP2，HTTP2 的广泛应用带来了更好的浏览体验，只要是 Modern 浏览器都支持，所以部署 HTTP2 并不会带来太多困扰。&lt;br&gt;虽然 h2 有 h2c （HTTP/2 Cleartext） 可以通过非加密通道传输，但是支持的浏览器初期还是比较少的，所以目前部署 h2 还是需要走加密的，不过由于 Let’s Encrypt 大力推行免费证书和证书的廉价化，部署 h2 的成本并不高。&lt;/p&gt;
&lt;h2 id=&quot;HTTP-2-0介绍&quot;&gt;&lt;a href=&quot;#HTTP-2-0介绍&quot; class=&quot;headerlink&quot; title=&quot;HTTP 2.0介绍&quot;&gt;&lt;/a&gt;HTTP 2.0介绍&lt;/h2&gt;&lt;p&gt;HTTP 2.0即超文本传输协议 2.0，是下一代HTTP协议。是由互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis (httpbis)工作小组进行开发。是自1999年http1.1发布后的首个更新。&lt;br&gt;HTTP/2 协议是从 SPDY 演变而来，SPDY 已经完成了使命并很快就会退出历史舞台（例如 Chrome 将在「2016 年初结束对 SPDY 的支持」；Nginx、Apache 也已经全面支持 HTTP/2 ，并也不再支持 SPDY）。&lt;br&gt;一般的大家把 HTTP2 简称为 h2，尽管有些朋友可能不怎么愿意，但是这个简称已经默认化了，特别是体现在浏览器对 HTTP2 都是这个简写的。&lt;br&gt;普通的 HTTPS 网站浏览会比 HTTP 网站稍微慢一些，因为需要处理加密任务，而配置了 h2 的 HTTPS，在低延时的情况下速度会比 HTTP 更快更稳定。&lt;br&gt;现在电信劫持事件频发，网站部署了 HTTPS 加密后可以杜绝大部分劫持，但不是完全。像电子商务行业对 HTTPS 加密可是标配啊，因此部署 h2 更是势在必行。&lt;/p&gt;
&lt;h2 id=&quot;环境信息&quot;&gt;&lt;a href=&quot;#环境信息&quot; class=&quot;headerlink&quot; title=&quot;环境信息&quot;&gt;&lt;/a&gt;环境信息&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;操作系统版本&lt;/th&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;res&lt;/td&gt;
&lt;td&gt;CentOS 7.0&lt;/td&gt;
&lt;td&gt;172.16.7.180&lt;/td&gt;
&lt;td&gt;Res静态资源服务器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我这里使用的Nginx是openresty-1.11.2.5。&lt;/p&gt;
&lt;h2 id=&quot;安装Nginx&quot;&gt;&lt;a href=&quot;#安装Nginx&quot; class=&quot;headerlink&quot; title=&quot;安装Nginx&quot;&gt;&lt;/a&gt;安装Nginx&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.安装依赖包&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# yum install readline-devel pcre-devel openssl-devel gcc -y
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先确认当前openssl版本，最低要求1.0.2，如果不满足，还得手动下载openssl，然后在编译时使用–with-openssl指定openssl目录。我这里是满足条件的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# openssl version
OpenSSL 1.0.2k-fips  26 Jan 2017
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.安装Openresty&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@res local]# cd /usr/local/
[root@res local]# wget https://openresty.org/download/openresty-1.11.2.5.tar.gz
[root@res local]# tar zxf openresty-1.11.2.5.tar.gz 
[root@res local]# cd openresty-1.11.2.5/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一些较低的版本里是不支持HTTP 2.0的，我这里使用的Openresty-1.11.2.5是支持的。另外，对于官方的Nginx，默认编译的 Nginx 并不包含 h2 模块，我们需要加入参数来编译，截止发文，Nginx 1.9 开发版及以上版本源码需要自己加入编译参数，从软件源仓库下载的则默认编译。 Tengine 可以同时部署 h2 和 SPDY 保证兼容性，Nginx 则是一刀切不再支持 SPDY。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#查看可供编译的参数是否有--with-http_v2_module
[root@res openresty-1.11.2.5]# ./configure --help
[root@res openresty-1.11.2.5]#./configure --with-http_v2_module
[root@res openresty-1.11.2.5]#  gmake &amp;amp;&amp;amp; gmake install
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;配置Nginx&quot;&gt;&lt;a href=&quot;#配置Nginx&quot; class=&quot;headerlink&quot; title=&quot;配置Nginx&quot;&gt;&lt;/a&gt;配置Nginx&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@res conf]# pwd
/usr/local/nginx/nginx/conf
[root@res conf]# cp nginx.conf nginx.conf.bak
[root@res conf]# vim nginx.conf
server {
    listen       80;
    server_name  res.wisedu.com;

    rewrite ^(.*)$  https://$host$1 permanent; #http强制转https

}

server {
    listen       443 ssl http2;
    server_name  res.wisedu.com;

    ssl on;
    #证书和私钥
    ssl_certificate /opt/ssl/214199023800937.pem;
    ssl_certificate_key /opt/ssl/214199023800937.key;
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于ssl使用的证书，由于是公司对外的服务环境，证书是购买的。当然做实验时也可以建立私有CA，模拟颁发证书。&lt;/p&gt;
&lt;p&gt;启动Nginx：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# systemctl start nginx.service
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;访问&lt;a href=&quot;https://res.wisedu.com，查看Nginx的access.log，可以看到协议已经是HTTP/2.0了。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://res.wisedu.com，查看Nginx的access.log，可以看到协议已经是HTTP/2.0了。&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;res.wisedu.com 172.16.0.12 [29/Jan/2018:19:54:20 +0800] &amp;quot;GET /static/img/logo.484ce8c.png HTTP/2.0&amp;quot; 200 17354 &amp;quot;https://res.wisedu.com/&amp;quot; &amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&amp;quot; 0.000 -
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近将公司前端组件的Nginx配置了http 2.0，特此在此记录一下。突然发现博客里竟然没有什么关于Nginx的文章，毕竟是一直在使用的，后面会写几篇关于自己这几年使用Nginx的一些总结。&lt;br&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Redis安装部署</title>
    <link href="http://yoursite.com/2018/01/10/Redis%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/01/10/Redis安装部署/</id>
    <published>2018-01-10T01:12:43.000Z</published>
    <updated>2018-01-10T03:45:22.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;安装Redis&quot;&gt;&lt;a href=&quot;#安装Redis&quot; class=&quot;headerlink&quot; title=&quot;安装Redis&quot;&gt;&lt;/a&gt;安装Redis&lt;/h2&gt;&lt;p&gt;我这里安装的版本是 3.2.2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@log2 ~]# yum install readline-devel pcre-devel openssl-devel -y
[root@log2 local]# tar zxf redis-3.2.2.tar.gz 
[root@log2 local]# cd redis-3.2.2/
[root@log2 redis-3.2.2]# make
[root@log2 redis-3.2.2]# make install
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;配置Redis&quot;&gt;&lt;a href=&quot;#配置Redis&quot; class=&quot;headerlink&quot; title=&quot;配置Redis&quot;&gt;&lt;/a&gt;配置Redis&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@log2 redis-3.2.2]# cp redis.conf /etc/
[root@log2 redis-3.2.2]# vim /etc/redis.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;1.配置redis后台启动&lt;/strong&gt;&lt;br&gt;打开/etc/redis.conf，将daemonize处修改为yes。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;################################# GENERAL #####################################

# By default Redis does not run as a daemon. Use &amp;apos;yes&amp;apos; if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
daemonize yes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.配置Redis持久化策略&lt;/strong&gt;&lt;br&gt;使用RDB和AOF双持久化策略：其中默认开启了RDB持久化，我们只需要开启AOF持久化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# AOF and RDB persistence can be enabled at the same time without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the file
# with the better durability guarantees.
#
# Please check http://redis.io/topics/persistence for more information.

appendonly yes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3.配置redis日志文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Specify the log file name. Also the empty string can be used to force
# Redis to log on the standard output. Note that if you use standard
# output for logging but daemonize, logs will be sent to /dev/null
logfile &amp;quot;/var/log/redis.log&amp;quot;   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4.配置数据文件存放路径，在/目录下面创建/RedisData目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@log2 redis-3.2.2]# mkdir /RedisData

 # The working directory.
#
# The DB will be written inside this directory, with the filename specified
# above using the &amp;apos;dbfilename&amp;apos; configuration directive.
#
# The Append Only File will also be created inside this directory.
#
# Note that you must specify a directory here, not a file name.
dir /RedisData
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;5.修改Redis监听地址&lt;/strong&gt;&lt;br&gt;注释掉 #bind 127.0.0.1&lt;br&gt;否则redis只会监听在127.0.0.1的某个端口上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.修改Redis监听端口&lt;/strong&gt;&lt;br&gt;为了安全，强烈建议修改redis的监听端口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Accept connections on the specified port, default is 6379 (IANA #815344).
# If port 0 is specified Redis will not listen on a TCP socket.
port 6400
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;7.在redis3.2之后，redis增加了protected-mode，在这个模式下，即使注释掉了bind 127.0.0.1，再访问redis的时候还是报错，所以要如下设置：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# By default protected mode is enabled. You should disable it only if
# you are sure you want clients from other hosts to connect to Redis
# even if no authentication is configured, nor a specific set of interfaces
# are explicitly listed using the &amp;quot;bind&amp;quot; directive.
protected-mode no
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;启动-停止&quot;&gt;&lt;a href=&quot;#启动-停止&quot; class=&quot;headerlink&quot; title=&quot;启动/停止&quot;&gt;&lt;/a&gt;启动/停止&lt;/h2&gt;&lt;p&gt;1.启动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@log2 ~]# /usr/local/bin/redis-server /etc/redis.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.停止&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@log2 ~]# /usr/local/redis-3.2.2/src/redis-cli -p 6400 shutdown
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Redis简单使用&quot;&gt;&lt;a href=&quot;#Redis简单使用&quot; class=&quot;headerlink&quot; title=&quot;Redis简单使用&quot;&gt;&lt;/a&gt;Redis简单使用&lt;/h2&gt;&lt;h3 id=&quot;使用客户端连接redis-server&quot;&gt;&lt;a href=&quot;#使用客户端连接redis-server&quot; class=&quot;headerlink&quot; title=&quot;使用客户端连接redis-server&quot;&gt;&lt;/a&gt;使用客户端连接redis-server&lt;/h3&gt;&lt;p&gt;在Redis的安装目录中有redis客户端，即redis-cli（Redis Command Line Interface），它是Redis自带的基于命令行的Redis的客户端。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# cd /usr/local/bin/
# ./redis-cli -h 172.16.206.30 -p 6400
172.16.206.30:6400&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;向Redis服务器发送命令&quot;&gt;&lt;a href=&quot;#向Redis服务器发送命令&quot; class=&quot;headerlink&quot; title=&quot;向Redis服务器发送命令&quot;&gt;&lt;/a&gt;向Redis服务器发送命令&lt;/h3&gt;&lt;p&gt;redis-cli连上redis服务后，可以在命令行发送命令。&lt;br&gt;&lt;strong&gt;1.ping，测试客户端与redis的连接是否正常，如果正常会收到回复PONG&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ./redis-cli -h 172.16.206.30 -p 6400
172.16.206.30:6400&amp;gt; ping
PONG
172.16.206.30:6400&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2.set/get，使用set和get可以向redis设置数据、获取数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;172.16.206.30:6400&amp;gt; set name wisedu
OK
172.16.206.30:6400&amp;gt; get name
&amp;quot;wisedu&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3.del，删除指定key的内容&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;172.16.206.30:6400&amp;gt; del name
(integer) 1
172.16.206.30:6400&amp;gt; get name
(nil)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4.keys *，查看当前库中所有的key&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装Redis&quot;&gt;&lt;a href=&quot;#安装Redis&quot; class=&quot;headerlink&quot; title=&quot;安装Redis&quot;&gt;&lt;/a&gt;安装Redis&lt;/h2&gt;&lt;p&gt;我这里安装的版本是 3.2.2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[root@log2 ~]# yum install readline-devel pcre-devel openssl-devel -y
[root@log2 local]# tar zxf redis-3.2.2.tar.gz 
[root@log2 local]# cd redis-3.2.2/
[root@log2 redis-3.2.2]# make
[root@log2 redis-3.2.2]# make install
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="NoSQL" scheme="http://yoursite.com/categories/NoSQL/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
</feed>
