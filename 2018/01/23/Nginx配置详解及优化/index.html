<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Nginx," />





  <link rel="alternate" href="/atom.xml" title="jkzhao's blog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.0.1" />






<meta name="description" content="上篇博文中介绍了安装部署OpenResty，这篇博文主要记录下Nginx的配置及优化。  NginxNginx的代码是由一个核心和一系列的模块组成, 核心主要用于提供Web Server的基本功能，以及Web和Mail反向代理的功能；">
<meta name="keywords" content="Nginx">
<meta property="og:type" content="article">
<meta property="og:title" content="Nginx配置详解及优化">
<meta property="og:url" content="http://yoursite.com/2018/01/23/Nginx配置详解及优化/index.html">
<meta property="og:site_name" content="jkzhao&#39;s blog">
<meta property="og:description" content="上篇博文中介绍了安装部署OpenResty，这篇博文主要记录下Nginx的配置及优化。  NginxNginx的代码是由一个核心和一系列的模块组成, 核心主要用于提供Web Server的基本功能，以及Web和Mail反向代理的功能；">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/12.png">
<meta property="og:updated_time" content="2018-04-24T10:27:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nginx配置详解及优化">
<meta name="twitter:description" content="上篇博文中介绍了安装部署OpenResty，这篇博文主要记录下Nginx的配置及优化。  NginxNginx的代码是由一个核心和一系列的模块组成, 核心主要用于提供Web Server的基本功能，以及Web和Mail反向代理的功能；">
<meta name="twitter:image" content="https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/10.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6287775856811050000,
      author: 'Author'
    }
  };
</script>

  <title> Nginx配置详解及优化 | jkzhao's blog </title>
</head>
<a href="https://github.com/you"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?c179eb46ac47d3b4b1b9203b82ee5821";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <a href="https://github.com/jkzhao"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">jkzhao's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">学习 总结 思考</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'CziK4aDdRyzFJrfygnHH','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Nginx配置详解及优化
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-01-23T15:06:27+08:00" content="2018-01-23">
              2018-01-23
            </time>
            
              <span class="post-updated">
              &nbsp; | &nbsp; 更新于
              <time itemprop="dateUpdated" datetime="2018-04-24T18:27:29+08:00" content="2018-04-24">
              2018-04-24
              </time>
              </span>
            
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Nginx/" itemprop="url" rel="index">
                    <span itemprop="name">Nginx</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          
             <span id="/2018/01/23/Nginx配置详解及优化/" class="leancloud_visitors" data-flag-title="Nginx配置详解及优化">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>上篇博文中介绍了安装部署OpenResty，这篇博文主要记录下Nginx的配置及优化。</p>
</blockquote>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx的代码是由一个核心和一系列的模块组成, 核心主要用于提供Web Server的基本功能，以及Web和Mail反向代理的功能；<a id="more"></a>还用于启用网络协议，创建必要的运行时环境以及确保不同的模块之间平滑地进行交互。不过，大多跟协议相关的功能和某应用特有的功能都是由nginx的模块实现的。这些功能模块大致可以分为事件模块、阶段性处理器、输出过滤器、变量处理器、协议、upstream和负载均衡几个类别，这些共同组成了nginx的http功能。事件模块主要用于提供OS独立的(不同操作系统的事件机制有所不同)事件通知机制如kqueue或epoll等。协议模块则负责实现nginx通过http、tls/ssl、smtp、pop3以及imap与对应的客户端建立会话。</p>
<p>Nginx的核心模块为Main和Events，此外还包括标准HTTP模块、可选HTTP模块和邮件模块，其还可以支持诸多第三方模块。Main用于配置错误日志、进程及权限等相关的参数，Events用于配置IO模型，如epoll、kqueue、select或poll等，它们是必备模块。</p>
<p>Nginx的主配置文件由几个段组成，这个段通常也被称为nginx的上下文，每个段的定义格式如下所示。需要注意的是，其每一个指令都必须使用分号(;)结束，否则为语法错误。</p>
<pre><code>&lt;section&gt; {
    &lt;directive&gt; &lt;parameters&gt;;
}
</code></pre><h2 id="配置文件有哪些"><a href="#配置文件有哪些" class="headerlink" title="配置文件有哪些"></a>配置文件有哪些</h2><p>1.主配置文件：nginx.conf<br>2.可以使用include指令引入其他地方的配置文件，比如</p>
<pre><code>include conf.d/*.conf
</code></pre><p>3.fastcgi的配置文件：</p>
<pre><code>fastcgi_params、uwsgi_params
</code></pre><p>4.配置指令(必须以分号结尾)</p>
<pre><code>Directive  value1 [value2...];

支持使用变量：
    内置变量：由模块引入；
    自定义变量：
        set  variable  value; 

    引用变量：$variable
</code></pre><h2 id="配置文件组织结构"><a href="#配置文件组织结构" class="headerlink" title="配置文件组织结构"></a>配置文件组织结构</h2><p>主配置文件结构：</p>
<pre><code>main block
event {
    ...
}
http {
    ...
    server{
        location{  
            ...          
        }           
    }
}
mail{
    ...
}
</code></pre><h2 id="配置main段"><a href="#配置main段" class="headerlink" title="配置main段"></a>配置main段</h2><p><strong>1.user USERNAME  [GROUPNAME];</strong><br>指定用于运行worker进程的用户和组，如果不设置，默认是nobody。比如：</p>
<pre><code>user  nginx  nginx;
</code></pre><p><strong>2.pid  /PATH/TO/PID_FILE;</strong><br>指定nginx进程的pid文件路径，也可以使用默认的。比如：</p>
<pre><code>pid  /var/run/nginx.pid;
</code></pre><p><strong>3.error_log</strong><br>用于配置错误日志，可用于main、http、server及location上下文中；语法格式为：</p>
<pre><code>error_log file | stderr [ debug | info | notice | warn | error | crit | alert | emerg ]
</code></pre><p>比如：</p>
<pre><code>error_log  logs/error.log debug;
</code></pre><p><strong>4.worker_processes</strong><br>worker进程是单线程进程。如果Nginx用于CPU密集型的场景中，如SSL或gzip，且主机上的CPU个数至少有2个，那么应该将此参数值设定为与CPU核心数相同；如果负载以IO密集型为主，如响应大量内容给客户端，则worker数应该为CPU个数的1.5或2倍。比如：Nginx所在服务器有2颗CPU，每颗两核，那么可以配置：</p>
<pre><code>worker_processes  4; #启动的work线程数
</code></pre><p>此参数与Events上下文中的work_connections变量一起决定了maxclient的值：<br>maxclients = work_processes * work_connections</p>
<p><strong>5.worker_cpu_affinity</strong><br>通过sched_setaffinity()将worker绑定至CPU上，只能用于main上下文。语法格式为：</p>
<pre><code>worker_cpu_affinity cpumask ...
</code></pre><p>例如：</p>
<pre><code>worker_processes     4;
worker_cpu_affinity 0001 0010 0100 1000;
</code></pre><p><strong>6.worker_priority</strong><br>为worker进程设定优先级(指定nice值)，此参数只能用于main上下文中，默认为0；语法格式为：</p>
<pre><code>worker_priority number
</code></pre><p><strong>7.worker_rlimit_nofile</strong><br>设定worker进程所能够打开的文件描述符个数的最大值。语法格式：</p>
<pre><code>worker_rlimit_nofile number
</code></pre><h2 id="配置Events段"><a href="#配置Events段" class="headerlink" title="配置Events段"></a>配置Events段</h2><p><strong>1.worker_connections</strong><br>设定每个worker所处理的最大连接数，它与来自main上下文的worker_processes一起决定了maxclients的值。</p>
<pre><code>nginx作为http服务器的时候：
max_clients = worker_processes * worker_connections
nginx作为反向代理服务器的时候：
max_clients = worker_processes * worker_connections/4
</code></pre><p><strong>2.use</strong><br>在有着多于一个的事件模型IO的应用场景中，可以使用此指令设定nginx所使用的IO机制，默认为./configure脚本选定的各机制中最适用当前OS的版本。语法格式：</p>
<pre><code>use [ kqueue | rtsig | epoll | /dev/poll | select | poll | eventport ]
</code></pre><p><strong>一个配置示例</strong></p>
<pre><code>user nginx;
# the load is CPU-bound and we have 16 cores
worker_processes 16;
error_log logs/error.log debug;
pid logs/nginx.pid;

events {
    use epoll;
    worker_connections 2048;
}
</code></pre><h2 id="配置http段"><a href="#配置http段" class="headerlink" title="配置http段"></a>配置http段</h2><p>http上下文专用于配置用于http的各模块，此类指令非常的多，每个模块都有其专用指定，具体请参数<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="external">nginx官方文档关于模块部分的说明</a>。大体上来讲，这些模块所提供的配置指令还可以分为如下几个类别。</p>
<ul>
<li>客户端类指令：如client_body_buffer_size、client_header_buffer_size、client_header_timeout和keepalive_timeout等；</li>
<li>文件IO类指令：如aio、directio、open_file_cache、open_file_cache_min_uses、open_file_cache_valid和sendfile等；</li>
<li>hash类指令：用于定义Nginx为某特定的变量分配多大的内存空间，如types_hash_bucket_size、server_names_hash_bucket_size和variables_hash_bucket_size等；</li>
<li>套接字类指令：用于定义Nginx如何处理tcp套接字相关的功能，如tcp_nodelay(用于keepalive功能启用时)和tcp_nopush(用于sendfile启用时)等；</li>
</ul>
<h3 id="套接字或主机相关配置"><a href="#套接字或主机相关配置" class="headerlink" title="套接字或主机相关配置"></a>套接字或主机相关配置</h3><pre><code>server {
    &lt;directive&gt; &lt;parameters&gt;;
}
</code></pre><p>用于定义虚拟主机相关的属性。比如：</p>
<pre><code>server {
    listen PORT; #listen指令监听在不同的端口；
    server_name NAME; #server_name指令指向不同的主机名；
    root /PATH/TO/DOCUMENTROOT;
}
</code></pre><p><strong>1.listen</strong></p>
<pre><code>listen address[:port] [default_server] [ssl] [http2 | spdy] 
listen port [default_server] [ssl] [http2 | spdy]
</code></pre><ul>
<li>default_server：设置默认虚拟主机；用于基于IP地址，或使用了任意不能对应于任何一个server的name时所返回站点；</li>
<li>ssl：用于限制只能通过ssl连接提供服务；</li>
<li>spdy：SPDY protocol（speedy），在编译了spdy模块的情况下，用于支持SPDY协议；</li>
<li>http2：http version 2；</li>
</ul>
<p><strong>2.server_name NAME […];</strong><br>后可跟一个或多个主机名；名称还可以使用通配符和正则表达式(~)；</p>
<ul>
<li>首先做精确匹配；例如：www.wisedu.com</li>
<li>左侧通配符；例如：*.wisedu.com</li>
<li>右侧通配符，例如：www.wisedu.*</li>
<li>正则表达式，例如：~^.*.wisedu.com$</li>
<li>default_server </li>
</ul>
<p><strong>3.tcp_nodelay on|off;</strong></p>
<pre><code>Syntax:    tcp_nodelay on | off;
Default:    tcp_nodelay on;
Context:    http, server, location
</code></pre><p>对keepalive模式下的连接是否使用TCP_NODELAY选项；</p>
<p><strong>4.tcp_nopush on|off;</strong></p>
<pre><code>Syntax:    tcp_nopush on | off;
Default:    tcp_nopush off;
Context:    http, server, location
</code></pre><p>是否启用TCP_NOPUSH(FREEBSE）或TCP_CORK(Linux)选项；仅在sendfile为on时有用；<br><strong>tcp_nopush和tcp_nodelay选项：</strong><br><strong>先来了解下Nagle算法：</strong><br>在网络拥塞控制领域，有一个非常有名的算法叫做<strong>Nagle算法（Nagle algorithm）</strong>，这是使用它的发明人John Nagle的名字来命名的，John Nagle在1984年首次用这个算法来尝试解决福特汽车公司的网络拥塞问题（RFC 896），该问题的具体描述是：如果我们的应用程序一次产生1个字节的数据，而这个1个字节数据又以网络数据包的形式发送到远端服务器，那么就很容易导致网络由于太多的数据包而过载。比如，当用户使用Telnet连接到远程服务器时，每一次击键操作就会产生1个字节数据，进而发送出去一个数据包，所以，在典型情况下，传送一个只拥有1个字节有效数据的数据包，却要发费40个字节长包头（即ip头20字节+tcp头20字节）的额外开销，这种有效载荷（payload）利用率极其低下的情况被统称之为愚蠢窗口症候群（Silly Window Syndrome）。可以看到，这种情况对于轻负载的网络来说，可能还可以接受，但是对于重负载的网络而言，就极有可能承载不了而轻易的发生拥塞瘫痪。<br>针对上面提到的这个状况，Nagle算法的改进在于：如果发送端欲多次发送包含少量字符的数据包（一般情况下，后面统一称长度小于MSS的数据包为小包，与此相对，称长度等于MSS的数据包为大包，为了某些对比说明，还有中包，即长度比小包长，但又不足一个MSS的包），则发送端会先将第一个小包发送出去，而将后面到达的少量字符数据都缓存起来而不立即发送，直到收到接收端对前一个数据包报文段的ACK确认、或当前字符属于紧急数据，或者积攒到了一定数量的数据（比如缓存的字符数据已经达到数据包报文段的最大长度）等多种情况才将其组成一个较大的数据包发送出去。<br>TCP中的Nagle算法默认是启用的，但是它并不是适合任何情况，对于telnet或rlogin这样的远程登录应用的确比较适合（原本就是为此而设计），但是在某些应用场景下我们却又需要关闭它。<br>Nagle算法是指发送方发送的数据不会立即发出, 而是先放在缓冲区, 等缓存区满了再发出。发送完一批数据后, 会等待接收方对这批数据的回应, 然后再发送下一批数据。Negale 算法适用于发送方需要发送大批量数据, 并且接收方会及时作出回应的场合, 这种算法通过减少传输数据的次数来提高通信效率。如果发送方持续地发送小批量的数据, 并且接收方不一定会立即发送响应数据, 那么Negale算法会使发送方运行很慢. 对于GUI 程序, 如网络游戏程序(服务器需要实时跟踪客户端鼠标的移动), 这个问题尤其突出。客户端鼠标位置改动的信息需要实时发送到服务器上, 由于Negale 算法采用缓冲, 大大减低了实时响应速度, 导致客户程序运行很慢。这个时候就需要使用TCP_NODELAY选项。</p>
<p><strong>tcp_nopush</strong><br>官方:</p>
<pre><code>tcp_nopush
Syntax: tcp_nopush on | off
Default: off
Context: http, server, location
Reference: tcp_nopush

This directive permits or forbids the use of thesocket options TCP_NOPUSH on FreeBSD or TCP_CORK on Linux. This option is onlyavailable when using sendfile.
Setting this option causes nginx to attempt to sendit’s HTTP response headers in one packet on Linux and FreeBSD 4.x
You can read more about the TCP_NOPUSH and TCP_CORKsocket options here.
</code></pre><p>linux 下是tcp_cork，上面的意思就是说，当使用sendfile函数时，tcp_nopush才起作用，它和指令tcp_nodelay是互斥的。tcp_cork是linux下tcp/ip传输的一个标准了，这个标准的大概的意思是，一般情况下，在tcp交互的过程中，当应用程序接收到数据包后马上传送出去，不等待，而tcp_cork选项是数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞。<br>也就是说tcp_nopush = on 会设置调用tcp_cork方法，这个也是默认的，结果就是数据包不会马上传送出去，等到数据包最大时，一次性的传输出去，这样有助于解决网络堵塞。<br>以快递投递举例说明一下（以下是我的理解，也许是不正确的），当快递东西时，快递员收到一个包裹，马上投递，这样保证了即时性，但是会耗费大量的人力物力，在网络上表现就是会引起网络堵塞，而当快递收到一个包裹，把包裹放到集散地，等一定数量后统一投递，这样就是tcp_cork的选项干的事情，这样的话，会最大化的利用网络资源，虽然有一点点延迟。<br>对于nginx配置文件中的tcp_nopush，tcp_nopush on;这个选项对于www，ftp等大文件很有帮助。</p>
<p><strong>tcp_nodelay</strong><br>TCP_NODELAY和TCP_CORK基本上控制了包的“Nagle化”，Nagle化在这里的含义是采用Nagle算法把较小的包组装为更大的帧。 John Nagle是Nagle算法的发明人，后者就是用他的名字来命名的，他在1984年首次用这种方法来尝试解决福特汽车公司的网络拥塞问题（欲了解详情请参看IETF RFC 896）。他解决的问题就是所谓的silly window syndrome，中文称“愚蠢窗口症候群”，具体含义是，因为普遍终端应用程序每产生一次击键操作就会发送一个包，而典型情况下一个包会拥有一个字节的数据载荷以及40个字节长的包头，于是产生4000%的过载，很轻易地就能令网络发生拥塞,。 Nagle化后来成了一种标准并且立即在因特网上得以实现。它现在已经成为缺省配置了，但在我们看来，有些场合下把这一选项关掉也是合乎需要的。<br>现在让我们假设某个应用程序发出了一个请求，希望发送小块数据。我们可以选择立即发送数据或者等待产生更多的数据然后再一次发送两种策略。如果我们马上发送数据，那么交互性的以及客户/服务器型的应用程序将极大地受益。如果请求立即发出那么响应时间也会快一些。以上操作可以通过设置套接字的TCP_NODELAY = on 选项来完成，这样就禁用了Nagle 算法。<br>另外一种情况则需要我们等到数据量达到最大时才通过网络一次发送全部数据，这种数据传输方式有益于大量数据的通信性能，典型的应用就是文件服务器。应用 Nagle算法在这种情况下就会产生问题。但是，如果你正在发送大量数据，你可以设置TCP_CORK选项禁用Nagle化，其方式正好同 TCP_NODELAY相反（TCP_CORK和 TCP_NODELAY是互相排斥的）。</p>
<p><strong>5.sendfile on|off;</strong><br>是否启用sendfile功能；<br>先来看下nginx作为web服务器的工作方式：<br>用户请求进来了，先到达网卡，由内核处理下交给了监听在80套接字上的应用程序，即交给worker进程，这个worker进程通过连接建立、通过接入分析发现用户请求的是一个静态页面，下面就是I/O了。首先进程向内核发出系统调用。内核为它准备一个缓冲，然后内核从磁盘中加载这个文件到缓冲中，然后将这个文件复制给worker进程自己的地址空间，然后进程将这个文件封装成响应报文，这个封装过程是，进程封装http请求首部，然后交给内核封装TCP首部、IP首部，然后交给客户端。<br><img src="https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/10.png" alt=""><br>然后你会发现这个文件是这么走的：从硬盘到内核空间，从内核到用户空间，从用户空间再到内核空间，白白绕一圈。如果说这个请求直接在内核中就封装好(http请求首部封装其实也是在内核封装的)，这样就避免了两次复制(注意是复制，内核任何时候和进程交互都是复制，除非共享内存)。复制虽然时间短，但是架不住多啊。<br><img src="https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/11.png" alt=""><br>这就是sendfile机制，读过来就响应了。send只支持很小的文件，sendfile64支持更大的文件。<br>现在流行的web 服务器里面都提供 sendfile 选项用来提高服务器性能，那到底 sendfile是什么，怎么影响性能的呢？<br>sendfile实际上是 Linux2.0+以后的推出的一个系统调用，web服务器可以通过调整自身的配置来决定是否利用sendfile这个系统调用。先来看一下不用 sendfile的传统网络传输过程：</p>
<pre><code>read(file,tmp_buf, len);
write(socket,tmp_buf, len);
</code></pre><p>硬盘 &gt;&gt; kernel buffer &gt;&gt; user buffer&gt;&gt; kernel socket buffer &gt;&gt;协议栈<br>一般来说一个网络应用是通过读硬盘数据，然后写数据到socket 来完成网络传输的。上面2行用代码解释了这一点，不过上面2行简单的代码掩盖了底层的很多操作。来看看底层是怎么执行上面2行代码的：</p>
<ul>
<li>①系统调用 read()产生一个上下文切换：从 user mode 切换到 kernel mode，然后 DMA 执行拷贝，把文件数据从硬盘读到一个 kernel buffer 里。</li>
<li>②数据从 kernel buffer拷贝到 user buffer，然后系统调用 read() 返回，这时又产生一个上下文切换：从kernel mode 切换到 user mode。</li>
<li>③系统调用write()产生一个上下文切换：从 user mode切换到 kernel mode，然后把步骤2读到 user buffer的数据拷贝到 kernel buffer（数据第2次拷贝到 kernel buffer），不过这次是个不同的 kernel buffer，这个 buffer和 socket相关联。</li>
<li><p>④系统调用 write()返回，产生一个上下文切换：从 kernel mode 切换到 user mode（第4次切换了），然后 DMA 从 kernel buffer拷贝数据到协议栈（第4次拷贝了）。<br>上面4个步骤有4次上下文切换，有4次拷贝，我们发现如果能减少切换次数和拷贝次数将会有效提升性能。在kernel2.0+ 版本中，系统调用 sendfile() 就是用来简化上面步骤提升性能的。sendfile() 不但能减少切换次数而且还能减少拷贝次数。<br>再来看一下用 sendfile() 来进行网络传输的过程：</p>
<p>  sendfile(socket,file, len);<br>  硬盘 &gt;&gt; kernel buffer (快速拷贝到kernel socket buffer) &gt;&gt;协议栈</p>
</li>
<li><p>①系统调用sendfile()通过 DMA把硬盘数据拷贝到 kernel buffer，然后数据被 kernel直接拷贝到另外一个与 socket相关的 kernel buffer。这里没有 user mode和 kernel mode之间的切换，在 kernel中直接完成了从一个 buffer到另一个buffer的拷贝。</p>
</li>
<li>②DMA 把数据从 kernelbuffer 直接拷贝给协议栈，没有切换，也不需要数据从 user mode 拷贝到 kernel mode，因为数据就在 kernel 里。<br>步骤减少了，切换减少了，拷贝减少了，自然性能就提升了。这就是为什么说在 Nginx 配置文件里打开 sendfile on 选项能提高 web server性能的原因。<br><img src="https://raw.githubusercontent.com/jkzhao/MarkdownPictures/master/Nginx/12.png" alt=""></li>
</ul>
<p><strong>4.gzip  on;</strong><br>对于响应用户的内容是不是先压缩再发送，可以节省带宽。如果网络带宽小，用户访问量大的话可以使用这种方式。</p>
<h3 id="路径相关的指令"><a href="#路径相关的指令" class="headerlink" title="路径相关的指令"></a>路径相关的指令</h3><p><strong>1.root</strong><br>设置web资源的路径映射；用于指明请求的URL所对应的文档的目录路径；</p>
<pre><code>server {
    ...
    root  /data/www/vhost1;
}
http://www.wisedu.com/images/logo.jpg --&gt; /data/www/vhosts/images/logo.jpg

server {
    ...
    server_name  www.wisedu.com;

    location /images/ {
         root  /data/imgs/;
         ...
    }
}
http://www.wisedu.com/images/logo.jpg --&gt; /data/imgs/images/logo.jpg
</code></pre><p><strong>2.location [ = | ~ | ~* | ^~ ] uri { … }<br>  location @name { … }</strong><br>功能：允许根据用户请求的URI来匹配定义的各location，匹配到时，此请求将被相应的location块中的配置所处理；简言之，即用于为需要用到专用配置的uri提供特定配置。<br><strong>先来看下location [ = | ~ | ~* | ^~ ] uri { … } </strong></p>
<ul>
<li>location URI{}：对当前路径及所有对象都生效。</li>
<li>location = URI{}：只对当前路径生效，不包括子路径。这是精确匹配。</li>
<li>location ~ URI{}：</li>
<li>location ~<em> URI{}：模式匹配URI，此处的URI可使用正则表达式，~区分字符大小写。~</em>不区分字符大小写。</li>
<li>location ^~ URI{}：明确说明不使用正则表达式。</li>
</ul>
<p>【注意】：如果被两个location匹配到，nginx是有优先级的。=优先级最高，^~优先级第二，模式匹配优先级第三，没加任何符号的优先级最低。<br>官方例子：<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location" target="_blank" rel="external">http://nginx.org/en/docs/http/ngx_http_core_module.html#location</a></p>
<pre><code>location = / {
    [ configuration A ]
}

location / {
    [ configuration B ]
}

location /documents/ {
    [ configuration C ]
}

location ^~ /images/ {
    [ configuration D ]
}

location ~* \.(gif|jpg|jpeg)$ {
    [ configuration E ]
}
The “/” request will match configuration A, the “/index.html” request will match configuration B, the “/documents/document.html” request will match configuration C, the “/images/1.gif” request will match configuration D, and the “/documents/1.jpg” request will match configuration E.
</code></pre><p>补充一个，</p>
<pre><code>location / {
    [ configuration A ]
}
location /abc {
    [ configuration B ]
}
</code></pre><p>访问 <a href="http://ip:port/abc" target="_blank" rel="external">http://ip:port/abc</a> 将被 location /abc 匹配到。</p>
<p><strong>再来看下location @name { … }，命名的location</strong><br>The “@” prefix defines a named location. Such a location is not used for a regular request processing, but instead used for request redirection. They cannot be nested, and cannot contain nested locations.<br>@：内部服务跳转</p>
<pre><code>server {
  location /img/ {
    set $memcached_key $uri;
    memcached_pass     name:11211;
    default_type       text/html;
    error_page         404 @fallback; #以 /img/ 开头的请求，如果连接的状态为 404。则会匹配到 @fallback 这条规则上。
  }

  location @fallback {
    proxy_pass http://backend;
  } 
}
</code></pre><p><strong>3.alias</strong><br>定义路径别名。</p>
<pre><code>location  /images/ {
    root /data/imgs/;
}

location  /images/  {
    alias /data/imgs/;
}
</code></pre><p>访问/images/test.jpg，对应的结果如下：</p>
<ul>
<li>root指令：给定的路径对应于location的“/”这个URL；<br>/images/test.jpg –&gt;  /data/imgs/images/test.jpg </li>
<li>alias指令：给定的路径对应于location的“/uri/“这个URL；<br>/images/test.jpg –&gt;  /data/imgs/test.jpg，注意alias把location后配置的路径images丢弃掉了。</li>
</ul>
<p>【注意】：</p>
<ul>
<li>使用alias时，目录名后面一定要加”/“。</li>
<li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</li>
<li>alias只能位于location块中。（root可以不放在location中）</li>
</ul>
<p><strong>4.index</strong> </p>
<pre><code>index file ...;
</code></pre><p>设置默认主页面。</p>
<p><strong>5.error_page code … [=[response]] uri;</strong><br>根据http的状态码重定向错误页面；</p>
<pre><code>error_page  404  /404.html
error_page  404  =200  /404.html  （以指定的响应状态码进行响应）
</code></pre><p><strong>6.try_files file … uri;<br>  try_files file … =code;</strong><br>其作用是按顺序检查文件是否存在，尝试查找第1至第N-1个文件，返回第一个找到的文件或文件夹（结尾加斜线表示为文件夹），如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。（必须不能匹配至当前location，而应该匹配至其它location，否则会导致死循环）。</p>
<pre><code>location / {
    try_files $uri $uri/ @fallback; # $uri为Nginx内置变量，下面会讲到。
    root   /home/data/FS/desgin_style/;
}

location @fallback {
    proxy_pass_header Server;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Scheme $scheme;

    proxy_pass http://backend;
}
</code></pre><h3 id="客户端请求相关的配置"><a href="#客户端请求相关的配置" class="headerlink" title="客户端请求相关的配置"></a>客户端请求相关的配置</h3><p><strong>1.keepalive_timeout timeout [header_timeout];</strong><br>设定keepalive连接的超时时长；0表示禁止长连接；默认为75s。<br>KeepAlive，意思为是否长连接。如果设置了超时时间，那么在这个时间内，那么当Nginx完成用户的请求后，那么Nginx进程不会断开用户的请求连接，依然保持连接状态。设置成0s则当Nginx完成用户的请求后，那么Nginx进程会立即断开和用户的请求连接。<br>完成用户的请求后，连接依然存在着，这样的好处是：当该用户的请求在过来时，Nginx会用这个已经建立的连接，不需要重新创建连接。这样会节省CPU的资源。但是却耗费了内存。为什么呢？可以假设这样的场景。假如keepalive 超时时间为10s，而每1s中有100个用户请求访问，每个用户3次连接，每个连接耗费2M内存，那么10s内建立的连接次数为1000次（跟用户每s请求次数无关），消耗内存为1000x2=2000M，相反，如果不保持长连接，同样的环境场景下，每1s内有100x3个连接，下一秒还是100x3个连接，也就是说永远都是100x3个连接，那么1s内甚至10s内消耗的内存为100x3x2=600M。 然而，在这10s内创建的连接次数100x3x10=3000次，这样肯定消耗了更多的cpu资源。毕竟每次tcp连接都是需要cpu去处理的。<br>问题来了，既然知道长连接与否的利与弊，那么如何判定什么时候On，什么时候Off？<br>在上面的举例中，涉及到了一个数，那就是每个用户在1s内请求的次数，如果把3改为1，是不是10s内得到的连接次数总和是一样的。那么这样无论是On还是Off，消耗的CPU资源是一样的。所以，我们考虑3种情况：</p>
<ul>
<li>①用户浏览一个网页时，除了网页本身外，还引用了多个 javascript 文件，多个 css 文件，多个图片文件，并且这些文件都在同一个 HTTP 服务器上。</li>
<li>②用户浏览一个网页时，除了网页本身外，还引用一个 javascript 文件，一个图片文件。</li>
<li>③用户浏览的是一个动态网页，由程序即时生成内容，并且不引用其他内容。<br>对于上面3中情况，我认为：1 最适合打开 KeepAlive ，2 随意，3 最适合关闭 KeepAlive（连接消耗的内存比较大）</li>
</ul>
<p>总结一下：<br>在内存非常充足的服务器上，不管是否关闭 KeepAlive 功能，服务器性能不会有明显变化；<br>如果服务器内存较少，或者服务器有非常大量的文件系统访问时，或者主要处理动态网页服务，关闭 KeepAlive 后可以节省很多内存，而节省出来的内存用于文件系统Cache，可以提高文件系统访问的性能，并且系统会更加稳定。<br>目前的服务器，CPU很强，所以不用考虑频繁的tcp连接对cpu造成的压力，那还让它长连接干什么，故，建议关闭你的长连接吧！！！<br>PS： 如果，你的服务器上请求量很大，那你最好还是关闭这个参数吧。我试过一次，打开长连接，并且设置超时时间为30s，结果仅仅十几s就把所有的Nginx进程跑满。这样很危险的，直接让用户等待，等30s，这不扯淡嘛？即使是你设置成3s，照样会让用户等待3s，这样很不合理的。所以，归根结蒂还是关闭长连接吧，这样效率会更高。</p>
<p>举个网上的具体例子：</p>
<ul>
<li>1.项目环境：nginx（前段代理，仅作代理用途）+3个tomcat（都在同一个服务器上），做的web项目</li>
<li>2.涉及到的业务逻辑：文件上传（可能有大文件，比如说android游戏，100m）；客户端接口请求；网站后台管理</li>
<li>3.问题重现流程：<ul>
<li>3.1 配置好tomcat后，直接加上nginx前段代理（仅配置了http代理）</li>
<li>3.2 问题一：当管理员后台上传文件时，大文件无法上传成功，出现time-out，经重复测试，发现上传时间超过1分钟以后，就会返回超时信息，小文件没有问题</li>
<li>3.3 经调研得知nginx默认设置的http连接超时时间为75s，超过75s，会断掉当前的http连接，而大文件上传时经常会超过75s，这就导致大文件无法上传成功，当时的解决方案是，设置nginx http连接超时时间为30分钟，即参数keepalive_timeout=1800；文件上传问题基本解决；</li>
<li>3.4项目运行2天后，发现服务器突然宕机了，重启nginx可以解决问题，但是2个小时后又再次宕机，重启nginx又解决了问题，调研了一个中午，并且查看nginx的错误日志（socket() failed (24: Too many open files) while connecting to upstream），发现问题来源与nginx的连接数（设置的默认值为1024）达到上限</li>
<li>3.5发现这个问题后，我就想应该把nginx的连接数调大点，于是设置 worker_connections  10240；重启nginx，短时间没有出现问题，但是运行过程中，我再次查看错误日志，发现（socket() failed (24: Too many open files) while connecting to upstream）时不时的出现</li>
<li>3.6 此时发现调整nginx的连接数并不能完全解决问题，于是google，百度之，发现问题所在，罪魁祸首是：nginx的keepalive_timeout(参看<a href="http://fengzheng369.blog.163.com/blog/static/752209792012418103813580/" target="_blank" rel="external">http://fengzheng369.blog.163.com/blog/static/752209792012418103813580/</a> )设置项时间太长，客户端接口访问其实是一个比较快速的过程，访问完成了已经不需要继续使用http连接了，但是由于对nginx的错误配置，导致接口访问完成后http连接并没有被释放掉，所以导致连接数越来越大，最终nginx崩溃。</li>
</ul>
</li>
<li>4.那么这个问题应该如何解决呢？<br>将keepalive_timeout时间调小会导致上传操作可能无法完成；调大点的话，许多无效的http连接占据着nginx的连接数。这貌似是一个两难的问题。<br>解决方案一：将接口请求，后台管理，文件上传这三个业务逻辑分开，nginx对这三种业务逻辑分开转发，每个业务逻辑单独设置一个keepalive-timeout(未实验)。</li>
</ul>
<p><strong>2.keepalive_requests number;</strong><br>在keepalived连接上所允许请求的最大资源数量；默认为100；</p>
<p><strong>3.keepalive_disable none | browser …;</strong><br>指明禁止为何种浏览器使用keepalive功能；</p>
<p><strong>4.send_timeout #;</strong><br>发送响应报文的超时时长，默认为60s; </p>
<p><strong>5.client_body_buffer_size size;</strong><br>接收客户请求报文body的缓冲区大小；默认为16k；超出此指定大小时，其将被移存于磁盘上；</p>
<p><strong>6.client_body_temp_path path [level1 [level2 [level3]]];</strong><br>设定用于存储客户端请求body的临时存储路径及子目录结构和数量；</p>
<pre><code>client_body_temp_path  /var/tmp/client_body  2 2;
</code></pre><p><strong>7.client_max_body_size 10m;</strong><br>允许客户端请求的最大的单个文件字节数，这个参数可以限制body的大小，默认是1m。如果上传的文件较大，那么需要调大这个参数。</p>
<h3 id="对客户端请求的进行限制"><a href="#对客户端请求的进行限制" class="headerlink" title="对客户端请求的进行限制"></a>对客户端请求的进行限制</h3><p><strong>1.limit_excpet  METHOD {…}</strong><br>对指定范围之外的其它的方法进行访问控制；</p>
<pre><code>limit_except  GET {
    allow  172.16.0.0/16;
    deny all;
}
</code></pre><p><strong>2.对客户端限速</strong><br>我们经常会遇到这种情况，服务器流量异常，负载过大等等。对于大流量恶意的攻击访问，会带来带宽的浪费，服务器压力，影响业务，往往考虑对同一个ip的连接数，并发数进行限制。下面说说ngx_http_limit_conn_module 模块来实现该需求。该模块可以根据定义的键来限制每个键值的连接数，如同一个IP来源的连接数。并不是所有的连接都会被该模块计数，只有那些正在被处理的请求（这些请求的头信息已被完全读入）所在的连接才会被计数。<br>nginx的限速功能通过limit_zone、limit_conn和limit_rate指令进行配置。首先需要在http上下文配置一个limit_zone，然后在需要的地方使用limit_conn和limit_rate 进行限速设置。</p>
<p><strong>limit_conn_zone</strong></p>
<pre><code>语法: limit_conn_zone $variable zone=name:size;
默认值: none
配置段: http
该指令描述会话状态存储区域。键的状态中保存了当前连接数，键的值可以是特定变量的任何非空值（空值将不会被考虑）。$variable定义键，zone=name定义区域名称，后面的limit_conn指令会用到的。size定义各个键共享内存空间大小。如：

limit_conn_zone $binary_remote_addr zone=addr:10m;
</code></pre><p>【说明】：</p>
<ul>
<li>客户端的IP地址作为键。注意，这里使用的是$binary_remote_addr变量，而不是$remote_addr变量。</li>
<li>$remote_addr变量的长度为7字节到15字节，而存储状态在32位平台中占用32字节或64字节，在64位平台中占用64字节。</li>
<li>$binary_remote_addr变量的长度是固定的4字节，存储状态在32位平台中占用32字节或64字节，在64位平台中占用64字节。</li>
<li>1M共享空间可以保存3.2万个32位的状态，1.6万个64位的状态。如果共享内存空间被耗尽，服务器将会对后续所有的请求返回 503 (Service Temporarily Unavailable) 错误。</li>
<li>limit_zone 指令和limit_conn_zone指令同等意思，已经被弃用，就不再做说明了。</li>
</ul>
<p><strong>limit_conn</strong><br>语法：limit_conn zone_name number<br>默认值：none<br>配置段：http, server, location<br>指定每个给定键值的最大同时连接数，当超过这个数字时被返回503 (Service Temporarily Unavailable)错误。如：</p>
<pre><code>limit_conn_zone $binary_remote_addr zone=addr:10m;
server {
    location /www.ttlsa.com/ {
        limit_conn addr 1;
    }
}
</code></pre><p>同一IP同一时间只允许有一个连接。<br>当多个 limit_conn 指令被配置时，所有的连接数限制都会生效。比如，下面配置不仅会限制单一IP来源的连接数，同时也会限制单一虚拟服务器的总连接数：</p>
<pre><code>limit_conn_zone $binary_remote_addr zone=perip:10m;
limit_conn_zone $server_name zone=perserver:10m;
server {
    limit_conn perip 10;
    limit_conn perserver 100;
}
</code></pre><p><strong>limit_rate</strong><br>语法：limit_rate rate<br>默认值：0<br>配置段：http, server, location, if in location<br>对每个连接的速率限制。参数rate的单位是字节/秒，设置为0将关闭限速。 按连接限速而不是按IP限制，因此如果某个客户端同时开启了两个连接，那么客户端的整体速率是这条指令设置值的2倍。</p>
<h3 id="Nginx反向代理配置"><a href="#Nginx反向代理配置" class="headerlink" title="Nginx反向代理配置"></a>Nginx反向代理配置</h3><p>Nginx通过proxy模块实现反向代理功能。在作为web反向代理服务器时，nginx负责接收客户请求，并能够根据URI、客户端参数或其它的处理逻辑将用户请求调度至上游服务器上(upstream server)。nginx在实现反向代理功能时的最重要指令为proxy_pass，它能够将location定义的某URI代理至指定的上游服务器(组)上。如下面的示例中，location的/uri将被替换为上游服务器上的/newuri。</p>
<pre><code>location /uri {
    proxy_pass http://www.magedu.com:8080/newuri; # 指定将请求代理至upstream server的URL路径；
} 
</code></pre><p>补充：<strong>上游</strong>，有发源的意思。故上游服务器指的产生内容的服务器。</p>
<p>不过，这种处理机制中有两个例外。一个是如果location的URI是通过模式匹配定义的，其URI将直接被传递至上游服务器，而不能为其指定转换的另一个URI。例如下面示例中的/forum将被代理为<a href="http://www.magedu.com/forum。" target="_blank" rel="external">http://www.magedu.com/forum。</a></p>
<pre><code>location ~ ^/bbs {
    proxy_pass http://www.magedu.com;
}
</code></pre><p>第二个例外是，如果在loation中使用的URL重定向，那么nginx将使用重定向后的URI处理请求，而不再考虑上游服务器上定义的URI。如下面所示的例子中，传送给上游服务器的URI为/index.php?page=<match>，而不是/index。</match></p>
<pre><code>location / {
    rewrite /(.*)$ /index.php?page=$1 break;
    proxy_pass http://localhost:8080/index;
}
</code></pre><h4 id="proxy模块的指令"><a href="#proxy模块的指令" class="headerlink" title="proxy模块的指令"></a>proxy模块的指令</h4><p>proxy模块的可用配置指令非常多，它们分别用于定义proxy模块工作时的诸多属性，如连接超时时长、代理时使用http协议版本等。下面对常用的指令做一个简单说明。</p>
<ul>
<li>proxy_connect_timeout：nginx将一个请求发送至upstream server之前等待的最大时长；</li>
<li>proxy_cookie_domain：将upstream server通过Set-Cookie首部设定的domain属性修改为指定的值，其值可以为一个字符串、正则表达式的模式或一个引用的变量；</li>
<li>proxy_cookie_path: 将upstream server通过Set-Cookie首部设定的path属性修改为指定的值，其值可以为一个字符串、正则表达式的模式或一个引用的变量；</li>
<li>proxy_hide_header：设定发送给客户端的报文中需要隐藏的首部；</li>
<li>proxy_pass：指定将请求代理至upstream server的URL路径；</li>
<li>proxy_set_header：将发送至upsream server的报文的某首部进行重写；</li>
<li>proxy_redirect：重写location并刷新从upstream server收到的报文的首部；</li>
<li>proxy_send_timeout：在连接断开之前两次发送至upstream server的写操作的最大间隔时长；</li>
<li>proxy_read_timeout：在连接断开之前两次从接收upstream server接收读操作的最大间隔时长；</li>
</ul>
<p>如下面的一个示例：</p>
<pre><code>proxy_redirect off;
proxy_set_header Host $host;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
client_max_body_size 10m;
client_body_buffer_size 128k;
proxy_connect_timeout 30;
proxy_send_timeout 15;
proxy_read_timeout 15;
</code></pre><p><strong>nginx proxy_pass 后面的url 加与不加/的区别：</strong><br>在nginx中配置proxy_pass时，当在后面的url加上了/，相当于是绝对根路径，则nginx不会把location中匹配的路径部分代理走;如果没有/，则会把匹配的路径部分也给代理走。<br>下面四种情况分别用<a href="http://192.168.1.4/proxy/test.html" target="_blank" rel="external">http://192.168.1.4/proxy/test.html</a> 进行访问。</p>
<p>第一种：</p>
<pre><code>location  /proxy/ {
    proxy_pass http://127.0.0.1:81/;
}
会被代理到http://127.0.0.1:81/test.html 这个url
</code></pre><p>第二种(相对于第一种，最后少一个 /)</p>
<pre><code>location  /proxy/ {
    proxy_pass http://127.0.0.1:81;
}
会被代理到http://127.0.0.1:81/proxy/test.html 这个url
</code></pre><p>第三种：</p>
<pre><code>location  /proxy/ {
    proxy_pass http://127.0.0.1:81/ftlynx/;
}
会被代理到http://127.0.0.1:81/ftlynx/test.html 这个url。
</code></pre><p>第四种情况(相对于第三种，最后少一个 / )：</p>
<pre><code>location  /proxy/ {
    proxy_pass http://127.0.0.1:81/ftlynx;
}
会被代理到http://127.0.0.1:81/ftlynxtest.html 这个url
</code></pre><p><strong>location后加/和不加/的区别</strong><br>首先是location进行的是模糊匹配</p>
<ul>
<li>没有“/”时，location /abc/def可以匹配/abc/defghi请求，也可以匹配/abc/def/ghi等</li>
<li>而有“/”时，location /abc/def/不能匹配/abc/defghi请求，只能匹配/abc/def/anything这样的请求</li>
</ul>
<h4 id="Nginx实现负载均衡-–upstream模块"><a href="#Nginx实现负载均衡-–upstream模块" class="headerlink" title="Nginx实现负载均衡 –upstream模块"></a>Nginx实现负载均衡 –upstream模块</h4><p>与proxy模块结合使用的模块中，最常用的当属upstream模块。upstream模块可定义一个新的上下文，它包含了一组服务器，这些服务器可能被赋予了不同的权重、不同的类型甚至可以基于维护等原因被标记为down。直白点就是说如果后端一个服务器是在抗不住了，nginx还可以代理用户请求至多个服务器，也就是一个location里定义多个服务器，即实现负载均衡的效果。还能检查后端server的健康状况。<br>例如：</p>
<pre><code>upstream backend {
    server 172.16.7.151:8080 weight=5;
    server 172.16.7.152:8090 weight=3;
}

server {
    listen 80;
    server_name www.wisedu.com;

    location / {
        proxy_pass http://backend;
    }

}
</code></pre><p>server也可以使用域名，但是需要内网有DNS服务器，或者在hosts文件做解析。也可以是IP:port。<br>upstream模块定义在http段，可以定义多个upstream，但是每一个都要有自己独立的名称。</p>
<p>upstream模块常用的指令有：</p>
<ul>
<li>ip_hash：基于客户端IP地址完成请求的分发，它可以保证来自于同一个客户端的请求始终被转发至同一个upstream服务器；<pre><code>upstream lb {
       ip_hash;
       server 172.16.7.151:8080;
       server 172.16.7.152:8090;
}
</code></pre></li>
<li>keepalive：每个worker进程为发送到upstream服务器的连接所缓存的个数；</li>
<li>least_conn：最少连接调度算法；检查后端的连接状况，挑一个当前连接数最少的来负责响应。</li>
<li>server：定义一个upstream服务器的地址，还可包括一系列可选参数，如：<ul>
<li>weight：权重；</li>
<li>max_fails：最大失败连接次数，失败连接的超时时长由fail_timeout指定；</li>
<li>fail_timeout：等待请求的目标服务器发送响应的时长；</li>
<li>backup：用于fallback的目的，所有服务均故障时才启动此服务器；</li>
<li>down：手动标记其不再处理任何请求；</li>
</ul>
</li>
</ul>
<p>upstream模块的负载均衡算法主要有三种，轮调(round-robin)、ip哈希(ip_hash)和最少连接(least_conn)三种。默认是轮调算法。</p>
<p><strong>健康状况检查</strong><br>如果某台机器挂了怎么办？可以进行健康状况检查。</p>
<pre><code>upstream webserv {
    server 172.16.7.151:8080 weight=1 max_fails=2 fail_timeout=2;
    server 172.16.7.152:8090 weight=1 max_fails=2 fail_timeout=2;
}
</code></pre><p>健康状况检查还应该有一个功能，万一所有服务器都宕掉怎么办？必须要有个Sorry-Server，下面以本机作为Sorry-Server，可以在定义个虚拟主机:</p>
<pre><code>server {
    listen 8080;
    server_name localhost;

    root /web/errorpages;
    index index.html
}
</code></pre><p>upstream添加配置：</p>
<pre><code>upstream webserv {
    server 172.16.7.151:8080 weight=1 max_fails=2 fail_timeout=2;
    server 172.16.7.152:8090 weight=1 max_fails=2 fail_timeout=2;
    server 127.0.0.1:8080 backup;
}
</code></pre><p>backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</p>
<h3 id="Nginx的URL重写功能和if指令"><a href="#Nginx的URL重写功能和if指令" class="headerlink" title="Nginx的URL重写功能和if指令"></a>Nginx的URL重写功能和if指令</h3><h4 id="URL重写rewrite"><a href="#URL重写rewrite" class="headerlink" title="URL重写rewrite"></a>URL重写rewrite</h4><p><strong>1.什么叫rewrite</strong><br>举个例子：</p>
<pre><code>location /images/ {       ——这是我们当前服务器上的目录
    rewrite http://172.16.2.27/images/;      ——把你转到另外一台服务器上的目录去了。
}
</code></pre><p>2.Nginx的rewrite<br>Nginx的rewrite支持正则表达式   ——可以将一类URL转成另一类URL</p>
<pre><code>Syntax: rewrite regex replacement [flag];
Default:    —
Context:    server, location, if
</code></pre><p>server区块中如果有包含rewrite规则,则会最先执行,而且只会执行一次, 然后再判断命中哪个location的配置。如果location中也配置了rewrite，会再去执行该location中的rewrite，当该location中的rewrite执行完毕时，rewrite并不会停止，而是根据rewrite过的URL再次判断location并执行其中的配置。那么，这里就存在一个问题，如果rewrite写的不正确的话，是会在location区块间造成无限循环的。所以nginx才会加一个最多重试10次的上限。比如：</p>
<pre><code>location / {
    root html;
    index index.html index.htm;
    rewrite ^/bbs/(.*)$ /forum/$1
}
</code></pre><p>flag：支持4种标志。</p>
<ul>
<li>last：本次重写完成之后重启下一轮检查。一般场景下用的都是last。</li>
<li>break：本次重写完成之后不启用下一轮检查，直接响应。</li>
<li>redirect：返回302临时重定向，地址栏会显示跳转后的地址</li>
<li>permanent： 返回301永久重定向，地址栏会显示跳转后的地址</li>
</ul>
<p>测验一下break与last的区别:</p>
<pre><code>location /test1.txt/ {
    rewrite /test1.txt/ /test2.txt break;
}

location ~ test2.txt {
    return 508;
}
</code></pre><p>使用break会停止匹配下面的location,直接发起请求www.xxx.com/test2.txt，由于不存在文件test2.txt，则会直接显示404。<br>使用last的话，会继续搜索下面是否有符合条件(符合重写后的/test2.txt请求)的location。此时，/test2.txt刚好与面location的条件对应上了，进入花括号{}里面的代码执行，这里会返回508。</p>
<h4 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h4><p>在location中使用if语句可以实现条件判断，其通常有一个return语句，且一般与有着last或break标记的rewrite规则一同使用。但其也可以按需要使用在多种场景下，需要注意的是，不当的使用可能会导致不可预料的后果。</p>
<pre><code>upstream imageservers {
    server 172.16.100.8:80 weight 2;
    server 172.16.100.9:80 weight 3;
}

location / {
    if ($request_method == “PUT”) {
        proxy_pass http://upload.wisedu.com:8080;
    } 

    if ($request_uri ~ &quot;\.(jpg|gif|jpeg|png)$&quot;) {
        proxy_pass http://imageservers;
        break; #这里的break也是停止rewrite检查
    }
}
</code></pre><p>if语句中的判断条件</p>
<p>正则表达式匹配：</p>
<pre><code>==: 等值比较；
~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；
~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；
!~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；
!~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；
</code></pre><p>文件及目录匹配判断：</p>
<pre><code>-f, !-f：判断指定的路径是否为存在且为文件；
-d, !-d：判断指定的路径是否为存在且为目录；
-e, !-e：判断指定的路径是否存在，文件或目录均可；
-x, !-x：判断指定路径的文件是否存在且可执行；
</code></pre><h2 id="http核心模块的内置变量"><a href="#http核心模块的内置变量" class="headerlink" title="http核心模块的内置变量"></a>http核心模块的内置变量</h2><pre><code>$uri: 当前请求的uri，不带参数；
$request_uri: 请求的uri，带完整参数；
$host: http请求报文中host首部；如果请求中没有host首部，则以处理此请求的虚拟主机的主机名代替；
$hostname: nginx服务运行在的主机的主机名；
$remote_addr: 客户端IP
$remote_port: 客户端Port
$remote_user: 使用用户认证时客户端用户输入的用户名；
$request_filename: 用户请求中的URI经过本地root或alias转换后映射的本地的文件路径；
$request_method: 请求方法
$server_addr: 服务器地址
$server_name: 服务器名称
$server_port: 服务器端口
$server_protocol: 服务器向客户端发送响应时的协议，如http/1.1, http/1.0
$scheme: 在请求中使用scheme, 如https://www.magedu.com/中的https；
$http_HEADER: 匹配请求报文中指定的HEADER，$http_host匹配请求报文中的host首部
$sent_http_HEADER: 匹配响应报文中指定的HEADER，例如$http_content_type匹配响应报文中的content-type首部；
$document_root：当前请求映射到的root配置；
</code></pre>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Nginx/" rel="tag"><i class="fa fa-tag"></i>Nginx</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/21/安装部署Openresty/" rel="next" title="安装部署Openresty">
                <i class="fa fa-chevron-left"></i> 安装部署Openresty
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/28/Nginx实现TCP负载均衡/" rel="prev" title="Nginx实现TCP负载均衡">
                Nginx实现TCP负载均衡 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


      <div id="lv-container" data-id="city" data-uid="MTAyMC8yODkyNi81NDk1"></div>

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Zhao Jiankai" />
          <p class="site-author-name" itemprop="name">Zhao Jiankai</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">89</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jkzhao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/3566507667/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.importnew.com/" title="ImportNew" target="_blank">ImportNew</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Nginx"><span class="nav-number">1.</span> <span class="nav-text">Nginx</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置文件有哪些"><span class="nav-number">2.</span> <span class="nav-text">配置文件有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置文件组织结构"><span class="nav-number">3.</span> <span class="nav-text">配置文件组织结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置main段"><span class="nav-number">4.</span> <span class="nav-text">配置main段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置Events段"><span class="nav-number">5.</span> <span class="nav-text">配置Events段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置http段"><span class="nav-number">6.</span> <span class="nav-text">配置http段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#套接字或主机相关配置"><span class="nav-number">6.1.</span> <span class="nav-text">套接字或主机相关配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路径相关的指令"><span class="nav-number">6.2.</span> <span class="nav-text">路径相关的指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端请求相关的配置"><span class="nav-number">6.3.</span> <span class="nav-text">客户端请求相关的配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对客户端请求的进行限制"><span class="nav-number">6.4.</span> <span class="nav-text">对客户端请求的进行限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx反向代理配置"><span class="nav-number">6.5.</span> <span class="nav-text">Nginx反向代理配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#proxy模块的指令"><span class="nav-number">6.5.1.</span> <span class="nav-text">proxy模块的指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nginx实现负载均衡-–upstream模块"><span class="nav-number">6.5.2.</span> <span class="nav-text">Nginx实现负载均衡 –upstream模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nginx的URL重写功能和if指令"><span class="nav-number">6.6.</span> <span class="nav-text">Nginx的URL重写功能和if指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#URL重写rewrite"><span class="nav-number">6.6.1.</span> <span class="nav-text">URL重写rewrite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if指令"><span class="nav-number">6.6.2.</span> <span class="nav-text">if指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http核心模块的内置变量"><span class="nav-number">7.</span> <span class="nav-text">http核心模块的内置变量</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhao Jiankai</span>
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共240.7k字</span>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  



  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("r9OTvh5qdm5WfVnhJBm4XoP9-gzGzoHsz", "VAES8qziiwbdUq0IzdQVj5xD");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

<!--    -->
</body>
</html>
